---
parse:
  title: "Legacy:Programmer Typology"
  text:
    text: "<blockquote class=\"legacyquote\">\n<p>{{{1}}}</p>\n</blockquote>\n<p></p>\n\
      <div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n</div>\n\
      <ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Programmer_Typology\"\
      ><span class=\"tocnumber\">1</span> <span class=\"toctext\">Programmer Typology</span></a>\n\
      <ul>\n<li class=\"toclevel-2 tocsection-2\"><a href=\"#Grimfort_writes_in_an_initial_statement:\"\
      ><span class=\"tocnumber\">1.1</span> <span class=\"toctext\">Grimfort writes\
      \ in an initial statement:</span></a></li>\n<li class=\"toclevel-2 tocsection-3\"\
      ><a href=\"#DFlor_elaborates_on_that_in_greater_detail:\"><span class=\"tocnumber\"\
      >1.2</span> <span class=\"toctext\">DFlor elaborates on that in greater detail:</span></a></li>\n\
      </ul>\n</li>\n<li class=\"toclevel-1 tocsection-4\"><a href=\"#Comments\"><span\
      \ class=\"tocnumber\">2</span> <span class=\"toctext\">Comments</span></a></li>\n\
      </ul>\n</div>\n<p></p>\n<h2><span class=\"mw-headline\" id=\"Programmer_Typology\"\
      >Programmer Typology</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Programmer_Typology?section=1\" title=\"Edit\
      \ section: Programmer Typology\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<h3><span class=\"mw-headline\" id=\"Grimfort_writes_in_an_initial_statement:\"\
      >Grimfort writes in an initial statement:</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Programmer_Typology?section=2\"\
      \ title=\"Edit section: Grimfort writes in an initial statement:\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>I myself consider\
      \ there to be two categories of programmer.</p>\n<p>There is the <b>code monkey</b>\
      \ who takes all your flowcharts, descriptions and other <i>diagrams</i>, and\
      \ types it into code; that is, a copy-and-paste coder.</p>\n<p>The other is\
      \ a <b>developer</b> who actually designs the classes/ideas around the system\
      \ based on the input from the game <i>designers</i>. These are the coders that\
      \ put their experience and skill into designing the system to look good, run\
      \ smooth and be <i>easy</i> to impliment.</p>\n<p>Give the developer an idea\
      \ of what you want, you're obviously looking for a programmer because you can't\
      \ do it yourself or have no time. Let them use their skills – that's their job.</p>\n\
      <p>If you are going to give detailed diagrams, ensure they are just a suggested\
      \ way of design.</p>\n<h3><span class=\"mw-headline\" id=\"DFlor_elaborates_on_that_in_greater_detail:\"\
      >DFlor elaborates on that in greater detail:</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Programmer_Typology?section=3\"\
      \ title=\"Edit section: DFlor elaborates on that in greater detail:\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>Actually, I have\
      \ two different categories of programmers:</p>\n<dl>\n<dt>The Automaton&#160;</dt>\n\
      <dd></dd>\n</dl>\n<p>Someone who was created by the university system and schooling.\
      \ These programmers know only how to do specific tasks, and otherwise have no\
      \ minds of their own. These are the type of programmers that could write an\
      \ entire quicksort routine from memory and use it over, and over, and over...\
      \ These are the kinds of guys that have eighteen different certifications.</p>\n\
      <p>These programmers are incapable of deviating from the norm – if you have\
      \ them do something that goes beyond anything they've done before, they're out\
      \ to sea without a paddle. For instance, if you want a progress indicator for\
      \ the above quicksort, they would spend days doing it because it's not documented\
      \ in any of their books.</p>\n<p>These programmers are good for grunt work,\
      \ work no true programmer wants to do. Converting data (the formats of which\
      \ are well defined), implementing user interfaces, etc...</p>\n<p>For these\
      \ programmers, a flowchart or some sort of document is essential, because they\
      \ need to know exactly what they need to do. If you want them to build a house,\
      \ you need to go as far as to tell them how many inches between each nail.</p>\n\
      <p><br /></p>\n<dl>\n<dt>The Free Thinker&#160;</dt>\n<dd></dd>\n</dl>\n<p>These\
      \ programmers are generally self-taught, rebelling against the establishment\
      \ and the educational systems. All the methods, all the reasoning, all the programming\
      \ creativity was not given to them – they had to learn it through trial and\
      \ error. These programmers probably didn't actually study computer science in\
      \ school (I've known patent lawyers and musicians that are damn good programmers),\
      \ and the only reason they would get a certification was because an employer\
      \ asked for it.</p>\n<p>These programmers need to be told what to do in the\
      \ most superficial of ways, and then left to their own devices as to how to\
      \ do it. You tell them where you want to go, and they'll pick the way that suits\
      \ them to get there.</p>\n<p>These are the kind of guys that you can simply\
      \ tell \"build me a house,\" but you do have to keep an eye on them or else\
      \ they'll build the house for themselves.</p>\n<p><br /></p>\n<p>\"Automatons\"\
      \ need a flowchart or a exceedingly detailed scope of work, design document,\
      \ etc... They need to be told down to the most vivid detail what you want. And,\
      \ believe me, they will do it down to the most vivid detail – if you accidentally\
      \ state that a pistol can carry 300 rounds of ammo instead of 30, 300 it will\
      \ be until told otherwise.</p>\n<p>\"Free thinkers\" could make do with a simple\
      \ design document, and you'll get to see how things progress through subsequent\
      \ builds.</p>\n<p>If you think I'm exaggerating this, you haven't worked in\
      \ the industry long enough.</p>\n<h2><span class=\"mw-headline\" id=\"Comments\"\
      >Comments</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Programmer_Typology?section=4\" title=\"Edit\
      \ section: Comments\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p><b>Mychaeel:</b> I found those comments worth preserving so they wouldn't\
      \ just glide into the oblivion of a forum archive or get crushed in a Great\
      \ Purge.</p>\n<p><b>Foxpaw:</b> I can't say that I completely agree with the\
      \ above.. I started out with and would consider myself to be in the second category\
      \ of both of those descriptions, but I've still taken some courses at University.\
      \ Most of the stuff was things I had already discovered, but in the two years\
      \ I've gone so far I picked up a couple of concepts I may not have come up with\
      \ myself: the red-black tree (which, admittedly, I don't use, but it's still\
      \ cool) and linked lists. (which I loathed at the time but now love) I find\
      \ that employers like to force people into the \"code monkey\"/\"automaton\"\
      \ role because the designers have their own vision of exactly how they want\
      \ things to work out. Once when I was working on an online game I suggested\
      \ that we change the implementation of the weapons (basically the weapons were\
      \ hard-coded) to a modular, configurable system that would be completely backwards\
      \ compatible but would allow for future expansion. This request was flatly denied\
      \ as it was \"unnecessary.\" I implemented it anyway, with full backwards compatibility,\
      \ and told noone.&#160;:P</p>\n<p><b>inio:</b> I agree with this to an extent.\
      \ However, I think these two posibilities represent poles on a continuum rather\
      \ than boolean abolutes.</p>\n<p><b>Mychaeel:</b> Having studied computer sciences\
      \ obviously doesn't immediately discount anyone as a \"code monkey,\" but you'll\
      \ get more of them out of university than there are self-taught ones. If somebody\
      \ has the mindset of a code monkey, they usually wouldn't have become self-taught\
      \ programmers in the first place. Again, as inio says, there are gradual differences,\
      \ not just black and white.</p>\n<p><b>Haral:</b> I'm trying to put into words\
      \ exactly why I don't like the above description. Maybe it's because of the\
      \ overly elitist attitude of the author, but I think it's more than that.</p>\n\
      <p>I am self-taught. My parents were programmers and refused to teach me a single\
      \ thing, as they wanted me to learn how to find my own solutions. This is something\
      \ nobody else can teach you. You have to learn to do it yourself. People can\
      \ give you tips, recommend resources, and give you encouragement. However, nobody\
      \ is going to teach you to find solutions on your own because then it wouldn't\
      \ be <b>on your own</b>.</p>\n<p>Programming is a constant state of learning\
      \ and thus it's all about finding your own solutions (<i>somebody</i> has gotta\
      \ find them, and if it's not you, why are you even in the picture?) Because\
      \ learning to do this is something you must do on your own, universities will\
      \ never be able to directly teach you to do this. This is why so many CS students\
      \ will idiotically say \"we haven't learned that yet\" rather than going and\
      \ <i>doing</i> it.</p>\n<p>However, it has nothing to do with universities.\
      \ They can't teach you that, but they can still be a valuable resource. After\
      \ all, our brains are all running different interperaters and sometimes you\
      \ just can't parse that load of crap you just read... other humans with that\
      \ understanding can help adapt it into something you can understand too.</p>\n\
      <p>So I wouldn't even call this 'programmer typology.' There's only one kind\
      \ of programmer: the one that writes code. This so-called 'code monkey' can\
      \ be replaced by downloadable modules.</p>\n<p><b>Dante:</b> Most people in\
      \ my university don't have enough coding practise. They used Perl/Java/Prolog/Pascal/...\
      \ for the things they needed it to pass their classes (like red-black trees&#160;;).\
      \ But most of them wouldn't even want to code for a project, let it be a mod\
      \ or some other thing. But it's their right to some extent, since cs&#160;!=\
      \ programming.</p>\n<p>I think <b>code monkey</b>s are people with other professions\
      \ like mappers. Like I create little cubic levels to test my code, they create\
      \ little cubic sourcecodes to test their maps (or so). The problem with this\
      \ is that maps share common code while code doesn't really depend on anything\
      \ else than code. Ok, I'm getting OT here...</p>\n<p><b>Mychaeel:</b> Obviously\
      \ nobody wants to be called \"code monkeys\" themselves, so I guess the definitions\
      \ will vary wildly to satisfy anyone. – I believe the described difference is\
      \ more comparable to that between a novel author and a technical writer: Granted,\
      \ you need the same basic skills and the creative demands of good technical\
      \ writing are not to be underestimated, but in the end they are not comparable\
      \ to the creativity and effort the author of a good novel has to put into developing\
      \ and writing an intriguing, complex and most of all believable story (especially\
      \ if it's not set in our contemporary world).</p>\n<p><b>EntropicLqd:</b> Heh.\
      \ I have three categories of programmers. Those who write code you know will\
      \ need to be re-written from the ground up before it goes live, those who write\
      \ code that will do the job as long as you don't need to extend it in some unexpected\
      \ direction, and those who write code that meets all of the stated requirements\
      \ and can be easily extended in unexpected directions. The differences between\
      \ them can be seen in the care and thought put into the split/categorisation/composition\
      \ of data structures and program function.</p>\n<p><b>Mychaeel:</b> I suppose\
      \ that categorization could be considered orthogonal to the one at the top of\
      \ this page&#160;;-) – I even suppose you're equally likely to get any of those\
      \ three sorts of code from either of the two alleged \"types\" of programmers\
      \ described above.</p>\n<p><b>EntropicLqd:</b> Heh - it's more of a probability\
      \ curve to be honest. The alleged first type of programmer is much more likely\
      \ to produce my first category of code than my final type (if they can manage\
      \ it at all). In my universe the second class of coders we have here would be\
      \ pretty much incapable of writing anything that fits in my first category (even\
      \ if it's a prototype). As already observed the two main programmer categories\
      \ are very much at opposite ends of a \"programmer type\" spectrum. Most programmers\
      \ will also have their \"type\" oscillate around their \"base position\" over\
      \ time.</p>\n\n<!-- \nNewPP limit report\nCPU time usage: 0.047 seconds\nReal\
      \ time usage: 0.048 seconds\nPreprocessor visited node count: 25/1000000\nPreprocessor\
      \ generated node count: 75/1000000\nPost‐expand include size: 110/2097152 bytes\n\
      Template argument size: 0/2097152 bytes\nHighest expansion depth: 3/40\nExpensive\
      \ parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report\
      \ (%,ms,calls,template)\n100.00%    5.766      1 - -total\n100.00%    5.766\
      \      1 - Template:Innerbox\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:2485-0!*!*!!en!*!*\
      \ and timestamp 20221120202419 and revision id 5962\n -->\n"
  categories: []
  links: []
  templates:
  - ns: 10
    exists: true
    name: "Template:Innerbox"
  images: []
  externallinks: []
  sections:
  - toclevel: 1
    level: "2"
    line: "Programmer Typology"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Programmer_Typology"
    byteoffset: 647
    anchor: "Programmer_Typology"
  - toclevel: 2
    level: "3"
    line: "Grimfort writes in an initial statement:"
    number: "1.1"
    index: "2"
    fromtitle: "Legacy:Programmer_Typology"
    byteoffset: 672
    anchor: "Grimfort_writes_in_an_initial_statement:"
  - toclevel: 2
    level: "3"
    line: "DFlor elaborates on that in greater detail:"
    number: "1.2"
    index: "3"
    fromtitle: "Legacy:Programmer_Typology"
    byteoffset: 1496
    anchor: "DFlor_elaborates_on_that_in_greater_detail:"
  - toclevel: 1
    level: "2"
    line: "Comments"
    number: "2"
    index: "4"
    fromtitle: "Legacy:Programmer_Typology"
    byteoffset: 4213
    anchor: "Comments"
  displaytitle: "Legacy:Programmer Typology"
  iwlinks: []
  wikitext:
    text: "{{innerbox| ''The following two statements were posted in an [http://www.ataricommunity.com/forums/showthread.php?threadid=308914\
      \ Atari forum thread] in response to somebody's question about the \"flowcharts\"\
      \ that are mentioned as such pivotal recruitment devices in [[Legacy:How To\
      \ Recruit A Programmer|How to Recruit a Programmer]].''\n\n ''The postings have\
      \ been edited for typos and layout, but are otherwise unaltered. Feel free to\
      \ scroll down and comment.''\n\n ''...and don't take this too seriously, please.\
      \  It does raise an important point on the subject of the mentioned \"flowcharts\"\
      \ though.  Be sure to read the comment section too.''\n\n}}\n\n==Programmer\
      \ Typology==\n\n===Grimfort writes in an initial statement:===\n\nI myself consider\
      \ there to be two categories of programmer.\n\nThere is the '''code monkey'''\
      \ who takes all your flowcharts, descriptions and other ''diagrams'', and types\
      \ it into code; that is, a copy-and-paste coder.\n\nThe other is a '''developer'''\
      \ who actually designs the classes/ideas around the system based on the input\
      \ from the game ''designers''. These are the coders that put their experience\
      \ and skill into designing the system to look good, run smooth and be ''easy''\
      \ to impliment.\n\nGive the developer an idea of what you want, you're obviously\
      \ looking for a programmer because you can't do it yourself or have no time.\
      \ Let them use their skills &ndash; that's their job.\n\nIf you are going to\
      \ give detailed diagrams, ensure they are just a suggested way of design.\n\n\
      ===DFlor elaborates on that in greater detail:===\n\nActually, I have two different\
      \ categories of programmers:\n\n; The Automaton : \nSomeone who was created\
      \ by the university system and schooling. These programmers know only how to\
      \ do specific tasks, and otherwise have no minds of their own. These are the\
      \ type of programmers that could write an entire quicksort routine from memory\
      \ and use it over, and over, and over... These are the kinds of guys that have\
      \ eighteen different certifications.\n\nThese programmers are incapable of deviating\
      \ from the norm &ndash; if you have them do something that goes beyond anything\
      \ they've done before, they're out to sea without a paddle. For instance, if\
      \ you want a progress indicator for the above quicksort, they would spend days\
      \ doing it because it's not documented in any of their books.\n\nThese programmers\
      \ are good for grunt work, work no true programmer wants to do. Converting data\
      \ (the formats of which are well defined), implementing user interfaces, etc...\n\
      \nFor these programmers, a flowchart or some sort of document is essential,\
      \ because they need to know exactly what they need to do. If you want them to\
      \ build a house, you need to go as far as to tell them how many inches between\
      \ each nail.\n\n\n\n; The Free Thinker : \nThese programmers are generally self-taught,\
      \ rebelling against the establishment and the educational systems. All the methods,\
      \ all the reasoning, all the programming creativity was not given to them &ndash;\
      \ they had to learn it through trial and error. These programmers probably didn't\
      \ actually study computer science in school (I've known patent lawyers and musicians\
      \ that are damn good programmers), and the only reason they would get a certification\
      \ was because an employer asked for it.\n\nThese programmers need to be told\
      \ what to do in the most superficial of ways, and then left to their own devices\
      \ as to how to do it. You tell them where you want to go, and they'll pick the\
      \ way that suits them to get there.\n\nThese are the kind of guys that you can\
      \ simply tell \"build me a house,\" but you do have to keep an eye on them or\
      \ else they'll build the house for themselves.\n\n\n\n\"Automatons\" need a\
      \ flowchart or a exceedingly detailed scope of work, design document, etc...\
      \ They need to be told down to the most vivid detail what you want. And, believe\
      \ me, they will do it down to the most vivid detail &ndash; if you accidentally\
      \ state that a pistol can carry 300 rounds of ammo instead of 30, 300 it will\
      \ be until told otherwise.\n\n\"Free thinkers\" could make do with a simple\
      \ design document, and you'll get to see how things progress through subsequent\
      \ builds.\n\nIf you think I'm exaggerating this, you haven't worked in the industry\
      \ long enough.\n\n==Comments==\n\n'''Mychaeel:''' I found those comments worth\
      \ preserving so they wouldn't just glide into the oblivion of a forum archive\
      \ or get crushed in a Great Purge.\n\n'''Foxpaw:''' I can't say that I completely\
      \ agree with the above.. I started out with and would consider myself to be\
      \ in the second category of both of those descriptions, but I've still taken\
      \ some courses at University. Most of the stuff was things I had already discovered,\
      \ but in the two years I've gone so far I picked up a couple of concepts I may\
      \ not have come up with myself: the red-black tree (which, admittedly, I don't\
      \ use, but it's still cool) and linked lists. (which I loathed at the time but\
      \ now love) I find that employers like to force people into the \"code monkey\"\
      /\"automaton\" role because the designers have their own vision of exactly how\
      \ they want things to work out. Once when I was working on an online game I\
      \ suggested that we change the implementation of the weapons (basically the\
      \ weapons were hard-coded) to a modular, configurable system that would be completely\
      \ backwards compatible but would allow for future expansion. This request was\
      \ flatly denied as it was \"unnecessary.\" I implemented it anyway, with full\
      \ backwards compatibility, and told noone. :P\n\n'''inio:''' I agree with this\
      \ to an extent.  However, I think these two posibilities represent poles on\
      \ a continuum rather than boolean abolutes.\n\n'''Mychaeel:''' Having studied\
      \ computer sciences obviously doesn't immediately discount anyone as a \"code\
      \ monkey,\" but you'll get more of them out of university than there are self-taught\
      \ ones.  If somebody has the mindset of a code monkey, they usually wouldn't\
      \ have become self-taught programmers in the first place.  Again, as inio says,\
      \ there are gradual differences, not just black and white.\n\n'''Haral:''' I'm\
      \ trying to put into words exactly why I don't like the above description. \
      \ Maybe it's because of the overly elitist attitude of the author, but I think\
      \ it's more than that.\n\nI am self-taught.  My parents were programmers and\
      \ refused to teach me a single thing, as they wanted me to learn how to find\
      \ my own solutions.  This is something nobody else can teach you.  You have\
      \ to learn to do it yourself.  People can give you tips, recommend resources,\
      \ and give you encouragement.  However, nobody is going to teach you to find\
      \ solutions on your own because then it wouldn't be '''on your own'''.\n\nProgramming\
      \ is a constant state of learning and thus it's all about finding your own solutions\
      \ (''somebody'' has gotta find them, and if it's not you, why are you even in\
      \ the picture?)  Because learning to do this is something you must do on your\
      \ own, universities will never be able to directly teach you to do this.  This\
      \ is why so many CS students will idiotically say \"we haven't learned that\
      \ yet\" rather than going and ''doing'' it.\n\nHowever, it has nothing to do\
      \ with universities.  They can't teach you that, but they can still be a valuable\
      \ resource.  After all, our brains are all running different interperaters and\
      \ sometimes you just can't parse that load of crap you just read... other humans\
      \ with that understanding can help adapt it into something you can understand\
      \ too.\n\nSo I wouldn't even call this 'programmer typology.' There's only one\
      \ kind of programmer:  the one that writes code.  This so-called 'code monkey'\
      \ can be replaced by downloadable modules.\n\n'''Dante:''' Most people in my\
      \ university don't have enough coding practise. They used Perl/Java/Prolog/Pascal/...\
      \ for the things they needed it to pass their classes (like red-black trees\
      \ ;). But most of them wouldn't even want to code for a project, let it be a\
      \ mod or some other thing. But it's their right to some extent, since cs !=\
      \ programming.\n\nI think '''code monkey'''s are people with other professions\
      \ like mappers. Like I create little cubic levels to test my code, they create\
      \ little cubic sourcecodes to test their maps (or so). The problem with this\
      \ is that maps share common code while code doesn't really depend on anything\
      \ else than code. Ok, I'm getting OT here...\n\n'''Mychaeel:''' Obviously nobody\
      \ wants to be called \"code monkeys\" themselves, so I guess the definitions\
      \ will vary wildly to satisfy anyone. &ndash; I believe the described difference\
      \ is more comparable to that between a novel author and a technical writer:\
      \  Granted, you need the same basic skills and the creative demands of good\
      \ technical writing are not to be underestimated, but in the end they are not\
      \ comparable to the creativity and effort the author of a good novel has to\
      \ put into developing and writing an intriguing, complex and most of all believable\
      \ story (especially if it's not set in our contemporary world).\n\n'''EntropicLqd:'''\
      \ Heh.  I have three categories of programmers.  Those who write code you know\
      \ will need to be re-written from the ground up before it goes live, those who\
      \ write code that will do the job as long as you don't need to extend it in\
      \ some unexpected direction, and those who write code that meets all of the\
      \ stated requirements and can be easily extended in unexpected directions. \
      \ The differences between them can be seen in the care and thought put into\
      \ the split/categorisation/composition of data structures and program function.\n\
      \n'''Mychaeel:''' I suppose that categorization could be considered orthogonal\
      \ to the one at the top of this page ;-) &ndash; I even suppose you're equally\
      \ likely to get any of those three sorts of code from either of the two alleged\
      \ \"types\" of programmers described above.\n\n'''EntropicLqd:'''  Heh - it's\
      \ more of a probability curve to be honest.  The alleged first type of programmer\
      \ is much more likely to produce my first category of code than my final type\
      \ (if they can manage it at all).  In my universe the second class of coders\
      \ we have here would be pretty much incapable of writing anything that fits\
      \ in my first category (even if it's a prototype).  As already observed the\
      \ two main programmer categories are very much at opposite ends of a \"programmer\
      \ type\" spectrum.  Most programmers will also have their \"type\" oscillate\
      \ around their \"base position\" over time."
  properties: []
  revId: 5962
name: "Legacy:Programmer Typology"
revision:
  revid: 5962
  parentid: 5963
  user: "EntropicLqd"
  timestamp: 1059294793.000000000
  comment: "orthogonal - I like that"
timestamp: 1668975600.186354000
