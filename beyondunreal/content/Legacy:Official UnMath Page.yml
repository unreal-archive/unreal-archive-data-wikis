---
parse:
  title: "Legacy:Official UnMath Page"
  text:
    text: "<h2><span class=\"mw-headline\" id=\"Introduction\">Introduction</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Official_UnMath_Page?section=1\" title=\"Edit section:\
      \ Introduction\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>The UnMath.h Header File (from, <a rel=\"nofollow\" class=\"external text\"\
      \ href=\"http://unreal.epicgames.com/files/ut432pubsrc.zip\">Unreal Tournament\
      \ 432 C++ Publicly Released Headers</a>) might more properly belong in the Unreal\
      \ Engine Core section, since it is integral to every critical process that the\
      \ Engine performs.<br /></p>\n<p>The Official UnMath Page is derived from that\
      \ Header File Released from Epic Games and coded in C++. The following is just\
      \ a section from the file, that describes FVectors. It appears in the original\
      \ Tim Sweeney code; an uncompiled text file.<br /></p>\n<p>The complete UnMath.h\
      \ file contains all the mathematical routines used by the Unreal Engine for\
      \ collision detection, the Artificial Intelligence of Bots, and the physics\
      \ (yes, even the Quaternion Rotations), and, ultimately, the rendering of the\
      \ scene. It's WAY <a href=\"/edit/Legacy:L33t?redlink=1\" class=\"new\" title=\"\
      Legacy:L33t (page does not exist)\">l33t</a>,...but, unfortunately, WAY humungeous.<br\
      \ /></p>\n<p>We should have an analysis page to acompany it.<br /></p>\n<p>It\
      \ will take you at least 5 years to read it all,...and by that time the Engine\
      \ hierarchy will have evolved into something incomprehensible and extremely\
      \ highly advanced.</p>\n<p><i>Preface:</i> The acronym API stands for Application\
      \ Programming Interface. Just to give you an idea of the insane complexity of\
      \ the UnMath routines, I have included a snippet of code for an important function\
      \ <u><b>FuzzVectors</b></u>:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"coMULTI\">/*-----------------------------------------------------------------------------\n\
      \tFVector.\n -----------------------------------------------------------------------------*/</span>\n\
      \ <span class=\"co1\">// Information associated with a floating point vector,\
      \ describing its</span>\n <span class=\"co1\">// status as a point in a rendering\
      \ context.</span>\n <span class=\"kw1\">enum</span> EVectorFlags\n <span class=\"\
      br0\">{</span>\n\tFVF_OutXMin\t\t<span class=\"sy0\">=</span> 0x04,\t<span class=\"\
      co1\">// Outcode rejection, off left hand side of screen.</span>\n\tFVF_OutXMax\t\
      \t<span class=\"sy0\">=</span> 0x08,\t<span class=\"co1\">// Outcode rejection,\
      \ off right hand side of screen.</span>\n\tFVF_OutYMin\t\t<span class=\"sy0\"\
      >=</span> 0x10,\t<span class=\"co1\">// Outcode rejection, off top of screen.</span>\n\
      \tFVF_OutYMax\t\t<span class=\"sy0\">=</span> 0x20,\t<span class=\"co1\">//\
      \ Outcode rejection, off bottom of screen.</span>\n\tFVF_OutNear     <span class=\"\
      sy0\">=</span> 0x40, <span class=\"co1\">// Near clipping plane.</span>\n\t\
      FVF_OutFar      <span class=\"sy0\">=</span> 0x80, <span class=\"co1\">// Far\
      \ clipping plane.</span>\n\tFVF_OutReject   <span class=\"sy0\">=</span> <span\
      \ class=\"br0\">(</span>FVF_OutXMin <span class=\"sy0\">|</span> FVF_OutXMax\
      \ <span class=\"sy0\">|</span> FVF_OutYMin <span class=\"sy0\">|</span> FVF_OutYMax<span\
      \ class=\"br0\">)</span>, <span class=\"co1\">//  Outcode rejectable.</span>\n\
      \tFVF_OutSkip\t\t<span class=\"sy0\">=</span> <span class=\"br0\">(</span>FVF_OutXMin\
      \ <span class=\"sy0\">|</span> FVF_OutXMax <span class=\"sy0\">|</span> FVF_OutYMin\
      \ <span class=\"sy0\">|</span> FVF_OutYMax<span class=\"br0\">)</span>, <span\
      \ class=\"co1\">// Outcode clippable.</span>\n <span class=\"br0\">}</span>;\n\
      \ \n <span class=\"co1\">//</span>\n <span class=\"co1\">// Floating point vector.</span>\n\
      \ <span class=\"co1\">// Playstation2 vectors are 16 bytes.</span>\n <span class=\"\
      co1\">//</span>\n <span class=\"co2\">#if __PSX2_EE__</span>\n <span class=\"\
      co2\">#define FVECTOR_ALIGNMENT 16</span>\n <span class=\"kw1\">class</span>\
      \ CORE_API FVector \n <span class=\"br0\">{</span>\n <span class=\"kw1\">public</span>:\n\
      \t<span class=\"co1\">// Variables.</span>\n\t<span class=\"kw5\">FLOAT</span>\
      \ X, Y, Z, W;\n \n\t<span class=\"co1\">// Constructors.</span>\n\tFVector<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n\t<span class=\"br0\"\
      >{</span><span class=\"br0\">}</span>\n \n\tFVector<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">FLOAT</span> InX, <span class=\"kw5\">FLOAT</span> InY,\
      \ <span class=\"kw5\">FLOAT</span> InZ <span class=\"br0\">)</span>\n\t:\tX<span\
      \ class=\"br0\">(</span>InX<span class=\"br0\">)</span>, Y<span class=\"br0\"\
      >(</span>InY<span class=\"br0\">)</span>, Z<span class=\"br0\">(</span>InZ<span\
      \ class=\"br0\">)</span>, W<span class=\"br0\">(</span><span class=\"nu0\">1</span>.<span\
      \ class=\"me0\">f</span><span class=\"br0\">)</span>\n\t<span class=\"br0\"\
      >{</span><span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Binary math\
      \ operators.</span>\n\tinline FVector <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">^</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\tFVector r;\n\
      \t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\t\
      lqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\t\t\tvopmula.xyz\tACCxyz,\
      \ vf2xyz, vf3xyz\n\t\t\tvopmsub.xyz\tvf1xyz, vf3xyz, vf2xyz\n\t\t\tsqc2\t\t\
      vf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"st0\">\"r\"</span>\
      \ <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>r<span class=\"\
      br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span>this<span\
      \ class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\"\
      >(</span><span class=\"sy0\">&amp;</span>V<span class=\"br0\">)</span>\n\t\t\
      : <span class=\"st0\">\"memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\
      \t\t<span class=\"kw2\">return</span> r;\n\t<span class=\"br0\">}</span>\n\t\
      inline <span class=\"kw5\">FLOAT</span> <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">|</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\tFVector r;\n\
      \t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\t\
      lqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\t\t\tvmul.xyz\tvf1, vf2,\
      \ vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"\
      st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>r<span\
      \ class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\"\
      >(</span>this<span class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span>\
      \ <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>V<span class=\"\
      br0\">)</span>\n\t\t: <span class=\"st0\">\"memory\"</span>\n\t\t<span class=\"\
      br0\">)</span>;\n\t\t<span class=\"kw2\">return</span> r.<span class=\"me0\"\
      >X</span> <span class=\"sy0\">+</span> r.<span class=\"me0\">Y</span> <span\
      \ class=\"sy0\">+</span> r.<span class=\"me0\">Z</span>;\n\t<span class=\"br0\"\
      >}</span>\n\tfriend FVector <span class=\"kw1\">operator</span><span class=\"\
      sy0\">*</span><span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span>\
      \ <span class=\"kw5\">Scale</span>, <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span class=\"\
      br0\">(</span> V.<span class=\"me0\">X</span> <span class=\"sy0\">*</span> <span\
      \ class=\"kw5\">Scale</span>, V.<span class=\"me0\">Y</span> <span class=\"\
      sy0\">*</span> <span class=\"kw5\">Scale</span>, V.<span class=\"me0\">Z</span>\
      \ <span class=\"sy0\">*</span> <span class=\"kw5\">Scale</span> <span class=\"\
      br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\tinline FVector <span class=\"\
      kw1\">operator</span><span class=\"sy0\">+</span><span class=\"br0\">(</span>\
      \ <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V\
      \ <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\tFVector r;\n\t\tasm volatile <span class=\"br0\">(</span><span\
      \ class=\"st0\">\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\
      \t\t\tvadd.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\
      \t:\n\t\t: <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span\
      \ class=\"sy0\">&amp;</span>r<span class=\"br0\">)</span>, <span class=\"st0\"\
      >\"r\"</span> <span class=\"br0\">(</span>this<span class=\"br0\">)</span>,\
      \ <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"\
      sy0\">&amp;</span>V<span class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"\
      memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\"\
      >return</span> r;\n\t<span class=\"br0\">}</span>\n\tinline FVector operator<span\
      \ class=\"sy0\">-</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\tFVector r;\n\
      \t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\t\
      lqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\t\t\tvsub.xyz\tvf1, vf2,\
      \ vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"\
      st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>r<span\
      \ class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\"\
      >(</span>this<span class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span>\
      \ <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>V<span class=\"\
      br0\">)</span>\n\t\t: <span class=\"st0\">\"memory\"</span>\n\t\t<span class=\"\
      br0\">)</span>;\n\t\t<span class=\"kw2\">return</span> r;\n\t<span class=\"\
      br0\">}</span>\n\tinline FVector <span class=\"kw1\">operator</span><span class=\"\
      sy0\">*</span><span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span>\
      \ <span class=\"kw5\">Scale</span> <span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\tFVector r;\n\t\tasm\
      \ volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\tctc2\t\t\
      %2,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tvmuli.xyz\tvf1, vf2, I\n\t\t\t\
      sqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"st0\">\"r\"\
      </span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>r<span class=\"\
      br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span>this<span\
      \ class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\"\
      >(</span><span class=\"kw5\">Scale</span><span class=\"br0\">)</span>\n\t\t\
      : <span class=\"st0\">\"memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\
      \t\t<span class=\"kw2\">return</span> r;\n\t<span class=\"br0\">}</span>\n\t\
      inline FVector <span class=\"kw1\">operator</span><span class=\"sy0\">/</span><span\
      \ class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span> <span class=\"kw5\"\
      >Scale</span> <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> RScale\
      \ <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\"\
      >f</span><span class=\"sy0\">/</span><span class=\"kw5\">Scale</span>;\n\t\t\
      FVector r;\n\t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\"\
      >\"\n\t\t\tctc2\t\t%2,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tvmuli.xyz\t\
      vf1, vf2, I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span\
      \ class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"sy0\"\
      >&amp;</span>r<span class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span>\
      \ <span class=\"br0\">(</span>this<span class=\"br0\">)</span>, <span class=\"\
      st0\">\"r\"</span> <span class=\"br0\">(</span>RScale<span class=\"br0\">)</span>\n\
      \t\t: <span class=\"st0\">\"memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\
      \t\t<span class=\"kw2\">return</span> r;\n\t<span class=\"br0\">}</span>\n\t\
      inline FVector <span class=\"kw1\">operator</span><span class=\"sy0\">*</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\tFVector r;\n\t\tasm volatile <span class=\"\
      br0\">(</span><span class=\"st0\">\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\
      \tvf3, 0x00(%2)\n\t\t\tvmul.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\
      \t\t\"</span>\n\t\t:\n\t\t: <span class=\"st0\">\"r\"</span> <span class=\"\
      br0\">(</span><span class=\"sy0\">&amp;</span>r<span class=\"br0\">)</span>,\
      \ <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span>this<span class=\"\
      br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span\
      \ class=\"sy0\">&amp;</span>V<span class=\"br0\">)</span>\n\t\t: <span class=\"\
      st0\">\"memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\t\t<span class=\"\
      kw2\">return</span> r;\n\t<span class=\"br0\">}</span>\n \n\t<span class=\"\
      co1\">// Binary comparison operators.</span>\n\tUBOOL <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">==</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> X<span class=\"sy0\">==</span>V.<span class=\"me0\">X</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> Y<span class=\"sy0\">==</span>V.<span\
      \ class=\"me0\">Y</span> <span class=\"sy0\">&amp;&amp;</span> Z<span class=\"\
      sy0\">==</span>V.<span class=\"me0\">Z</span>;\n\t<span class=\"br0\">}</span>\n\
      \tUBOOL <span class=\"kw1\">operator</span><span class=\"sy0\">!=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span\
      \ class=\"sy0\">!=</span>V.<span class=\"me0\">X</span> <span class=\"sy0\"\
      >||</span> Y<span class=\"sy0\">!=</span>V.<span class=\"me0\">Y</span> <span\
      \ class=\"sy0\">||</span> Z<span class=\"sy0\">!=</span>V.<span class=\"me0\"\
      >Z</span>;\n\t<span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Unary\
      \ operators.</span>\n\tFVector operator<span class=\"sy0\">-</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> <span class=\"sy0\">-</span>X, <span class=\"sy0\"\
      >-</span>Y, <span class=\"sy0\">-</span>Z <span class=\"br0\">)</span>;\n\t\
      <span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Assignment operators.</span>\n\
      \tinline FVector <span class=\"kw1\">operator</span><span class=\"sy0\">+=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\
      \t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\t\
      lqc2\t\tvf2, 0x00(%0)\n\t\t\tlqc2\t\tvf3, 0x00(%1)\n\t\t\tvadd.xyz\tvf1, vf2,\
      \ vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t: \n\t\t: <span class=\"\
      st0\">\"r\"</span> <span class=\"br0\">(</span>this<span class=\"br0\">)</span>,\
      \ <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"\
      sy0\">&amp;</span>V<span class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"\
      memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\"\
      >return</span> <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\
      \tinline FVector operator<span class=\"sy0\">-=</span><span class=\"br0\">(</span>\
      \ <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\tasm volatile\
      \ <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\
      \t\t\tlqc2\t\tvf3, 0x00(%1)\n\t\t\tvsub.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1,\
      \ 0x00(%0)\n\t\t\"</span>\n\t\t: \n\t\t: <span class=\"st0\">\"r\"</span> <span\
      \ class=\"br0\">(</span>this<span class=\"br0\">)</span>, <span class=\"st0\"\
      >\"r\"</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>V<span\
      \ class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"memory\"</span>\n\t\t\
      <span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\">return</span> <span class=\"\
      sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\tinline FVector <span\
      \ class=\"kw1\">operator</span><span class=\"sy0\">*=</span><span class=\"br0\"\
      >(</span> <span class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span>\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\tasm volatile\
      \ <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\tctc2\t\t%1,  $21\n\
      \t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\tvmuli.xyz\tvf1, vf2, I\n\t\t\tsqc2\t\tvf1,\
      \ 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"st0\">\"r\"</span> <span\
      \ class=\"br0\">(</span>this<span class=\"br0\">)</span>, <span class=\"st0\"\
      >\"r\"</span> <span class=\"br0\">(</span><span class=\"kw5\">Scale</span><span\
      \ class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"memory\"</span>\n\t\t\
      <span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\">return</span> <span class=\"\
      sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\tinline FVector <span\
      \ class=\"kw1\">operator</span><span class=\"sy0\">/=</span><span class=\"br0\"\
      >(</span> <span class=\"kw5\">FLOAT</span> V <span class=\"br0\">)</span>\n\t\
      <span class=\"br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> RScale <span\
      \ class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\">f</span><span\
      \ class=\"sy0\">/</span>V;\n\t\tasm volatile <span class=\"br0\">(</span><span\
      \ class=\"st0\">\"\n\t\t\tctc2\t\t%1,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\
      \tvmuli.xyz\tvf1, vf2, I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\
      \t\t: <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span>this<span\
      \ class=\"br0\">)</span>, <span class=\"st0\">\"r\"</span> <span class=\"br0\"\
      >(</span>RScale<span class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"memory\"\
      </span>\n\t\t<span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\">return</span>\
      \ <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\tinline\
      \ FVector <span class=\"kw1\">operator</span><span class=\"sy0\">*=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\
      \t\tasm volatile <span class=\"br0\">(</span><span class=\"st0\">\"\n\t\t\t\
      lqc2\t\tvf2, 0x00(%0)\n\t\t\tlqc2\t\tvf3, 0x00(%1)\n\t\t\tvmul.xyz\tvf1, vf2,\
      \ vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"</span>\n\t\t:\n\t\t: <span class=\"\
      st0\">\"r\"</span> <span class=\"br0\">(</span>this<span class=\"br0\">)</span>,\
      \ <span class=\"st0\">\"r\"</span> <span class=\"br0\">(</span><span class=\"\
      sy0\">&amp;</span>V<span class=\"br0\">)</span>\n\t\t: <span class=\"st0\">\"\
      memory\"</span>\n\t\t<span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\"\
      >return</span> <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\
      \tFVector <span class=\"kw1\">operator</span><span class=\"sy0\">/=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\
      \t\tX <span class=\"sy0\">/=</span> V.<span class=\"me0\">X</span>; Y <span\
      \ class=\"sy0\">/=</span> V.<span class=\"me0\">Y</span>; Z <span class=\"sy0\"\
      >/=</span> V.<span class=\"me0\">Z</span>;\n\t\t<span class=\"kw2\">return</span>\
      \ <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n \n\t<span\
      \ class=\"co1\">// Simple functions.</span>\n\t<span class=\"kw5\">FLOAT</span>\
      \ Size<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\"\
      >return</span> appSqrt<span class=\"br0\">(</span> X<span class=\"sy0\">*</span>X\
      \ <span class=\"sy0\">+</span> Y<span class=\"sy0\">*</span>Y <span class=\"\
      sy0\">+</span> Z<span class=\"sy0\">*</span>Z <span class=\"br0\">)</span>;\n\
      \t<span class=\"br0\">}</span>\n\t<span class=\"kw5\">FLOAT</span> SizeSquared<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span\
      \ class=\"sy0\">*</span>X <span class=\"sy0\">+</span> Y<span class=\"sy0\"\
      >*</span>Y <span class=\"sy0\">+</span> Z<span class=\"sy0\">*</span>Z;\n\t\
      <span class=\"br0\">}</span>\n\t<span class=\"kw5\">FLOAT</span> Size2D<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\
      \ \n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> appSqrt<span\
      \ class=\"br0\">(</span> X<span class=\"sy0\">*</span>X <span class=\"sy0\"\
      >+</span> Y<span class=\"sy0\">*</span>Y <span class=\"br0\">)</span>;\n\t<span\
      \ class=\"br0\">}</span>\n\t<span class=\"kw5\">FLOAT</span> SizeSquared2D<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\
      \ \n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span\
      \ class=\"sy0\">*</span>X <span class=\"sy0\">+</span> Y<span class=\"sy0\"\
      >*</span>Y;\n\t<span class=\"br0\">}</span>\n\t<span class=\"kw5\">int</span>\
      \ IsNearlyZero<span class=\"br0\">(</span><span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span>\n\t\t\t\t<span class=\"kw3\">Abs</span><span class=\"br0\"\
      >(</span>X<span class=\"br0\">)</span><span class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER\n\
      \t\t\t<span class=\"sy0\">&amp;&amp;</span>\t<span class=\"kw3\">Abs</span><span\
      \ class=\"br0\">(</span>Y<span class=\"br0\">)</span><span class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER\n\
      \t\t\t<span class=\"sy0\">&amp;&amp;</span>\t<span class=\"kw3\">Abs</span><span\
      \ class=\"br0\">(</span>Z<span class=\"br0\">)</span><span class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER;\n\
      \t<span class=\"br0\">}</span>\n\tUBOOL IsZero<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span class=\"sy0\">==</span><span\
      \ class=\"nu0\">0</span>.<span class=\"me0\">f</span> <span class=\"sy0\">&amp;&amp;</span>\
      \ Y<span class=\"sy0\">==</span><span class=\"nu0\">0</span>.<span class=\"\
      me0\">f</span> <span class=\"sy0\">&amp;&amp;</span> Z<span class=\"sy0\">==</span><span\
      \ class=\"nu0\">0</span>.<span class=\"me0\">f</span>;\n\t<span class=\"br0\"\
      >}</span>\n\tUBOOL <span class=\"kw3\">Normalize</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw5\">FLOAT</span> SquareSum <span class=\"sy0\">=</span> X<span class=\"sy0\"\
      >*</span>X<span class=\"sy0\">+</span>Y<span class=\"sy0\">*</span>Y<span class=\"\
      sy0\">+</span>Z<span class=\"sy0\">*</span>Z;\n\t\t<span class=\"kw2\">if</span><span\
      \ class=\"br0\">(</span> SquareSum <span class=\"sy0\">&gt;=</span> SMALL_NUMBER\
      \ <span class=\"br0\">)</span>\n\t\t<span class=\"br0\">{</span>\n\t\t\t<span\
      \ class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span> <span class=\"\
      sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\">f</span><span\
      \ class=\"sy0\">/</span>appSqrt<span class=\"br0\">(</span>SquareSum<span class=\"\
      br0\">)</span>;\n\t\t\tX <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\
      \ Y <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>; Z <span\
      \ class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\n\t\t\t<span class=\"\
      kw2\">return</span> <span class=\"nu0\">1</span>;\n\t\t<span class=\"br0\">}</span>\n\
      \t\t<span class=\"kw2\">else</span> <span class=\"kw2\">return</span> <span\
      \ class=\"nu0\">0</span>;\n\t<span class=\"br0\">}</span>\n\tFVector Projection<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> RZ <span\
      \ class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\">f</span><span\
      \ class=\"sy0\">/</span>Z;\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> X<span class=\"sy0\">*</span>RZ, Y<span class=\"sy0\"\
      >*</span>RZ, <span class=\"nu0\">1</span> <span class=\"br0\">)</span>;\n\t\
      <span class=\"br0\">}</span>\n\tFVector UnsafeNormal<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span>\
      \ <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\"\
      >f</span><span class=\"sy0\">/</span>appSqrt<span class=\"br0\">(</span>X<span\
      \ class=\"sy0\">*</span>X<span class=\"sy0\">+</span>Y<span class=\"sy0\">*</span>Y<span\
      \ class=\"sy0\">+</span>Z<span class=\"sy0\">*</span>Z<span class=\"br0\">)</span>;\n\
      \t\t<span class=\"kw2\">return</span> FVector<span class=\"br0\">(</span> X<span\
      \ class=\"sy0\">*</span><span class=\"kw5\">Scale</span>, Y<span class=\"sy0\"\
      >*</span><span class=\"kw5\">Scale</span>, Z<span class=\"sy0\">*</span><span\
      \ class=\"kw5\">Scale</span> <span class=\"br0\">)</span>;\n\t<span class=\"\
      br0\">}</span>\n\tFVector GridSnap<span class=\"br0\">(</span> <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Grid <span class=\"\
      br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span>\
      \ FVector<span class=\"br0\">(</span> FSnap<span class=\"br0\">(</span>X, Grid.<span\
      \ class=\"me0\">X</span><span class=\"br0\">)</span>,FSnap<span class=\"br0\"\
      >(</span>Y, Grid.<span class=\"me0\">Y</span><span class=\"br0\">)</span>,FSnap<span\
      \ class=\"br0\">(</span>Z, Grid.<span class=\"me0\">Z</span><span class=\"br0\"\
      >)</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\t\
      FVector BoundToCube<span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span>\
      \ Radius <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t\
      <span class=\"kw2\">return</span> FVector\n\t\t<span class=\"br0\">(</span>\n\
      \t\t\t<span class=\"kw3\">Clamp</span><span class=\"br0\">(</span>X,<span class=\"\
      sy0\">-</span>Radius,Radius<span class=\"br0\">)</span>,\n\t\t\t<span class=\"\
      kw3\">Clamp</span><span class=\"br0\">(</span>Y,<span class=\"sy0\">-</span>Radius,Radius<span\
      \ class=\"br0\">)</span>,\n\t\t\t<span class=\"kw3\">Clamp</span><span class=\"\
      br0\">(</span>Z,<span class=\"sy0\">-</span>Radius,Radius<span class=\"br0\"\
      >)</span>\n\t\t<span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\
      \tvoid AddBounded<span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V, <span class=\"kw5\">FLOAT</span>\
      \ Radius<span class=\"sy0\">=</span>MAXSWORD <span class=\"br0\">)</span>\n\t\
      <span class=\"br0\">{</span>\n\t\t<span class=\"sy0\">*</span>this <span class=\"\
      sy0\">=</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span>this\
      \ <span class=\"sy0\">+</span> V<span class=\"br0\">)</span>.<span class=\"\
      me0\">BoundToCube</span><span class=\"br0\">(</span>Radius<span class=\"br0\"\
      >)</span>;\n\t<span class=\"br0\">}</span>\n\tFLOAT<span class=\"sy0\">&amp;</span>\
      \ Component<span class=\"br0\">(</span> <span class=\"kw5\">INT</span> Index\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>X<span\
      \ class=\"br0\">)</span><span class=\"br0\">[</span>Index<span class=\"br0\"\
      >]</span>;\n\t<span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Return\
      \ a boolean that is based on the vector's direction.</span>\n\t<span class=\"\
      co1\">// When      V==(0,0,0) Booleanize(0)=1.</span>\n\t<span class=\"co1\"\
      >// Otherwise Booleanize(V) &lt;-&gt; !Booleanize(!B).</span>\n\tUBOOL Booleanize<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n\t<span class=\"br0\"\
      >{</span>\n\t\t<span class=\"kw2\">return</span>\n\t\t\tX <span class=\"sy0\"\
      >&gt;</span>  <span class=\"nu0\">0</span>.<span class=\"me0\">f</span> ? <span\
      \ class=\"nu0\">1</span> :\n\t\t\tX <span class=\"sy0\">&lt;</span>  <span class=\"\
      nu0\">0</span>.<span class=\"me0\">f</span> ? <span class=\"nu0\">0</span> :\n\
      \t\t\tY <span class=\"sy0\">&gt;</span>  <span class=\"nu0\">0</span>.<span\
      \ class=\"me0\">f</span> ? <span class=\"nu0\">1</span> :\n\t\t\tY <span class=\"\
      sy0\">&lt;</span>  <span class=\"nu0\">0</span>.<span class=\"me0\">f</span>\
      \ ? <span class=\"nu0\">0</span> :\n\t\t\tZ <span class=\"sy0\">&gt;=</span>\
      \ <span class=\"nu0\">0</span>.<span class=\"me0\">f</span> ? <span class=\"\
      nu0\">1</span> : <span class=\"nu0\">0</span>;\n\t<span class=\"br0\">}</span>\n\
      \ \n\t<span class=\"co1\">// Transformation.</span>\n\tFVector TransformVectorBy<span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FCoords<span class=\"\
      sy0\">&amp;</span> <span class=\"kw5\">Coords</span> <span class=\"br0\">)</span>\
      \ <span class=\"kw1\">const</span>;\n\tFVector TransformPointBy<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FCoords<span class=\"sy0\">&amp;</span>\
      \ <span class=\"kw5\">Coords</span> <span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>;\n\tFVector MirrorByVector<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> MirrorNormal\
      \ <span class=\"br0\">)</span> <span class=\"kw1\">const</span>;\n\tFVector\
      \ MirrorByPlane<span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FPlane<span class=\"sy0\">&amp;</span> MirrorPlane <span class=\"br0\">)</span>\
      \ <span class=\"kw1\">const</span>;\n\tFVector PivotTransform<span class=\"\
      br0\">(</span><span class=\"kw1\">const</span> FCoords<span class=\"sy0\">&amp;</span>\
      \ <span class=\"kw5\">Coords</span><span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>;\n \n\t<span class=\"co1\">// Complicated functions.</span>\n\
      \tFRotator <span class=\"kw7\">Rotation</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n\tvoid FindBestAxisVectors<span class=\"br0\">(</span>\
      \ FVector<span class=\"sy0\">&amp;</span> Axis1, FVector<span class=\"sy0\"\
      >&amp;</span> Axis2 <span class=\"br0\">)</span>;\n\tFVector SafeNormal<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>;\
      \ <span class=\"co1\">//warning: Not inline because of compiler bug.</span>\n\
      \ \n\t<span class=\"co1\">// Friends.</span>\n\tfriend <span class=\"kw5\">FLOAT</span>\
      \ FDist<span class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> V1, <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> V2 <span class=\"br0\">)</span>;\n\tfriend <span\
      \ class=\"kw5\">FLOAT</span> FDistSquared<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V1, <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V2 <span\
      \ class=\"br0\">)</span>;\n\tfriend UBOOL FPointsAreSame<span class=\"br0\"\
      >(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ P, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Q <span class=\"br0\">)</span>;\n\tfriend UBOOL FPointsAreNear<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point2, <span class=\"kw5\">FLOAT</span> Dist<span class=\"br0\">)</span>;\n\
      \tfriend <span class=\"kw5\">FLOAT</span> FPointPlaneDist<span class=\"br0\"\
      >(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ PlaneBase, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ PlaneNormal <span class=\"br0\">)</span>;\n\tfriend FVector FLinePlaneIntersection<span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> Point1, <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> Point2, <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> PlaneOrigin, <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> PlaneNormal <span class=\"br0\">)</span>;\n\tfriend\
      \ FVector FLinePlaneIntersection<span class=\"br0\">(</span> <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Point1, <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Point2, <span class=\"\
      kw1\">const</span> FPlane<span class=\"sy0\">&amp;</span> <span class=\"kw5\"\
      >Plane</span> <span class=\"br0\">)</span>;\n\tfriend UBOOL FParallel<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal2 <span class=\"br0\">)</span>;\n\tfriend UBOOL FCoplanar<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Base1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Base2, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal2 <span class=\"br0\">)</span>;\n \n\t<span class=\"co1\">// Serializer.</span>\n\
      \tfriend FArchive<span class=\"sy0\">&amp;</span> operator<span class=\"sy0\"\
      >&lt;&lt;</span><span class=\"br0\">(</span> FArchive<span class=\"sy0\">&amp;</span>\
      \ Ar, FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> Ar <span\
      \ class=\"sy0\">&lt;&lt;</span> V.<span class=\"me0\">X</span> <span class=\"\
      sy0\">&lt;&lt;</span> V.<span class=\"me0\">Y</span> <span class=\"sy0\">&lt;&lt;</span>\
      \ V.<span class=\"me0\">Z</span>;\n\t<span class=\"br0\">}</span>\n <span class=\"\
      br0\">}</span> GCC_ALIGN<span class=\"br0\">(</span><span class=\"nu0\">16</span><span\
      \ class=\"br0\">)</span>;\n \n \n \n <span class=\"co2\">#else</span>\n \n \n\
      \ \n <span class=\"co2\">#define FVECTOR_ALIGNMENT DEFAULT_ALIGNMENT</span>\n\
      \ <span class=\"kw1\">class</span> CORE_API FVector \n <span class=\"br0\">{</span>\n\
      \ <span class=\"kw1\">public</span>:\n\t<span class=\"co1\">// Variables.</span>\n\
      \t<span class=\"kw5\">FLOAT</span> X,Y,Z;\n \n\t<span class=\"co1\">// Constructors.</span>\n\
      \tFVector<span class=\"br0\">(</span><span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">{</span><span class=\"br0\">}</span>\n \n\tFVector<span class=\"br0\"\
      >(</span> <span class=\"kw5\">FLOAT</span> InX, <span class=\"kw5\">FLOAT</span>\
      \ InY, <span class=\"kw5\">FLOAT</span> InZ <span class=\"br0\">)</span>\n\t\
      :\tX<span class=\"br0\">(</span>InX<span class=\"br0\">)</span>, Y<span class=\"\
      br0\">(</span>InY<span class=\"br0\">)</span>, Z<span class=\"br0\">(</span>InZ<span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span><span class=\"br0\"\
      >}</span>\n \n\t<span class=\"co1\">// Binary math operators.</span>\n\tFVector\
      \ <span class=\"kw1\">operator</span><span class=\"sy0\">^</span><span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ V <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector\n\t\t<span class=\"\
      br0\">(</span>\n\t\t\tY <span class=\"sy0\">*</span> V.<span class=\"me0\">Z</span>\
      \ <span class=\"sy0\">-</span> Z <span class=\"sy0\">*</span> V.<span class=\"\
      me0\">Y</span>,\n\t\t\tZ <span class=\"sy0\">*</span> V.<span class=\"me0\"\
      >X</span> <span class=\"sy0\">-</span> X <span class=\"sy0\">*</span> V.<span\
      \ class=\"me0\">Z</span>,\n\t\t\tX <span class=\"sy0\">*</span> V.<span class=\"\
      me0\">Y</span> <span class=\"sy0\">-</span> Y <span class=\"sy0\">*</span> V.<span\
      \ class=\"me0\">X</span>\n\t\t<span class=\"br0\">)</span>;\n\t<span class=\"\
      br0\">}</span>\n\t<span class=\"kw5\">FLOAT</span> <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">|</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> X<span class=\"sy0\">*</span>V.<span class=\"me0\">X</span>\
      \ <span class=\"sy0\">+</span> Y<span class=\"sy0\">*</span>V.<span class=\"\
      me0\">Y</span> <span class=\"sy0\">+</span> Z<span class=\"sy0\">*</span>V.<span\
      \ class=\"me0\">Z</span>;\n\t<span class=\"br0\">}</span>\n\tfriend FVector\
      \ <span class=\"kw1\">operator</span><span class=\"sy0\">*</span><span class=\"\
      br0\">(</span> <span class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span>,\
      \ <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> FVector<span class=\"br0\">(</span> V.<span class=\"me0\"\
      >X</span> <span class=\"sy0\">*</span> <span class=\"kw5\">Scale</span>, V.<span\
      \ class=\"me0\">Y</span> <span class=\"sy0\">*</span> <span class=\"kw5\">Scale</span>,\
      \ V.<span class=\"me0\">Z</span> <span class=\"sy0\">*</span> <span class=\"\
      kw5\">Scale</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\
      \tFVector <span class=\"kw1\">operator</span><span class=\"sy0\">+</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> X <span class=\"sy0\">+</span> V.<span class=\"me0\"\
      >X</span>, Y <span class=\"sy0\">+</span> V.<span class=\"me0\">Y</span>, Z\
      \ <span class=\"sy0\">+</span> V.<span class=\"me0\">Z</span> <span class=\"\
      br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\tFVector operator<span class=\"\
      sy0\">-</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> FVector<span class=\"br0\">(</span> X <span class=\"sy0\"\
      >-</span> V.<span class=\"me0\">X</span>, Y <span class=\"sy0\">-</span> V.<span\
      \ class=\"me0\">Y</span>, Z <span class=\"sy0\">-</span> V.<span class=\"me0\"\
      >Z</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\t\
      FVector <span class=\"kw1\">operator</span><span class=\"sy0\">*</span><span\
      \ class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span> <span class=\"kw5\"\
      >Scale</span> <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> X <span class=\"sy0\">*</span> <span class=\"kw5\"\
      >Scale</span>, Y <span class=\"sy0\">*</span> <span class=\"kw5\">Scale</span>,\
      \ Z <span class=\"sy0\">*</span> <span class=\"kw5\">Scale</span> <span class=\"\
      br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\tFVector <span class=\"kw1\"\
      >operator</span><span class=\"sy0\">/</span><span class=\"br0\">(</span> <span\
      \ class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span> <span class=\"\
      br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\
      \t\t<span class=\"kw5\">FLOAT</span> RScale <span class=\"sy0\">=</span> <span\
      \ class=\"nu0\">1</span>.<span class=\"me0\">f</span><span class=\"sy0\">/</span><span\
      \ class=\"kw5\">Scale</span>;\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> X <span class=\"sy0\">*</span> RScale, Y <span class=\"\
      sy0\">*</span> RScale, Z <span class=\"sy0\">*</span> RScale <span class=\"\
      br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\tFVector <span class=\"kw1\"\
      >operator</span><span class=\"sy0\">*</span><span class=\"br0\">(</span> <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V <span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span class=\"\
      br0\">(</span> X <span class=\"sy0\">*</span> V.<span class=\"me0\">X</span>,\
      \ Y <span class=\"sy0\">*</span> V.<span class=\"me0\">Y</span>, Z <span class=\"\
      sy0\">*</span> V.<span class=\"me0\">Z</span> <span class=\"br0\">)</span>;\n\
      \t<span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Binary comparison\
      \ operators.</span>\n\tUBOOL <span class=\"kw1\">operator</span><span class=\"\
      sy0\">==</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span> <span\
      \ class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> X<span class=\"sy0\">==</span>V.<span class=\"me0\">X</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> Y<span class=\"sy0\">==</span>V.<span\
      \ class=\"me0\">Y</span> <span class=\"sy0\">&amp;&amp;</span> Z<span class=\"\
      sy0\">==</span>V.<span class=\"me0\">Z</span>;\n\t<span class=\"br0\">}</span>\n\
      \tUBOOL <span class=\"kw1\">operator</span><span class=\"sy0\">!=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span\
      \ class=\"sy0\">!=</span>V.<span class=\"me0\">X</span> <span class=\"sy0\"\
      >||</span> Y<span class=\"sy0\">!=</span>V.<span class=\"me0\">Y</span> <span\
      \ class=\"sy0\">||</span> Z<span class=\"sy0\">!=</span>V.<span class=\"me0\"\
      >Z</span>;\n\t<span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Unary\
      \ operators.</span>\n\tFVector operator<span class=\"sy0\">-</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> <span class=\"sy0\">-</span>X, <span class=\"sy0\"\
      >-</span>Y, <span class=\"sy0\">-</span>Z <span class=\"br0\">)</span>;\n\t\
      <span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Assignment operators.</span>\n\
      \tFVector <span class=\"kw1\">operator</span><span class=\"sy0\">+=</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\
      \t\tX <span class=\"sy0\">+=</span> V.<span class=\"me0\">X</span>; Y <span\
      \ class=\"sy0\">+=</span> V.<span class=\"me0\">Y</span>; Z <span class=\"sy0\"\
      >+=</span> V.<span class=\"me0\">Z</span>;\n\t\t<span class=\"kw2\">return</span>\
      \ <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\">}</span>\n\tFVector\
      \ operator<span class=\"sy0\">-=</span><span class=\"br0\">(</span> <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V <span class=\"\
      br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\tX <span class=\"sy0\">-=</span>\
      \ V.<span class=\"me0\">X</span>; Y <span class=\"sy0\">-=</span> V.<span class=\"\
      me0\">Y</span>; Z <span class=\"sy0\">-=</span> V.<span class=\"me0\">Z</span>;\n\
      \t\t<span class=\"kw2\">return</span> <span class=\"sy0\">*</span>this;\n\t\
      <span class=\"br0\">}</span>\n\tFVector <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">*=</span><span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span>\
      \ <span class=\"kw5\">Scale</span> <span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">{</span>\n\t\tX <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\
      \ Y <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>; Z <span\
      \ class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\n\t\t<span class=\"\
      kw2\">return</span> <span class=\"sy0\">*</span>this;\n\t<span class=\"br0\"\
      >}</span>\n\tFVector <span class=\"kw1\">operator</span><span class=\"sy0\"\
      >/=</span><span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span> V <span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw5\">FLOAT</span> RV <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span\
      \ class=\"me0\">f</span><span class=\"sy0\">/</span>V;\n\t\tX <span class=\"\
      sy0\">*=</span> RV; Y <span class=\"sy0\">*=</span> RV; Z <span class=\"sy0\"\
      >*=</span> RV;\n\t\t<span class=\"kw2\">return</span> <span class=\"sy0\">*</span>this;\n\
      \t<span class=\"br0\">}</span>\n\tFVector <span class=\"kw1\">operator</span><span\
      \ class=\"sy0\">*=</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t\
      <span class=\"br0\">{</span>\n\t\tX <span class=\"sy0\">*=</span> V.<span class=\"\
      me0\">X</span>; Y <span class=\"sy0\">*=</span> V.<span class=\"me0\">Y</span>;\
      \ Z <span class=\"sy0\">*=</span> V.<span class=\"me0\">Z</span>;\n\t\t<span\
      \ class=\"kw2\">return</span> <span class=\"sy0\">*</span>this;\n\t<span class=\"\
      br0\">}</span>\n\tFVector <span class=\"kw1\">operator</span><span class=\"\
      sy0\">/=</span><span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\t\
      <span class=\"br0\">{</span>\n\t\tX <span class=\"sy0\">/=</span> V.<span class=\"\
      me0\">X</span>; Y <span class=\"sy0\">/=</span> V.<span class=\"me0\">Y</span>;\
      \ Z <span class=\"sy0\">/=</span> V.<span class=\"me0\">Z</span>;\n\t\t<span\
      \ class=\"kw2\">return</span> <span class=\"sy0\">*</span>this;\n\t<span class=\"\
      br0\">}</span>\n \n\t<span class=\"co1\">// Simple functions.</span>\n\t<span\
      \ class=\"kw5\">FLOAT</span> Size<span class=\"br0\">(</span><span class=\"\
      br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\
      \t\t<span class=\"kw2\">return</span> appSqrt<span class=\"br0\">(</span> X<span\
      \ class=\"sy0\">*</span>X <span class=\"sy0\">+</span> Y<span class=\"sy0\"\
      >*</span>Y <span class=\"sy0\">+</span> Z<span class=\"sy0\">*</span>Z <span\
      \ class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\t<span class=\"\
      kw5\">FLOAT</span> SizeSquared<span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"kw1\">const</span>\n\t<span class=\"br0\">{</span>\n\
      \t\t<span class=\"kw2\">return</span> X<span class=\"sy0\">*</span>X <span class=\"\
      sy0\">+</span> Y<span class=\"sy0\">*</span>Y <span class=\"sy0\">+</span> Z<span\
      \ class=\"sy0\">*</span>Z;\n\t<span class=\"br0\">}</span>\n\t<span class=\"\
      kw5\">FLOAT</span> Size2D<span class=\"br0\">(</span><span class=\"br0\">)</span>\
      \ <span class=\"kw1\">const</span> \n\t<span class=\"br0\">{</span>\n\t\t<span\
      \ class=\"kw2\">return</span> appSqrt<span class=\"br0\">(</span> X<span class=\"\
      sy0\">*</span>X <span class=\"sy0\">+</span> Y<span class=\"sy0\">*</span>Y\
      \ <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\t<span class=\"\
      kw5\">FLOAT</span> SizeSquared2D<span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"kw1\">const</span> \n\t<span class=\"br0\">{</span>\n\
      \t\t<span class=\"kw2\">return</span> X<span class=\"sy0\">*</span>X <span class=\"\
      sy0\">+</span> Y<span class=\"sy0\">*</span>Y;\n\t<span class=\"br0\">}</span>\n\
      \t<span class=\"kw5\">int</span> IsNearlyZero<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span>\n\t\t\t\t<span class=\"\
      kw3\">Abs</span><span class=\"br0\">(</span>X<span class=\"br0\">)</span><span\
      \ class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER\n\t\t\t<span class=\"sy0\">&amp;&amp;</span>\t\
      <span class=\"kw3\">Abs</span><span class=\"br0\">(</span>Y<span class=\"br0\"\
      >)</span><span class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER\n\t\t\t<span class=\"\
      sy0\">&amp;&amp;</span>\t<span class=\"kw3\">Abs</span><span class=\"br0\">(</span>Z<span\
      \ class=\"br0\">)</span><span class=\"sy0\">&lt;</span>KINDA_SMALL_NUMBER;\n\
      \t<span class=\"br0\">}</span>\n\tUBOOL IsZero<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">return</span> X<span class=\"sy0\">==</span><span\
      \ class=\"nu0\">0</span>.<span class=\"me0\">f</span> <span class=\"sy0\">&amp;&amp;</span>\
      \ Y<span class=\"sy0\">==</span><span class=\"nu0\">0</span>.<span class=\"\
      me0\">f</span> <span class=\"sy0\">&amp;&amp;</span> Z<span class=\"sy0\">==</span><span\
      \ class=\"nu0\">0</span>.<span class=\"me0\">f</span>;\n\t<span class=\"br0\"\
      >}</span>\n\tUBOOL <span class=\"kw3\">Normalize</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw5\">FLOAT</span> SquareSum <span class=\"sy0\">=</span> X<span class=\"sy0\"\
      >*</span>X<span class=\"sy0\">+</span>Y<span class=\"sy0\">*</span>Y<span class=\"\
      sy0\">+</span>Z<span class=\"sy0\">*</span>Z;\n\t\t<span class=\"kw2\">if</span><span\
      \ class=\"br0\">(</span> SquareSum <span class=\"sy0\">&gt;=</span> SMALL_NUMBER\
      \ <span class=\"br0\">)</span>\n\t\t<span class=\"br0\">{</span>\n\t\t\t<span\
      \ class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span> <span class=\"\
      sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\">f</span><span\
      \ class=\"sy0\">/</span>appSqrt<span class=\"br0\">(</span>SquareSum<span class=\"\
      br0\">)</span>;\n\t\t\tX <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\
      \ Y <span class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>; Z <span\
      \ class=\"sy0\">*=</span> <span class=\"kw5\">Scale</span>;\n\t\t\t<span class=\"\
      kw2\">return</span> <span class=\"nu0\">1</span>;\n\t\t<span class=\"br0\">}</span>\n\
      \t\t<span class=\"kw2\">else</span> <span class=\"kw2\">return</span> <span\
      \ class=\"nu0\">0</span>;\n\t<span class=\"br0\">}</span>\n\tFVector Projection<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> RZ <span\
      \ class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\">f</span><span\
      \ class=\"sy0\">/</span>Z;\n\t\t<span class=\"kw2\">return</span> FVector<span\
      \ class=\"br0\">(</span> X<span class=\"sy0\">*</span>RZ, Y<span class=\"sy0\"\
      >*</span>RZ, <span class=\"nu0\">1</span> <span class=\"br0\">)</span>;\n\t\
      <span class=\"br0\">}</span>\n\tFVector UnsafeNormal<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"kw1\">const</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw5\">FLOAT</span> <span class=\"kw5\">Scale</span>\
      \ <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me0\"\
      >f</span><span class=\"sy0\">/</span>appSqrt<span class=\"br0\">(</span>X<span\
      \ class=\"sy0\">*</span>X<span class=\"sy0\">+</span>Y<span class=\"sy0\">*</span>Y<span\
      \ class=\"sy0\">+</span>Z<span class=\"sy0\">*</span>Z<span class=\"br0\">)</span>;\n\
      \t\t<span class=\"kw2\">return</span> FVector<span class=\"br0\">(</span> X<span\
      \ class=\"sy0\">*</span><span class=\"kw5\">Scale</span>, Y<span class=\"sy0\"\
      >*</span><span class=\"kw5\">Scale</span>, Z<span class=\"sy0\">*</span><span\
      \ class=\"kw5\">Scale</span> <span class=\"br0\">)</span>;\n\t<span class=\"\
      br0\">}</span>\n\tFVector GridSnap<span class=\"br0\">(</span> <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Grid <span class=\"\
      br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span>\
      \ FVector<span class=\"br0\">(</span> FSnap<span class=\"br0\">(</span>X, Grid.<span\
      \ class=\"me0\">X</span><span class=\"br0\">)</span>,FSnap<span class=\"br0\"\
      >(</span>Y, Grid.<span class=\"me0\">Y</span><span class=\"br0\">)</span>,FSnap<span\
      \ class=\"br0\">(</span>Z, Grid.<span class=\"me0\">Z</span><span class=\"br0\"\
      >)</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\t\
      FVector BoundToCube<span class=\"br0\">(</span> <span class=\"kw5\">FLOAT</span>\
      \ Radius <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t\
      <span class=\"kw2\">return</span> FVector\n\t\t<span class=\"br0\">(</span>\n\
      \t\t\t<span class=\"kw3\">Clamp</span><span class=\"br0\">(</span>X,<span class=\"\
      sy0\">-</span>Radius,Radius<span class=\"br0\">)</span>,\n\t\t\t<span class=\"\
      kw3\">Clamp</span><span class=\"br0\">(</span>Y,<span class=\"sy0\">-</span>Radius,Radius<span\
      \ class=\"br0\">)</span>,\n\t\t\t<span class=\"kw3\">Clamp</span><span class=\"\
      br0\">(</span>Z,<span class=\"sy0\">-</span>Radius,Radius<span class=\"br0\"\
      >)</span>\n\t\t<span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n\
      \tvoid AddBounded<span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FVector<span class=\"sy0\">&amp;</span> V, <span class=\"kw5\">FLOAT</span>\
      \ Radius<span class=\"sy0\">=</span>MAXSWORD <span class=\"br0\">)</span>\n\t\
      <span class=\"br0\">{</span>\n\t\t<span class=\"sy0\">*</span>this <span class=\"\
      sy0\">=</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span>this\
      \ <span class=\"sy0\">+</span> V<span class=\"br0\">)</span>.<span class=\"\
      me0\">BoundToCube</span><span class=\"br0\">(</span>Radius<span class=\"br0\"\
      >)</span>;\n\t<span class=\"br0\">}</span>\n\tFLOAT<span class=\"sy0\">&amp;</span>\
      \ Component<span class=\"br0\">(</span> <span class=\"kw5\">INT</span> Index\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw2\">return</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>X<span\
      \ class=\"br0\">)</span><span class=\"br0\">[</span>Index<span class=\"br0\"\
      >]</span>;\n\t<span class=\"br0\">}</span>\n \n\t<span class=\"co1\">// Return\
      \ a boolean that is based on the vector's direction.</span>\n\t<span class=\"\
      co1\">// When      V==(0,0,0) Booleanize(0)=1.</span>\n\t<span class=\"co1\"\
      >// Otherwise Booleanize(V) &lt;-&gt; !Booleanize(!B).</span>\n\tUBOOL Booleanize<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n\t<span class=\"br0\"\
      >{</span>\n\t\t<span class=\"kw2\">return</span>\n\t\t\tX <span class=\"sy0\"\
      >&gt;</span>  <span class=\"nu0\">0</span>.<span class=\"me0\">f</span> ? <span\
      \ class=\"nu0\">1</span> :\n\t\t\tX <span class=\"sy0\">&lt;</span>  <span class=\"\
      nu0\">0</span>.<span class=\"me0\">f</span> ? <span class=\"nu0\">0</span> :\n\
      \t\t\tY <span class=\"sy0\">&gt;</span>  <span class=\"nu0\">0</span>.<span\
      \ class=\"me0\">f</span> ? <span class=\"nu0\">1</span> :\n\t\t\tY <span class=\"\
      sy0\">&lt;</span>  <span class=\"nu0\">0</span>.<span class=\"me0\">f</span>\
      \ ? <span class=\"nu0\">0</span> :\n\t\t\tZ <span class=\"sy0\">&gt;=</span>\
      \ <span class=\"nu0\">0</span>.<span class=\"me0\">f</span> ? <span class=\"\
      nu0\">1</span> : <span class=\"nu0\">0</span>;\n\t<span class=\"br0\">}</span>\n\
      \ \n\t<span class=\"co1\">// Transformation.</span>\n\tFVector TransformVectorBy<span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FCoords<span class=\"\
      sy0\">&amp;</span> <span class=\"kw5\">Coords</span> <span class=\"br0\">)</span>\
      \ <span class=\"kw1\">const</span>;\n\tFVector TransformPointBy<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FCoords<span class=\"sy0\">&amp;</span>\
      \ <span class=\"kw5\">Coords</span> <span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>;\n\tFVector MirrorByVector<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> MirrorNormal\
      \ <span class=\"br0\">)</span> <span class=\"kw1\">const</span>;\n\tFVector\
      \ MirrorByPlane<span class=\"br0\">(</span> <span class=\"kw1\">const</span>\
      \ FPlane<span class=\"sy0\">&amp;</span> MirrorPlane <span class=\"br0\">)</span>\
      \ <span class=\"kw1\">const</span>;\n\tFVector PivotTransform<span class=\"\
      br0\">(</span><span class=\"kw1\">const</span> FCoords<span class=\"sy0\">&amp;</span>\
      \ <span class=\"kw5\">Coords</span><span class=\"br0\">)</span> <span class=\"\
      kw1\">const</span>;\n \n\t<span class=\"co1\">// Complicated functions.</span>\n\
      \tFRotator <span class=\"kw7\">Rotation</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n\tvoid FindBestAxisVectors<span class=\"br0\">(</span>\
      \ FVector<span class=\"sy0\">&amp;</span> Axis1, FVector<span class=\"sy0\"\
      >&amp;</span> Axis2 <span class=\"br0\">)</span>;\n\tFVector SafeNormal<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">const</span>;\
      \ <span class=\"co1\">//warning: Not inline because of compiler bug.</span>\n\
      \ \n\t<span class=\"co1\">// Friends.</span>\n\tfriend <span class=\"kw5\">FLOAT</span>\
      \ FDist<span class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> V1, <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> V2 <span class=\"br0\">)</span>;\n\tfriend <span\
      \ class=\"kw5\">FLOAT</span> FDistSquared<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V1, <span\
      \ class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> V2 <span\
      \ class=\"br0\">)</span>;\n\tfriend UBOOL FPointsAreSame<span class=\"br0\"\
      >(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ P, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Q <span class=\"br0\">)</span>;\n\tfriend UBOOL FPointsAreNear<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point2, <span class=\"kw5\">FLOAT</span> Dist<span class=\"br0\">)</span>;\n\
      \tfriend <span class=\"kw5\">FLOAT</span> FPointPlaneDist<span class=\"br0\"\
      >(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Point, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ PlaneBase, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ PlaneNormal <span class=\"br0\">)</span>;\n\tfriend FVector FLinePlaneIntersection<span\
      \ class=\"br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> Point1, <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> Point2, <span class=\"kw1\">const</span> FVector<span class=\"\
      sy0\">&amp;</span> PlaneOrigin, <span class=\"kw1\">const</span> FVector<span\
      \ class=\"sy0\">&amp;</span> PlaneNormal <span class=\"br0\">)</span>;\n\tfriend\
      \ FVector FLinePlaneIntersection<span class=\"br0\">(</span> <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Point1, <span class=\"\
      kw1\">const</span> FVector<span class=\"sy0\">&amp;</span> Point2, <span class=\"\
      kw1\">const</span> FPlane<span class=\"sy0\">&amp;</span> <span class=\"kw5\"\
      >Plane</span> <span class=\"br0\">)</span>;\n\tfriend UBOOL FParallel<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal2 <span class=\"br0\">)</span>;\n\tfriend UBOOL FCoplanar<span class=\"\
      br0\">(</span> <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Base1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal1, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Base2, <span class=\"kw1\">const</span> FVector<span class=\"sy0\">&amp;</span>\
      \ Normal2 <span class=\"br0\">)</span>;\n \n\t<span class=\"co1\">// Serializer.</span>\n\
      \tfriend FArchive<span class=\"sy0\">&amp;</span> operator<span class=\"sy0\"\
      >&lt;&lt;</span><span class=\"br0\">(</span> FArchive<span class=\"sy0\">&amp;</span>\
      \ Ar, FVector<span class=\"sy0\">&amp;</span> V <span class=\"br0\">)</span>\n\
      \t<span class=\"br0\">{</span>\n\t\t<span class=\"kw2\">return</span> Ar <span\
      \ class=\"sy0\">&lt;&lt;</span> V.<span class=\"me0\">X</span> <span class=\"\
      sy0\">&lt;&lt;</span> V.<span class=\"me0\">Y</span> <span class=\"sy0\">&lt;&lt;</span>\
      \ V.<span class=\"me0\">Z</span>;\n\t<span class=\"br0\">}</span>\n <span class=\"\
      br0\">}</span>;\n <span class=\"co2\">#endif</span></pre></div>\n</div>\n<hr\
      \ />\n<p><b>DJPaul:</b> Interesting page, rubbish on itself. What about we make\
      \ a new page that we can put this - and other notes about the Unreal Engine's\
      \ Native Classes we've gotten out of Epic? Perhaps hack0rz <a href=\"/Legacy:Native_Coding\"\
      \ title=\"Legacy:Native Coding\">Native Coding</a> around a bit.</p>\n<p>That\
      \ way we can link to this, the few UT2003 native classes we've gotten out of\
      \ epic via ut2003mods, the Deus Ex native sources, etc.</p>\n<p><b>Tarquin:</b>\
      \ What is this page?</p>\n\n<!-- \nNewPP limit report\nCPU time usage: 0.174\
      \ seconds\nReal time usage: 0.663 seconds\nPreprocessor visited node count:\
      \ 6/1000000\nPreprocessor generated node count: 30/1000000\nPost‐expand include\
      \ size: 0/2097152 bytes\nTemplate argument size: 0/2097152 bytes\nHighest expansion\
      \ depth: 2/40\nExpensive parser function count: 0/100\n-->\n\n<!-- \nTransclusion\
      \ expansion time report (%,ms,calls,template)\n100.00%    0.000      1 - -total\n\
      -->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:2317-0!*!0!*!*!*!*\
      \ and timestamp 20221118021941 and revision id 5587\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:Native Coding"
  - ns: 100
    exists: false
    name: "Legacy:L33t"
  templates: []
  images: []
  externallinks:
  - "http://unreal.epicgames.com/files/ut432pubsrc.zip"
  sections:
  - toclevel: 1
    level: "2"
    line: "Introduction"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Official_UnMath_Page"
    byteoffset: 0
    anchor: "Introduction"
  displaytitle: "Legacy:Official UnMath Page"
  iwlinks: []
  wikitext:
    text: "==Introduction ==\n\nThe UnMath.h Header File (from, [http://unreal.epicgames.com/files/ut432pubsrc.zip\
      \ Unreal Tournament 432 C++ Publicly Released Headers]) might more properly\
      \ belong in the Unreal Engine Core section, since it is integral to every critical\
      \ process that the Engine performs.<br /> \n\nThe Official UnMath Page is derived\
      \ from that Header File Released from Epic Games and coded in C++. The following\
      \ is just a section from the file, that describes FVectors. It appears in the\
      \ original Tim Sweeney code; an uncompiled text file. <br> \n\nThe complete\
      \ UnMath.h file contains all the mathematical routines used by the Unreal Engine\
      \ for collision detection, the Artificial Intelligence of Bots, and the physics\
      \ (yes, even the Quaternion Rotations), and, ultimately, the rendering of the\
      \ scene. It's WAY [[Legacy:L33t|l33t]],...but, unfortunately, WAY humungeous.<br>\
      \ \n\nWe should have an analysis page to acompany it.<br> \n\nIt will take you\
      \ at least 5 years to read it all,...and by that time the Engine hierarchy will\
      \ have evolved into something incomprehensible and extremely highly advanced.\
      \ \n\n''Preface:'' The acronym API stands for Application Programming Interface.\
      \ Just to give you an idea of the insane complexity of the UnMath routines,\
      \ I have included a snippet of code for an important function <u><b>FuzzVectors</b></u>:\n\
      \n<uscript>\n/*-----------------------------------------------------------------------------\n\
      \tFVector.\n -----------------------------------------------------------------------------*/\n\
      \ // Information associated with a floating point vector, describing its\n //\
      \ status as a point in a rendering context.\n enum EVectorFlags\n {\n\tFVF_OutXMin\t\
      \t= 0x04,\t// Outcode rejection, off left hand side of screen.\n\tFVF_OutXMax\t\
      \t= 0x08,\t// Outcode rejection, off right hand side of screen.\n\tFVF_OutYMin\t\
      \t= 0x10,\t// Outcode rejection, off top of screen.\n\tFVF_OutYMax\t\t= 0x20,\t\
      // Outcode rejection, off bottom of screen.\n\tFVF_OutNear     = 0x40, // Near\
      \ clipping plane.\n\tFVF_OutFar      = 0x80, // Far clipping plane.\n\tFVF_OutReject\
      \   = (FVF_OutXMin | FVF_OutXMax | FVF_OutYMin | FVF_OutYMax), //  Outcode rejectable.\n\
      \tFVF_OutSkip\t\t= (FVF_OutXMin | FVF_OutXMax | FVF_OutYMin | FVF_OutYMax),\
      \ // Outcode clippable.\n };\n\n //\n // Floating point vector.\n // Playstation2\
      \ vectors are 16 bytes.\n //\n #if __PSX2_EE__\n #define FVECTOR_ALIGNMENT 16\n\
      \ class CORE_API FVector \n {\n public:\n\t// Variables.\n\tFLOAT X, Y, Z, W;\n\
      \n\t// Constructors.\n\tFVector()\n\t{}\n\n\tFVector( FLOAT InX, FLOAT InY,\
      \ FLOAT InZ )\n\t:\tX(InX), Y(InY), Z(InZ), W(1.f)\n\t{}\n\n\t// Binary math\
      \ operators.\n\tinline FVector operator^( const FVector& V ) const\n\t{\n\t\t\
      FVector r;\n\t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\t\
      vf3, 0x00(%2)\n\t\t\tvopmula.xyz\tACCxyz, vf2xyz, vf3xyz\n\t\t\tvopmsub.xyz\t\
      vf1xyz, vf3xyz, vf2xyz\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"\
      r\" (&r), \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\treturn r;\n\
      \t}\n\tinline FLOAT operator|( const FVector& V ) const\n\t{\n\t\tFVector r;\n\
      \t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\
      \t\t\tvmul.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\
      \t: \"r\" (&r), \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\treturn\
      \ r.X + r.Y + r.Z;\n\t}\n\tfriend FVector operator*( FLOAT Scale, const FVector&\
      \ V )\n\t{\n\t\treturn FVector( V.X * Scale, V.Y * Scale, V.Z * Scale );\n\t\
      }\n\tinline FVector operator+( const FVector& V ) const\n\t{\n\t\tFVector r;\n\
      \t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\
      \t\t\tvadd.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\
      \t: \"r\" (&r), \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\treturn\
      \ r;\n\t}\n\tinline FVector operator-( const FVector& V ) const\n\t{\n\t\tFVector\
      \ r;\n\t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3,\
      \ 0x00(%2)\n\t\t\tvsub.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\
      \"\n\t\t:\n\t\t: \"r\" (&r), \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t\
      );\n\t\treturn r;\n\t}\n\tinline FVector operator*( FLOAT Scale ) const\n\t\
      {\n\t\tFVector r;\n\t\tasm volatile (\"\n\t\t\tctc2\t\t%2,  $21\n\t\t\tlqc2\t\
      \tvf2, 0x00(%1)\n\t\t\tvmuli.xyz\tvf1, vf2, I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\
      \t\t\"\n\t\t:\n\t\t: \"r\" (&r), \"r\" (this), \"r\" (Scale)\n\t\t: \"memory\"\
      \n\t\t);\n\t\treturn r;\n\t}\n\tinline FVector operator/( FLOAT Scale ) const\n\
      \t{\n\t\tFLOAT RScale = 1.f/Scale;\n\t\tFVector r;\n\t\tasm volatile (\"\n\t\
      \t\tctc2\t\t%2,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tvmuli.xyz\tvf1, vf2,\
      \ I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"r\" (&r), \"r\" (this),\
      \ \"r\" (RScale)\n\t\t: \"memory\"\n\t\t);\n\t\treturn r;\n\t}\n\tinline FVector\
      \ operator*( const FVector& V ) const\n\t{\n\t\tFVector r;\n\t\tasm volatile\
      \ (\"\n\t\t\tlqc2\t\tvf2, 0x00(%1)\n\t\t\tlqc2\t\tvf3, 0x00(%2)\n\t\t\tvmul.xyz\t\
      vf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"r\" (&r),\
      \ \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\treturn r;\n\t}\n\n\
      \t// Binary comparison operators.\n\tUBOOL operator==( const FVector& V ) const\n\
      \t{\n\t\treturn X==V.X && Y==V.Y && Z==V.Z;\n\t}\n\tUBOOL operator!=( const\
      \ FVector& V ) const\n\t{\n\t\treturn X!=V.X || Y!=V.Y || Z!=V.Z;\n\t}\n\n\t\
      // Unary operators.\n\tFVector operator-() const\n\t{\n\t\treturn FVector( -X,\
      \ -Y, -Z );\n\t}\n\n\t// Assignment operators.\n\tinline FVector operator+=(\
      \ const FVector& V )\n\t{\n\t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\
      \t\t\tlqc2\t\tvf3, 0x00(%1)\n\t\t\tvadd.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1,\
      \ 0x00(%0)\n\t\t\"\n\t\t: \n\t\t: \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\
      \n\t\t);\n\t\treturn *this;\n\t}\n\tinline FVector operator-=( const FVector&\
      \ V )\n\t{\n\t\tasm volatile (\"\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\tlqc2\t\t\
      vf3, 0x00(%1)\n\t\t\tvsub.xyz\tvf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\
      \t\"\n\t\t: \n\t\t: \"r\" (this), \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\t\
      return *this;\n\t}\n\tinline FVector operator*=( FLOAT Scale )\n\t{\n\t\tasm\
      \ volatile (\"\n\t\t\tctc2\t\t%1,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\t\
      vmuli.xyz\tvf1, vf2, I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"\
      r\" (this), \"r\" (Scale)\n\t\t: \"memory\"\n\t\t);\n\t\treturn *this;\n\t}\n\
      \tinline FVector operator/=( FLOAT V )\n\t{\n\t\tFLOAT RScale = 1.f/V;\n\t\t\
      asm volatile (\"\n\t\t\tctc2\t\t%1,  $21\n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\t\
      vmuli.xyz\tvf1, vf2, I\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"\
      r\" (this), \"r\" (RScale)\n\t\t: \"memory\"\n\t\t);\n\t\treturn *this;\n\t\
      }\n\tinline FVector operator*=( const FVector& V )\n\t{\n\t\tasm volatile (\"\
      \n\t\t\tlqc2\t\tvf2, 0x00(%0)\n\t\t\tlqc2\t\tvf3, 0x00(%1)\n\t\t\tvmul.xyz\t\
      vf1, vf2, vf3\n\t\t\tsqc2\t\tvf1, 0x00(%0)\n\t\t\"\n\t\t:\n\t\t: \"r\" (this),\
      \ \"r\" (&V)\n\t\t: \"memory\"\n\t\t);\n\t\treturn *this;\n\t}\n\tFVector operator/=(\
      \ const FVector& V )\n\t{\n\t\tX /= V.X; Y /= V.Y; Z /= V.Z;\n\t\treturn *this;\n\
      \t}\n\n\t// Simple functions.\n\tFLOAT Size() const\n\t{\n\t\treturn appSqrt(\
      \ X*X + Y*Y + Z*Z );\n\t}\n\tFLOAT SizeSquared() const\n\t{\n\t\treturn X*X\
      \ + Y*Y + Z*Z;\n\t}\n\tFLOAT Size2D() const \n\t{\n\t\treturn appSqrt( X*X +\
      \ Y*Y );\n\t}\n\tFLOAT SizeSquared2D() const \n\t{\n\t\treturn X*X + Y*Y;\n\t\
      }\n\tint IsNearlyZero() const\n\t{\n\t\treturn\n\t\t\t\tAbs(X)<KINDA_SMALL_NUMBER\n\
      \t\t\t&&\tAbs(Y)<KINDA_SMALL_NUMBER\n\t\t\t&&\tAbs(Z)<KINDA_SMALL_NUMBER;\n\t\
      }\n\tUBOOL IsZero() const\n\t{\n\t\treturn X==0.f && Y==0.f && Z==0.f;\n\t}\n\
      \tUBOOL Normalize()\n\t{\n\t\tFLOAT SquareSum = X*X+Y*Y+Z*Z;\n\t\tif( SquareSum\
      \ >= SMALL_NUMBER )\n\t\t{\n\t\t\tFLOAT Scale = 1.f/appSqrt(SquareSum);\n\t\t\
      \tX *= Scale; Y *= Scale; Z *= Scale;\n\t\t\treturn 1;\n\t\t}\n\t\telse return\
      \ 0;\n\t}\n\tFVector Projection() const\n\t{\n\t\tFLOAT RZ = 1.f/Z;\n\t\treturn\
      \ FVector( X*RZ, Y*RZ, 1 );\n\t}\n\tFVector UnsafeNormal() const\n\t{\n\t\t\
      FLOAT Scale = 1.f/appSqrt(X*X+Y*Y+Z*Z);\n\t\treturn FVector( X*Scale, Y*Scale,\
      \ Z*Scale );\n\t}\n\tFVector GridSnap( const FVector& Grid )\n\t{\n\t\treturn\
      \ FVector( FSnap(X, Grid.X),FSnap(Y, Grid.Y),FSnap(Z, Grid.Z) );\n\t}\n\tFVector\
      \ BoundToCube( FLOAT Radius )\n\t{\n\t\treturn FVector\n\t\t(\n\t\t\tClamp(X,-Radius,Radius),\n\
      \t\t\tClamp(Y,-Radius,Radius),\n\t\t\tClamp(Z,-Radius,Radius)\n\t\t);\n\t}\n\
      \tvoid AddBounded( const FVector& V, FLOAT Radius=MAXSWORD )\n\t{\n\t\t*this\
      \ = (*this + V).BoundToCube(Radius);\n\t}\n\tFLOAT& Component( INT Index )\n\
      \t{\n\t\treturn (&X)[Index];\n\t}\n\n\t// Return a boolean that is based on\
      \ the vector's direction.\n\t// When      V==(0,0,0) Booleanize(0)=1.\n\t//\
      \ Otherwise Booleanize(V) <-> !Booleanize(!B).\n\tUBOOL Booleanize()\n\t{\n\t\
      \treturn\n\t\t\tX >  0.f ? 1 :\n\t\t\tX <  0.f ? 0 :\n\t\t\tY >  0.f ? 1 :\n\
      \t\t\tY <  0.f ? 0 :\n\t\t\tZ >= 0.f ? 1 : 0;\n\t}\n\n\t// Transformation.\n\
      \tFVector TransformVectorBy( const FCoords& Coords ) const;\n\tFVector TransformPointBy(\
      \ const FCoords& Coords ) const;\n\tFVector MirrorByVector( const FVector& MirrorNormal\
      \ ) const;\n\tFVector MirrorByPlane( const FPlane& MirrorPlane ) const;\n\t\
      FVector PivotTransform(const FCoords& Coords) const;\n\n\t// Complicated functions.\n\
      \tFRotator Rotation();\n\tvoid FindBestAxisVectors( FVector& Axis1, FVector&\
      \ Axis2 );\n\tFVector SafeNormal() const; //warning: Not inline because of compiler\
      \ bug.\n\n\t// Friends.\n\tfriend FLOAT FDist( const FVector& V1, const FVector&\
      \ V2 );\n\tfriend FLOAT FDistSquared( const FVector& V1, const FVector& V2 );\n\
      \tfriend UBOOL FPointsAreSame( const FVector& P, const FVector& Q );\n\tfriend\
      \ UBOOL FPointsAreNear( const FVector& Point1, const FVector& Point2, FLOAT\
      \ Dist);\n\tfriend FLOAT FPointPlaneDist( const FVector& Point, const FVector&\
      \ PlaneBase, const FVector& PlaneNormal );\n\tfriend FVector FLinePlaneIntersection(\
      \ const FVector& Point1, const FVector& Point2, const FVector& PlaneOrigin,\
      \ const FVector& PlaneNormal );\n\tfriend FVector FLinePlaneIntersection( const\
      \ FVector& Point1, const FVector& Point2, const FPlane& Plane );\n\tfriend UBOOL\
      \ FParallel( const FVector& Normal1, const FVector& Normal2 );\n\tfriend UBOOL\
      \ FCoplanar( const FVector& Base1, const FVector& Normal1, const FVector& Base2,\
      \ const FVector& Normal2 );\n\n\t// Serializer.\n\tfriend FArchive& operator<<(\
      \ FArchive& Ar, FVector& V )\n\t{\n\t\treturn Ar << V.X << V.Y << V.Z;\n\t}\n\
      \ } GCC_ALIGN(16);\n\n\n\n #else\n\n\n\n #define FVECTOR_ALIGNMENT DEFAULT_ALIGNMENT\n\
      \ class CORE_API FVector \n {\n public:\n\t// Variables.\n\tFLOAT X,Y,Z;\n\n\
      \t// Constructors.\n\tFVector()\n\t{}\n\n\tFVector( FLOAT InX, FLOAT InY, FLOAT\
      \ InZ )\n\t:\tX(InX), Y(InY), Z(InZ)\n\t{}\n\n\t// Binary math operators.\n\t\
      FVector operator^( const FVector& V ) const\n\t{\n\t\treturn FVector\n\t\t(\n\
      \t\t\tY * V.Z - Z * V.Y,\n\t\t\tZ * V.X - X * V.Z,\n\t\t\tX * V.Y - Y * V.X\n\
      \t\t);\n\t}\n\tFLOAT operator|( const FVector& V ) const\n\t{\n\t\treturn X*V.X\
      \ + Y*V.Y + Z*V.Z;\n\t}\n\tfriend FVector operator*( FLOAT Scale, const FVector&\
      \ V )\n\t{\n\t\treturn FVector( V.X * Scale, V.Y * Scale, V.Z * Scale );\n\t\
      }\n\tFVector operator+( const FVector& V ) const\n\t{\n\t\treturn FVector( X\
      \ + V.X, Y + V.Y, Z + V.Z );\n\t}\n\tFVector operator-( const FVector& V ) const\n\
      \t{\n\t\treturn FVector( X - V.X, Y - V.Y, Z - V.Z );\n\t}\n\tFVector operator*(\
      \ FLOAT Scale ) const\n\t{\n\t\treturn FVector( X * Scale, Y * Scale, Z * Scale\
      \ );\n\t}\n\tFVector operator/( FLOAT Scale ) const\n\t{\n\t\tFLOAT RScale =\
      \ 1.f/Scale;\n\t\treturn FVector( X * RScale, Y * RScale, Z * RScale );\n\t\
      }\n\tFVector operator*( const FVector& V ) const\n\t{\n\t\treturn FVector( X\
      \ * V.X, Y * V.Y, Z * V.Z );\n\t}\n\n\t// Binary comparison operators.\n\tUBOOL\
      \ operator==( const FVector& V ) const\n\t{\n\t\treturn X==V.X && Y==V.Y &&\
      \ Z==V.Z;\n\t}\n\tUBOOL operator!=( const FVector& V ) const\n\t{\n\t\treturn\
      \ X!=V.X || Y!=V.Y || Z!=V.Z;\n\t}\n\n\t// Unary operators.\n\tFVector operator-()\
      \ const\n\t{\n\t\treturn FVector( -X, -Y, -Z );\n\t}\n\n\t// Assignment operators.\n\
      \tFVector operator+=( const FVector& V )\n\t{\n\t\tX += V.X; Y += V.Y; Z +=\
      \ V.Z;\n\t\treturn *this;\n\t}\n\tFVector operator-=( const FVector& V )\n\t\
      {\n\t\tX -= V.X; Y -= V.Y; Z -= V.Z;\n\t\treturn *this;\n\t}\n\tFVector operator*=(\
      \ FLOAT Scale )\n\t{\n\t\tX *= Scale; Y *= Scale; Z *= Scale;\n\t\treturn *this;\n\
      \t}\n\tFVector operator/=( FLOAT V )\n\t{\n\t\tFLOAT RV = 1.f/V;\n\t\tX *= RV;\
      \ Y *= RV; Z *= RV;\n\t\treturn *this;\n\t}\n\tFVector operator*=( const FVector&\
      \ V )\n\t{\n\t\tX *= V.X; Y *= V.Y; Z *= V.Z;\n\t\treturn *this;\n\t}\n\tFVector\
      \ operator/=( const FVector& V )\n\t{\n\t\tX /= V.X; Y /= V.Y; Z /= V.Z;\n\t\
      \treturn *this;\n\t}\n\n\t// Simple functions.\n\tFLOAT Size() const\n\t{\n\t\
      \treturn appSqrt( X*X + Y*Y + Z*Z );\n\t}\n\tFLOAT SizeSquared() const\n\t{\n\
      \t\treturn X*X + Y*Y + Z*Z;\n\t}\n\tFLOAT Size2D() const \n\t{\n\t\treturn appSqrt(\
      \ X*X + Y*Y );\n\t}\n\tFLOAT SizeSquared2D() const \n\t{\n\t\treturn X*X + Y*Y;\n\
      \t}\n\tint IsNearlyZero() const\n\t{\n\t\treturn\n\t\t\t\tAbs(X)<KINDA_SMALL_NUMBER\n\
      \t\t\t&&\tAbs(Y)<KINDA_SMALL_NUMBER\n\t\t\t&&\tAbs(Z)<KINDA_SMALL_NUMBER;\n\t\
      }\n\tUBOOL IsZero() const\n\t{\n\t\treturn X==0.f && Y==0.f && Z==0.f;\n\t}\n\
      \tUBOOL Normalize()\n\t{\n\t\tFLOAT SquareSum = X*X+Y*Y+Z*Z;\n\t\tif( SquareSum\
      \ >= SMALL_NUMBER )\n\t\t{\n\t\t\tFLOAT Scale = 1.f/appSqrt(SquareSum);\n\t\t\
      \tX *= Scale; Y *= Scale; Z *= Scale;\n\t\t\treturn 1;\n\t\t}\n\t\telse return\
      \ 0;\n\t}\n\tFVector Projection() const\n\t{\n\t\tFLOAT RZ = 1.f/Z;\n\t\treturn\
      \ FVector( X*RZ, Y*RZ, 1 );\n\t}\n\tFVector UnsafeNormal() const\n\t{\n\t\t\
      FLOAT Scale = 1.f/appSqrt(X*X+Y*Y+Z*Z);\n\t\treturn FVector( X*Scale, Y*Scale,\
      \ Z*Scale );\n\t}\n\tFVector GridSnap( const FVector& Grid )\n\t{\n\t\treturn\
      \ FVector( FSnap(X, Grid.X),FSnap(Y, Grid.Y),FSnap(Z, Grid.Z) );\n\t}\n\tFVector\
      \ BoundToCube( FLOAT Radius )\n\t{\n\t\treturn FVector\n\t\t(\n\t\t\tClamp(X,-Radius,Radius),\n\
      \t\t\tClamp(Y,-Radius,Radius),\n\t\t\tClamp(Z,-Radius,Radius)\n\t\t);\n\t}\n\
      \tvoid AddBounded( const FVector& V, FLOAT Radius=MAXSWORD )\n\t{\n\t\t*this\
      \ = (*this + V).BoundToCube(Radius);\n\t}\n\tFLOAT& Component( INT Index )\n\
      \t{\n\t\treturn (&X)[Index];\n\t}\n\n\t// Return a boolean that is based on\
      \ the vector's direction.\n\t// When      V==(0,0,0) Booleanize(0)=1.\n\t//\
      \ Otherwise Booleanize(V) <-> !Booleanize(!B).\n\tUBOOL Booleanize()\n\t{\n\t\
      \treturn\n\t\t\tX >  0.f ? 1 :\n\t\t\tX <  0.f ? 0 :\n\t\t\tY >  0.f ? 1 :\n\
      \t\t\tY <  0.f ? 0 :\n\t\t\tZ >= 0.f ? 1 : 0;\n\t}\n\n\t// Transformation.\n\
      \tFVector TransformVectorBy( const FCoords& Coords ) const;\n\tFVector TransformPointBy(\
      \ const FCoords& Coords ) const;\n\tFVector MirrorByVector( const FVector& MirrorNormal\
      \ ) const;\n\tFVector MirrorByPlane( const FPlane& MirrorPlane ) const;\n\t\
      FVector PivotTransform(const FCoords& Coords) const;\n\n\t// Complicated functions.\n\
      \tFRotator Rotation();\n\tvoid FindBestAxisVectors( FVector& Axis1, FVector&\
      \ Axis2 );\n\tFVector SafeNormal() const; //warning: Not inline because of compiler\
      \ bug.\n\n\t// Friends.\n\tfriend FLOAT FDist( const FVector& V1, const FVector&\
      \ V2 );\n\tfriend FLOAT FDistSquared( const FVector& V1, const FVector& V2 );\n\
      \tfriend UBOOL FPointsAreSame( const FVector& P, const FVector& Q );\n\tfriend\
      \ UBOOL FPointsAreNear( const FVector& Point1, const FVector& Point2, FLOAT\
      \ Dist);\n\tfriend FLOAT FPointPlaneDist( const FVector& Point, const FVector&\
      \ PlaneBase, const FVector& PlaneNormal );\n\tfriend FVector FLinePlaneIntersection(\
      \ const FVector& Point1, const FVector& Point2, const FVector& PlaneOrigin,\
      \ const FVector& PlaneNormal );\n\tfriend FVector FLinePlaneIntersection( const\
      \ FVector& Point1, const FVector& Point2, const FPlane& Plane );\n\tfriend UBOOL\
      \ FParallel( const FVector& Normal1, const FVector& Normal2 );\n\tfriend UBOOL\
      \ FCoplanar( const FVector& Base1, const FVector& Normal1, const FVector& Base2,\
      \ const FVector& Normal2 );\n\n\t// Serializer.\n\tfriend FArchive& operator<<(\
      \ FArchive& Ar, FVector& V )\n\t{\n\t\treturn Ar << V.X << V.Y << V.Z;\n\t}\n\
      \ };\n #endif\n</uscript>\n\n----\n\n'''DJPaul:''' Interesting page, rubbish\
      \ on itself.  What about we make a new page that we can put this - and other\
      \ notes about the Unreal Engine's Native Classes we've gotten out of Epic? \
      \ Perhaps hack0rz [[Legacy:Native Coding|Native Coding]] around a bit.\n\nThat\
      \ way we can link to this, the few UT2003 native classes we've gotten out of\
      \ epic via ut2003mods, the Deus Ex native sources, etc.\n\n'''Tarquin:''' What\
      \ is this page?"
  properties: []
  revId: 5587
name: "Legacy:Official UnMath Page"
revision:
  revid: 5587
  parentid: 5588
  user: "Tarquin"
  timestamp: 1076798668.000000000
  comment: "what's this?"
timestamp: 1668763600.306358000
