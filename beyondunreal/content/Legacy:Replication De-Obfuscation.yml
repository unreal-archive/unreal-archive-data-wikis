---
parse:
  title: "Legacy:Replication De-Obfuscation"
  text:
    text: "<p><b>A blatant \"copy\" from <a rel=\"nofollow\" class=\"external free\"\
      \ href=\"http://unreal.jall.org/tutorials/replication.html\">http://unreal.jall.org/tutorials/replication.html</a>,\
      \ since that link seems to be down (Web Archive copy <a rel=\"nofollow\" class=\"\
      external text\" href=\"http://web.archive.org/web/20060813220553/http://unreal.jall.org/tutorials/replication.html\"\
      >is available</a>)</b></p>\n<p><br /></p>\n<p></p>\n<div id=\"toc\" class=\"\
      toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n</div>\n<ul>\n<li class=\"\
      toclevel-1 tocsection-1\"><a href=\"#Introduction\"><span class=\"tocnumber\"\
      >1</span> <span class=\"toctext\">Introduction</span></a>\n<ul>\n<li class=\"\
      toclevel-2 tocsection-2\"><a href=\"#Server_as_Authority\"><span class=\"tocnumber\"\
      >1.1</span> <span class=\"toctext\">Server as Authority</span></a></li>\n</ul>\n\
      </li>\n<li class=\"toclevel-1 tocsection-3\"><a href=\"#Replication_Overview\"\
      ><span class=\"tocnumber\">2</span> <span class=\"toctext\">Replication Overview</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-4\"><a href=\"#Relevant_Actors\"><span class=\"\
      tocnumber\">3</span> <span class=\"toctext\">Relevant Actors</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-5\"><a href=\"#NetPriorities\"><span class=\"\
      tocnumber\">4</span> <span class=\"toctext\">NetPriorities</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-6\"><a href=\"#Roles_and_RemoteRoles_Introduction\"\
      ><span class=\"tocnumber\">5</span> <span class=\"toctext\">Roles and RemoteRoles\
      \ Introduction</span></a></li>\n<li class=\"toclevel-1 tocsection-7\"><a href=\"\
      #General_Replication\"><span class=\"tocnumber\">6</span> <span class=\"toctext\"\
      >General Replication</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-8\"\
      ><a href=\"#No_Recursive_Relevancy\"><span class=\"tocnumber\">6.1</span> <span\
      \ class=\"toctext\">No Recursive Relevancy</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-9\"><a href=\"#Replication_Checks\"><span class=\"tocnumber\">6.2</span>\
      \ <span class=\"toctext\">Replication Checks</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-10\"><a href=\"#Special_Replication_Variables\"><span class=\"\
      tocnumber\">6.3</span> <span class=\"toctext\">Special Replication Variables</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-11\"><a href=\"#NetUpdateFrequency\"><span\
      \ class=\"tocnumber\">6.4</span> <span class=\"toctext\">NetUpdateFrequency</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-12\"><a href=\"#Reliable_versus_Unreliable\"\
      ><span class=\"tocnumber\">6.5</span> <span class=\"toctext\">Reliable versus\
      \ Unreliable</span></a></li>\n<li class=\"toclevel-2 tocsection-13\"><a href=\"\
      #Writing_Replication_Statements\"><span class=\"tocnumber\">6.6</span> <span\
      \ class=\"toctext\">Writing Replication Statements</span></a></li>\n</ul>\n\
      </li>\n<li class=\"toclevel-1 tocsection-14\"><a href=\"#Variable_Replication\"\
      ><span class=\"tocnumber\">7</span> <span class=\"toctext\">Variable Replication</span></a>\n\
      <ul>\n<li class=\"toclevel-2 tocsection-15\"><a href=\"#Newly_Relevant_Actors_.28Spawning.29\"\
      ><span class=\"tocnumber\">7.1</span> <span class=\"toctext\">Newly Relevant\
      \ Actors (Spawning)</span></a></li>\n<li class=\"toclevel-2 tocsection-16\"\
      ><a href=\"#A_Time_for_Replication\"><span class=\"tocnumber\">7.2</span> <span\
      \ class=\"toctext\">A Time for Replication</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-17\"><a href=\"#Client-Server_Replication\"><span class=\"tocnumber\"\
      >7.3</span> <span class=\"toctext\">Client-Server Replication</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-18\"><a href=\"#Replication_Only_When_Necessary\"\
      ><span class=\"tocnumber\">7.4</span> <span class=\"toctext\">Replication Only\
      \ When Necessary</span></a></li>\n<li class=\"toclevel-2 tocsection-19\"><a\
      \ href=\"#Replication_Data_Approximation\"><span class=\"tocnumber\">7.5</span>\
      \ <span class=\"toctext\">Replication Data Approximation</span></a></li>\n</ul>\n\
      </li>\n<li class=\"toclevel-1 tocsection-20\"><a href=\"#Variable_Replication_Examples\"\
      ><span class=\"tocnumber\">8</span> <span class=\"toctext\">Variable Replication\
      \ Examples</span></a></li>\n<li class=\"toclevel-1 tocsection-21\"><a href=\"\
      #Role_and_RemoteRole_Summary\"><span class=\"tocnumber\">9</span> <span class=\"\
      toctext\">Role and RemoteRole Summary</span></a></li>\n<li class=\"toclevel-1\
      \ tocsection-22\"><a href=\"#Function_Replication.2C_and_Simulation\"><span\
      \ class=\"tocnumber\">10</span> <span class=\"toctext\">Function Replication,\
      \ and Simulation</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-23\"><a\
      \ href=\"#Rep.2FSim_Function_Rules\"><span class=\"tocnumber\">10.1</span> <span\
      \ class=\"toctext\">Rep/Sim Function Rules</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-24\"><a href=\"#Rep.2FSim_Function_Rules_Restatement\"><span class=\"\
      tocnumber\">10.2</span> <span class=\"toctext\">Rep/Sim Function Rules Restatement</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-25\"><a href=\"#Rep.2FSim_Function_Summary\"\
      ><span class=\"tocnumber\">10.3</span> <span class=\"toctext\">Rep/Sim Function\
      \ Summary</span></a></li>\n<li class=\"toclevel-2 tocsection-26\"><a href=\"\
      #Spawning_Within_Simulated_Functions\"><span class=\"tocnumber\">10.4</span>\
      \ <span class=\"toctext\">Spawning Within Simulated Functions</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-27\"><a href=\"#Networked-Function_Paramater_Optimizations\"\
      ><span class=\"tocnumber\">10.5</span> <span class=\"toctext\">Networked-Function\
      \ Paramater Optimizations</span></a></li>\n<li class=\"toclevel-2 tocsection-28\"\
      ><a href=\"#Simulated_States\"><span class=\"tocnumber\">10.6</span> <span class=\"\
      toctext\">Simulated States</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1\
      \ tocsection-29\"><a href=\"#Level_NetModes_and_their_Implications\"><span class=\"\
      tocnumber\">11</span> <span class=\"toctext\">Level NetModes and their Implications</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-30\"><a href=\"#Special_Properties_about_Special_Stuff\"\
      ><span class=\"tocnumber\">12</span> <span class=\"toctext\">Special Properties\
      \ about Special Stuff</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-31\"\
      ><a href=\"#bNetOptional_Usage\"><span class=\"tocnumber\">12.1</span> <span\
      \ class=\"toctext\">bNetOptional Usage</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-32\"><a href=\"#bNetTemporary_Usage\"><span class=\"tocnumber\"\
      >12.2</span> <span class=\"toctext\">bNetTemporary Usage</span></a></li>\n<li\
      \ class=\"toclevel-2 tocsection-33\"><a href=\"#PlaySound.27s_and_PlayOwnedSound.27s_Special_Behaviors\"\
      ><span class=\"tocnumber\">12.3</span> <span class=\"toctext\">PlaySound's and\
      \ PlayOwnedSound's Special Behaviors</span></a></li>\n<li class=\"toclevel-2\
      \ tocsection-34\"><a href=\"#ClientPlaySound_and_ClientReliablePlaySound\"><span\
      \ class=\"tocnumber\">12.4</span> <span class=\"toctext\">ClientPlaySound and\
      \ ClientReliablePlaySound</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1\
      \ tocsection-35\"><a href=\"#When_Things_Go_Awry\"><span class=\"tocnumber\"\
      >13</span> <span class=\"toctext\">When Things Go Awry</span></a></li>\n<li\
      \ class=\"toclevel-1 tocsection-36\"><a href=\"#Figure_Out_What.27s_Going_On\"\
      ><span class=\"tocnumber\">14</span> <span class=\"toctext\">Figure Out What's\
      \ Going On</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-37\"><a href=\"\
      #Check_the_Replication_Statements\"><span class=\"tocnumber\">14.1</span> <span\
      \ class=\"toctext\">Check the Replication Statements</span></a></li>\n<li class=\"\
      toclevel-2 tocsection-38\"><a href=\"#Logging_is_Your_Friend\"><span class=\"\
      tocnumber\">14.2</span> <span class=\"toctext\">Logging is Your Friend</span></a></li>\n\
      </ul>\n</li>\n<li class=\"toclevel-1 tocsection-39\"><a href=\"#Testing_Real-World_Conditions\"\
      ><span class=\"tocnumber\">15</span> <span class=\"toctext\">Testing Real-World\
      \ Conditions</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-40\"><a href=\"\
      #Testing_a_Mod_in_Netplay_without_a_Network\"><span class=\"tocnumber\">15.1</span>\
      \ <span class=\"toctext\">Testing a Mod in Netplay without a Network</span></a>\n\
      <ul>\n<li class=\"toclevel-3 tocsection-41\"><a href=\"#Windows_9x\"><span class=\"\
      tocnumber\">15.1.1</span> <span class=\"toctext\">Windows 9x</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-42\"><a href=\"#Windows_NT.2F2000\"><span\
      \ class=\"tocnumber\">15.1.2</span> <span class=\"toctext\">Windows NT/2000</span></a></li>\n\
      </ul>\n</li>\n<li class=\"toclevel-2 tocsection-43\"><a href=\"#Simulating_Lag_and_PacketLoss\"\
      ><span class=\"tocnumber\">15.2</span> <span class=\"toctext\">Simulating Lag\
      \ and PacketLoss</span></a>\n<ul>\n<li class=\"toclevel-3 tocsection-44\"><a\
      \ href=\"#PktLoss\"><span class=\"tocnumber\">15.2.1</span> <span class=\"toctext\"\
      >PktLoss</span></a></li>\n<li class=\"toclevel-3 tocsection-45\"><a href=\"\
      #PktOrder\"><span class=\"tocnumber\">15.2.2</span> <span class=\"toctext\"\
      >PktOrder</span></a></li>\n<li class=\"toclevel-3 tocsection-46\"><a href=\"\
      #PktLag\"><span class=\"tocnumber\">15.2.3</span> <span class=\"toctext\">PktLag</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-47\"><a href=\"#PktDup\"><span class=\"tocnumber\"\
      >15.2.4</span> <span class=\"toctext\">PktDup</span></a></li>\n<li class=\"\
      toclevel-3 tocsection-48\"><a href=\"#Using_the_Variables\"><span class=\"tocnumber\"\
      >15.2.5</span> <span class=\"toctext\">Using the Variables</span></a></li>\n\
      </ul>\n</li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-49\"><a href=\"\
      #Conclusion\"><span class=\"tocnumber\">16</span> <span class=\"toctext\">Conclusion</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-50\"><a href=\"#Special_Networking_Tricks_.28Case_Studies.29\"\
      ><span class=\"tocnumber\">17</span> <span class=\"toctext\">Special Networking\
      \ Tricks (Case Studies)</span></a></li>\n</ul>\n</div>\n<p></p>\n<h2><span class=\"\
      mw-headline\" id=\"Introduction\">Introduction</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=1\"\
      \ title=\"Edit section: Introduction\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Ask any halfway decent UnrealScript programmer what\
      \ the most confusing aspect of Unreal coding, and he'll be sure to tell you\
      \ replication. (or perhaps PlayerMovement or pawn/bot AI&#160;:) I've been there\
      \ myself, and I still have trouble with it sometimes, but I think I know enough\
      \ to write some documentation. Lots of trial and error helped me get far, along\
      \ with various insights from people that had the source code to the engine.\
      \ I've tried to piece it all together to create this document. I have however,\
      \ recently gotten a lot more information about exactly how replication works,\
      \ which has helped me immensely in understanding replication. Since I can't\
      \ post that information directly because of NDA, I'll try my best to explain\
      \ it to you through this networking documentation. Hopefully I'll be able to\
      \ expand upon what was described in Epic's documents at: <a rel=\"nofollow\"\
      \ class=\"external free\" href=\"http://unreal.epicgames.com/Network.htm\">http://unreal.epicgames.com/Network.htm</a>\
      \ and <a rel=\"nofollow\" class=\"external free\" href=\"http://unreal.epicgames.com/UTMods.html\"\
      >http://unreal.epicgames.com/UTMods.html</a>. Please read it first, as it will\
      \ help a lot with background and context. In writing this document, I'm going\
      \ to assume you've programmed in UnrealScript before, you have at the very least\
      \ considered the problems of replication, you are reasonably intelligent, you\
      \ know how to read, and you think my jokes are funny.</p>\n<p>First, Unreal\
      \ Tournament uses a client-server architecture. The client is basically a dumb\
      \ terminal, that sends data to the server about where the player moved, if they're\
      \ jumping, if they're shooting, etc. It displays to the user what is given to\
      \ it by the server. The client's information is necessarily out of date with\
      \ what exists on the server, because of lag, ping time, and other factors. So\
      \ in order to present a believable world, the client has logic to simulate what\
      \ it thinks the server will be sending it. It knows the laws of physics, and\
      \ that if something is travelling in a straight line, then it will contine to\
      \ travel with that same velocity. Likewise, if it's falling through the air,\
      \ it's likely to continue to be accelerated under the force of gravity. The\
      \ dumb terminal predicts where how the game state will be progressing, and so\
      \ can provide the user with a more believable game. On the other end of the\
      \ connection is the server, which holds the authoritative state of what's going\
      \ on in the game. If the server thinks you are dead, then you are dead. Like\
      \ your teachers, they're never wrong, no matter how much evidence you've seen\
      \ to the contrary (like how you *thought* you dodged that rocket). The client\
      \ gets information sent to it by the server (like where other people are, what\
      \ things have been shot, etc) , and sends other information back to the server\
      \ (like where the client wants to move, shoot, etc). In the client-server architecture,\
      \ the client only communicates with the server, and the server communicates\
      \ with all of the clients (people connected to the server).</p>\n<h3><span class=\"\
      mw-headline\" id=\"Server_as_Authority\">Server as Authority</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=2\"\
      \ title=\"Edit section: Server as Authority\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>With the recent brew-ha-ha regarding the ZeroPing\
      \ mod, which aims to give the client more control, there have been two sides\
      \ to the issue of why the server as authority is the best model.</p>\n<p>A good\
      \ description of the history of the networking architectures in games can be\
      \ found at the top of the tech page's networking document. Go read the \"History\"\
      \ section now, and then come back. The current model is that of a client-server\
      \ architecture, where the client has prediction to minimize the effects of lag.\
      \ In current versions of UT, the client tells the server all about it's input.\
      \ Where is the user looking, in which direction are they moving, and are they\
      \ firing primary or secondary fires.. The server then uses that data to calculate\
      \ information about the player, and to tell other clients about that player.\
      \ For the most part, that is all there is to it. ZeroPing pioneered an idea\
      \ of giving the client more power. It allowed the client to decide whether they\
      \ hit the other player. In theory, this sounds great. The user gets to decide\
      \ what's happening, and if they hit the player, then they hit the player. Unfortunately,\
      \ there are problems with this idea.</p>\n<p>In a large-scale game like UT or\
      \ Q3A, many people try to cheat. The people that make the game have to prevent\
      \ that from happening. With these games, the client does so little logic, that\
      \ there is little room to cheat. The client sends its data to the server, and\
      \ the trusted server decides whether they hit the player or not. Cheats are\
      \ extremely limited in what they can do, as they can only modify the direction\
      \ the player is going, and whether to cheat or not. It's not something that\
      \ is really worthwhile. However, when you have something like ZeroPing, you\
      \ are letting the client decide whether or not you hit the player. A cheat can\
      \ pretend that it hit every player, and can wreck havoc in such a game, where\
      \ it is killing everyone the moment they enter view, and sometimes even getting\
      \ repeated kills ten times in a row on a single player as they respawn and then\
      \ are 'hit' again. Mods like ZeroPing are mods, and so do not ahve the same\
      \ public appeal that a full game does. As such, mods are less likely to be hacked\
      \ for cheats. But it does not make them immune. If game makers were to use the\
      \ approach that ZeroPing uses, there would be a flood of cheats within weeks\
      \ of the game's release. You can understand the resistance that the game companies\
      \ have for such an approach. It is not because it's the 'not-invented-here'\
      \ syndrome as many have suggested, but rather that it really is much more open\
      \ to cheating.</p>\n<p>As a side note, I guess the ZeroPing author does realize\
      \ this. He has hidden his code to make it impossible to cheat with. He took\
      \ the security through obfuscation approach. This will work for awhile, until\
      \ code decompilers become available, or the code gets out. While I am not working\
      \ on any of these myself, I do know of some UnrealScript code decompilers in\
      \ the works. So this approach really will not work in the long run.</p>\n<h2><span\
      \ class=\"mw-headline\" id=\"Replication_Overview\">Replication Overview</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=3\" title=\"Edit section:\
      \ Replication Overview\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Replication deals with how information is sent from the server to the client\
      \ and vice versa. Because of bandwidth limitations for modems, not everything\
      \ can be sent, and because of the unpredictability of the Internet, not everything\
      \ can be ensured of arriving on time. Only a subset of all the information is\
      \ sent to the client, and replication deals with that subset that travels from\
      \ the server to the client, and deals with how the client sends its relevant\
      \ information back to the server.</p>\n<p>While the definition of replication\
      \ may sound simple, there is a lot of underlying assumptions and quirks that\
      \ you must be aware of, which UT uses in the interest of optimum bandwidth and\
      \ speed. It's an unmapped jungle out there, and many an explorer has been lost\
      \ to the dangerous native inhabitants. This guide you are reading is your map\
      \ and survival guide.</p>\n<p>First, the Unreal server does some logic like\
      \ the following for each client connected:</p>\n<ol>\n<li>Run all events (like\
      \ tick, timer, hitwall, etc)</li>\n<li>Go through each client connected to the\
      \ server</li>\n<li>Get the list of relevant actors for this client.</li>\n<li>For\
      \ each actor, replicate variables that need to be replicated.</li>\n<li>Replicate\
      \ any function calls that should be replicated to that particular client, if\
      \ they were called during the previous server-side events run above.</li>\n\
      </ol>\n<p>The client does the following logic:</p>\n<ol>\n<li>Receive data from\
      \ the server, and update its local copies of the actors</li>\n<li>Run any replicated\
      \ calls that were called on the server</li>\n<li>Run any simulated events (like\
      \ tick, timer, hitwall, etc), and do the local playerpawn handling</li>\n<li>Find\
      \ out what replicated were called on the client and need to be replicated to\
      \ the server, and send them</li>\n</ol>\n<p>If that didn't make any sense, don't\
      \ worry about it. They just outline the main parts of replication, and they\
      \ will all be explained later.</p>\n<p>If you did understand that, there's still\
      \ plenty to learn. UT has a lot of logic going on under the hood in regards\
      \ to replication, most of which is not immediately apparent. That was the purpose\
      \ of this document, to explain these mysteries to you, the reader, so that your\
      \ networking development will go that much more smoothly. Again, all this will\
      \ be explained in due time, assuming you read the whole document.&#160;:)</p>\n\
      <h2><span class=\"mw-headline\" id=\"Relevant_Actors\">Relevant Actors</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=4\" title=\"Edit section:\
      \ Relevant Actors\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>First, we need to define what a relevant actor is. A client, as the dumb\
      \ terminal, needs to know about everything that it will need to display on screen.\
      \ It needs to know about the other players, and weapons in the level, if any\
      \ projectiles are visible, if the flag is visible, health packs, etc. All of\
      \ these actors constitute the relevant set of actors. how is the relevant set\
      \ of actors determined? If an actor is not relevant, no amount of replication\
      \ statements or voodoo magic will cause its information to be sent to the client.\
      \ It must be relevant to that particular client in order for data to be sent\
      \ to that client. For Unreal / Unreal Tournament, the method of determining\
      \ relevant actors is as follows (ripped from the tech page's networking document):</p>\n\
      <p>The following logic is performed on each actor, and you should be able to\
      \ tell whether it is relevant. The actor must pass two discrete sets of steps\
      \ in order to be considered relevant. One it passes the first test, it must\
      \ then pass the second. The rules higher in the list have precedence over rules\
      \ that follow them:</p>\n<ol>\n<li>If it is bNetTemporary, then it does not\
      \ pass the first stage.</li>\n<li>If it is not bStatic and not bNoDelete, then\
      \ it passes the first stage.</li>\n<li>If it is a LevelInfo, it passes the first\
      \ stage.</li>\n<li>If it is a temporary network actor, (as defined by bNetTemporary),\
      \ and it's been sent to this client already, then it does not pass the first\
      \ stage. These types of actors will be decribed in more detail later.</li>\n\
      <li>If its Role is ROLE_None, then does not pass the first stage.</li>\n<li>If\
      \ it is bAlwaysRelevant, and time since the last relevancy is less than 1 /\
      \ NetUpdateFrequency (described farther below) seconds, then it does not pass\
      \ the first stage. This basically means an actor will only update it's variables\
      \ to the client NetUpdateFrequency times per second. (NetUpdateFrequency values:\
      \ Actor: 100, ZoneInfo: 4, GameReplicationInfo: 4, PlayerReplicationInfo: 2,\
      \ or Inventory: 8).</li>\n<li>If it is bNetOptional, and it has a non-zero LifeSpan\
      \ (meaning it does not exist forever), and it is not in the first 150 ms of\
      \ its lifetime, then it passes the first stage. Any attempt at replicating a\
      \ bNetOptional actor after the first 150 ms, (because it was pushed off the\
      \ replication list due to bandwidth contraints for that client, etc,) will fail.</li>\n\
      <li>If the time since the last relevancy is greater than 1 / ~NetUpdateFrequency\
      \ seconds, it passes the first stage. (This is a more finely tuned optimization\
      \ of NetUpdateFrequency, tuned to the type of actor. It will only perform the\
      \ calculations needed if it has passed through the weeding techniques above.)</li>\n\
      <li>It does not pass the first stage.</li>\n</ol>\n<p>If it passed all of those\
      \ steps, it's not through and clear to be relevant yet. It has another step\
      \ to go through. If it is deemed relevant during the following steps, then it\
      \ is relevant to this client.</p>\n<ol>\n<li>If it is bAlwaysRelevant, then\
      \ it is relevant.</li>\n<li>If it is owned by the client or owned by the actor\
      \ we are viewing through (as returned by PlayerCalcView), then it is relevant.</li>\n\
      <li>If it is the client or the actor we are viewing through (as returned by\
      \ PlayerCalcView), then it is relevant.</li>\n<li>If its Instigator is the client,\
      \ then it is relevant.</li>\n<li>If it has an ambient sound and is within 'audible\
      \ distance', then it is relevant.</li>\n<li>If it is a weapon that is owned\
      \ by a visible Pawn owner, then it is relevant.</li>\n<li>If it is bHidden or\
      \ and not bBlockPlayers and the AmbientSound is none, then the actor is not\
      \ relevant.</li>\n<li>If it is not relevant (per the above tests), but if any\
      \ of the above conditions made it relevant within the last RelevantTimeout seconds,\
      \ (by default, five seconds, but is defined in UnrealTournament.ini:[IpDrv.TcpNetDriver],)\
      \ then it is relevant.</li>\n<li>It is not relevant.</li>\n</ol>\n<p>Those rules,\
      \ while seeming complicated, are exactly how UT determines what is relevant\
      \ to each client. Many times such checks are not related to what you are doing,\
      \ but they are always good to know. Thinking about it, it makes sense. If something\
      \ is not visible, then the client probably does not need to know about it. If\
      \ it's a player on the other side of CTF-LavaGiant, what use does this client\
      \ have for it? Or if it's an invisible pathnode used for Bot AI, the client\
      \ also has no use for it. Sending data and variables for such actors would be\
      \ wasteful on a tiny little 28.8 kbps modem.</p>\n<p>Working this discussion\
      \ into a guideline for your own code, you should set your actors' bAlwaysRelevant\
      \ to true if they are data storage units that the client needs to know about,\
      \ like PlayerReplicationInfo or GameReplicationInfo. Things like PlayerReplicationInfo,\
      \ which store information about the player, are always relevant. This allows\
      \ a client to view the Scoreboard and see the information (name, score, ping,\
      \ packetloss, etc) for everyone in the level, regardless of whether that player\
      \ actor is relevant to the client. PlayerReplicationInfo's allow precious information\
      \ that's small, bandwidth wise, to be relevant and replicated to each client,\
      \ yet have information like the location, velocity, weapon, animations, etc\
      \ of the player to not be replicated when it's not necessary (because it's in\
      \ the Pawn/PlayerPawn, which is not always relevant.) Hopefully I've not lost\
      \ you here. It's an important thing to know and remember about Unreal replication.\
      \ Where to put your variables, and how to make them relevant to the client.\
      \ If you needed some important game information to be seen by all clients, your\
      \ best bet would be to subclass ReplicationInfo and utilize that for your data\
      \ variables. Information that is only needed when it's seen is best put in regular\
      \ actors, that will go in and out of relevancy as time passes.</p>\n<p>In a\
      \ nutshell, if the client needs to know about it, they will. All inventory is\
      \ relevant to the client, as is all nearby players. All projectiles and weapon\
      \ effects that are visible are relelvant. Anything that affects the player's\
      \ world on the client, will be replicated. This includes things that block the\
      \ player's movement, or actors that play ambient music. There is an overhead\
      \ to spawning a new actor in netplay, and so UT does not immediately remove\
      \ an actor from the relevancy list when it goes out of view. It gives it a few\
      \ seconds before it is really considered not relevant. Oh, and UT takes into\
      \ account the fact that a player may be viewing through another actor's eyes,\
      \ as in the case of the GuidedWarhead, or the teammate views when you hit the\
      \ number keys on the right side of your keyboard.</p>\n<h2><span class=\"mw-headline\"\
      \ id=\"NetPriorities\">NetPriorities</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=5\"\
      \ title=\"Edit section: NetPriorities\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>While that's the \"simple\" description, figuring\
      \ out why things happen can get a bit more complicated. Unreal Tournament gives\
      \ different priorities for different types of actors. NetPriority, which should\
      \ typically be between 1 and 3, determines how to prioritize a given actor's\
      \ bandwidth \"allocation\" in the stream being sent to each client. Actors are\
      \ first sorted by a calculation based upon their priority (adjusted to take\
      \ into account how close the client is looking at them, etc.) Actors marked\
      \ bNetOptional are sent to the bottom of the list. So....actors with a higher\
      \ priority are sent first in the bandwidth stream, and when the connection becomes\
      \ saturated, any remaining actors are starved of bandwidth until later. (UT\
      \ remembers which actors have not been replicated, and so it can give bNetOptional\
      \ actors 150 ms to get replicated before they are discarded. See the above relevancy\
      \ list for more information.)</p>\n<p>Here's a wide and almost complete sampling\
      \ of UT's NetPriorities:</p>\n<table>\n<tr>\n<td>Bots</td>\n<td>3.0</td>\n</tr>\n\
      <tr>\n<td>PlayerPawns</td>\n<td>3.0</td>\n</tr>\n<tr>\n<td>GuidedRedeemer</td>\n\
      <td>3.0</td>\n</tr>\n<tr>\n<td>Movers</td>\n<td>2.7</td>\n</tr>\n<tr>\n<td>Projectiles</td>\n\
      <td>2.5</td>\n</tr>\n<tr>\n<td>Carcasses</td>\n<td>2.5</td>\n</tr>\n<tr>\n<td>Other\
      \ Pawns (Spectators, Titans, Bunny Rabbits, etc)</td>\n<td>2.0</td>\n</tr>\n\
      <tr>\n<td>Effects (sparks, blood, smoke)</td>\n<td>2.0</td>\n</tr>\n<tr>\n<td>Simpler\
      \ effects (shell casings)</td>\n<td>1.4</td>\n</tr>\n<tr>\n<td>Inventory</td>\n\
      <td>1.4 or 2.5</td>\n</tr>\n<tr>\n<td>Everything else</td>\n<td>1.0</td>\n</tr>\n\
      </table>\n<p>This shows that the server considers a Player's (be it bot or playerpawn)\
      \ information to be much more important than something like bullet casings from\
      \ a gun. And it makes sense. A guided redeemer also has unpredictability to\
      \ it, since it is controlled by a player, and thus needs a higher NetPriority.\
      \ A projectile follows the simple Physics given to it, eg: PHYS_Falling, PHYS_Projectile,\
      \ and so they are not very unpredictable. Thus, its NetPriority is not as high\
      \ as a player's. However, projectiles are still quite important to gameplay\
      \ (doesn't it suck to get hit by that rocket you never saw?&#160;:), and they\
      \ get a high NetPriority. It's the same with the carcasses, since their animations\
      \ as they fly through the air or fall to the ground are quite important (not\
      \ to gameplay, but to that touchy-feel-good feeling when you kill someone.)\
      \ You should use these examples as a guide when creating your own actors that\
      \ need a different priority.</p>\n<p>One additional thing to note is that you\
      \ can change the NetPriority on the fly. This is done with Inventory, for example.\
      \ It exists as 1.4 for most of its life, but when it is thrown from a player's\
      \ inventory, it now is a moving actor with more importance attached to it. It\
      \ is then given a higher NetPriority. Once it hits the ground, it gets a NetPriority\
      \ of 1.4 again, since it does not need to be updated as often when it is sitting\
      \ stationary on the ground.</p>\n<p>In general, all of the relevant actors for\
      \ a particular client are put in an array each tick, and then sorted by their\
      \ priorities. The server then starts replication the actors, starting with the\
      \ highest NetPrioritized actor, working it's way down. UT then stops replicating\
      \ actors when the bandwidth becomes saturated. That's why it's important to\
      \ prioritize your actors correctly, so that when a lot of actors are on screen,\
      \ or on the lowly 28.8K connections, UT will know how to perform triage, and\
      \ who to starve of bandwidth first. If an actor is not replicated, the variables\
      \ it was supposed to tell the client about are not forgotten. They will be put\
      \ on the list during the next tick, to have another go at getting replicated.\
      \ Note that doubling the size of the actor's NetPriority does not actually change\
      \ anything in regards to giving it more bandwidth, since a NetPriority only\
      \ has meaning in relation to other NetPriorities. Since 3.0 is the highest on\
      \ the list, there is no real difference between giving your actor a NetPriority\
      \ of 4.0 and 4000.0, since they will both be placed at the top of the list.</p>\n\
      <h2><span class=\"mw-headline\" id=\"Roles_and_RemoteRoles_Introduction\">Roles\
      \ and RemoteRoles Introduction</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=6\"\
      \ title=\"Edit section: Roles and RemoteRoles Introduction\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h2>\n<p>Now is a good a time as any\
      \ to explain the purposes of the various roles in Unreal. Roles simply guide\
      \ UT in determining what role this particular actor plays in the game of replication.\
      \ For example, a player needs to be replicated quite differently from an ammo\
      \ box sitting on the ground, or a projectile moving according to the rules of\
      \ physics. On a server, the Role will be ROLE_Authority, which makes sense since\
      \ that actor is currently being evaluated on the authoritative server. The RemoteRole\
      \ of that actor will be set to any of a variety of roles, defined below. On\
      \ the client, the Role and RemoteRole will be reversed. On the client, the RemoteRole\
      \ will be ROLE_Authority, and the Role will be one of the other role types.\
      \ Let's go through the various roles (which will be set in the RemoteRole default\
      \ properties), in order of increasing 'control.'</p>\n<dl>\n<dt>ROLE_None</dt>\n\
      <dd>This role is probably the simplest. It simply tells the server not to make\
      \ this actor relevant to the client. No information will be sent about it, and\
      \ it will exist where it was created only. If it was created on both the client\
      \ and the server (via a simulated function, described later), and given a Role\
      \ of ROLE_None, then it would exist both on the server and on the client, and\
      \ they would both operate independently of each other.</dd>\n<dt>ROLE_DumbProxy</dt>\n\
      <dd>This role is used for objects that don't move much, yet still need information\
      \ about them updated to the client. The server does this by sending periodic\
      \ updates about this actor's location and velocity to the client. If the actor\
      \ has any sort of logic to it, with Physics, for example, it's much better to\
      \ use the following role.</dd>\n<dt>ROLE_SimulatedProxy</dt>\n<dd>This is used\
      \ for anything that should be simulated over the network, via prediction. Take\
      \ a rocket, for example. It always travels in a straight line, and is an ideal\
      \ candidate for SimulatedProxy. By the same token, UT can predict the falling\
      \ physics clientside, and so grenades, and falling people are also good candidates\
      \ for this role. Anything that can be predicted clientside because of Physics\
      \ or clientside physics should use this Role. All Bots and PlayerPawns use this\
      \ role as well, since when a player is running, he's more than likely to continue\
      \ to run. It's the best prediction method that can be used for unpredictable\
      \ players. The only exception to this is the playerpawn you yourself are playing\
      \ as.</dd>\n<dt>ROLE_AutonomousProxy</dt>\n<dd>This is used for you. When you\
      \ play online, you yourself should be treated differently from all other playerpawns.\
      \ You don't want your own self being predicted based upon the server's expectations.\
      \ Rather, you want to control yourself and tell the server where you are moving.\
      \ With this Role, that's easily possible. Many things that should only be done\
      \ for your own playerpawn, like server-corrections of your location when you\
      \ get lagged out, are only done with this role.</dd>\n<dt>ROLE_Authority</dt>\n\
      <dd>This role is different from the others in that it is always the Role on\
      \ the server. On the server, all Roles will be ROLE_Authority, and the RemoteRole\
      \ will be one of the above. On the client, the reverse will be true. This role\
      \ doesn't have any real significance, beyond it's use in replication statements,\
      \ described below.</dd>\n</dl>\n<h2><span class=\"mw-headline\" id=\"General_Replication\"\
      >General Replication</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=7\" title=\"\
      Edit section: General Replication\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>For each actor that is deemed to be relevant to a\
      \ particular client, the server needs to determine what subset of its variables\
      \ will be sent to the client. The most obvious rule is to only send variables\
      \ if they change. Unfortunately, that rule alone is not enough to fit data over\
      \ a modem. Instead, the server has to further whittle down its list of variables,\
      \ and it does this through replication statements. These replication statements\
      \ are executed for each client, for each relevant actor to that client. When\
      \ a subset of the variables of a subset of the actors are sent over the network,\
      \ only then can it be fit on a regular modem. But how can a client operate without\
      \ all of the information in the game? Once you stop and think about it, it's\
      \ not quite that unthinkable. Do all of a Bot's AI variables need to be replicated\
      \ to the client? Only the result of the AI needs to be sent, which basically\
      \ consists of the same thing for any other Pawn in the game. Also, depending\
      \ upon the RemoteRole, different things are replicated. Some cause the Location\
      \ to be updated periodically as a poor man's simulation of its motion, while\
      \ another role causes the physics to be replicated, and the location not to\
      \ be, creating true client-side simulation of the actor's motion.</p>\n<h3><span\
      \ class=\"mw-headline\" id=\"No_Recursive_Relevancy\">No Recursive Relevancy</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=8\" title=\"Edit section:\
      \ No Recursive Relevancy\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n\
      <p>Please note one important point that can easily be overlooked. Relevancy\
      \ is not recursive with replicated references to variables. Let's say that Actor\
      \ A contains a reference to Actor B in Property C, and Actor A replicates Property\
      \ C (currently set to Actor B). Let's also say that Actor A is relevant, and\
      \ Actor B is not. (Don't worry, there's only three letters in this example.)\
      \ In this example, Actor A is relevant, and so it's Property C variable will\
      \ be replicated to the client. Now what does the client know? The client knows\
      \ about Actor B through Actor A's reference, but Actor B is not relevant. All\
      \ of Actor B's variables are not checked for replication. The client only knows\
      \ about Actor B, which really is of no use whatsoever, since the variables are\
      \ not replicated. I initially thought that replicated variables to actors caused\
      \ those actors to be relevant and parsed themselves for replicated variables,\
      \ but that view is false. An actor can only be relevant according to the rules\
      \ stated above, which make no provision for a reliable reference to them from\
      \ a relevant actor.</p>\n<h3><span class=\"mw-headline\" id=\"Replication_Checks\"\
      >Replication Checks</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=9\" title=\"\
      Edit section: Replication Checks\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>When you think about the number of clients in a server,\
      \ and the number of relevant actors for each client, and the number of replication\
      \ checks on variables for each actor, there's a large number of such checks.\
      \ Special care should be taken when implementing replication statements. As\
      \ each conditional is evaluated, you should be considerate of the server's limited\
      \ processing ability. Don't call functions from within replication statements,\
      \ as function calls are much too slow for replication statements. Along the\
      \ same lines, you should try to keep your checks as simple as possible, only\
      \ evaluating a condition if its necessary. Finally, note that Epic had a problem\
      \ with replication checks taking too long for some important actors like Actor\
      \ or Inventory, both of which replicate many variables. To alleviate the situation\
      \ on servers, Epic moved the checks to native code. That's why you will see\
      \ the 'nativereplication' on a few of the Engine classes. Any variables being\
      \ evaluated in those classes will be covered by the nativereplication code,\
      \ making any UnrealScript replication statements useless in that class, (except\
      \ as a form of documentation for UnrealScript programmers.) Any variables that\
      \ are not defined in a nativereplication class, (defined in a non-nativereplication\
      \ subclass or superclass,) will be replicated via the unrealscript definitions.\
      \ Despite the fact that the nativereplication checks are in C++, the UnrealScript\
      \ checks that remain in those classes are still accurate, and a good guide to\
      \ go by in determining problems with replication, and ways around it.</p>\n\
      <h3><span class=\"mw-headline\" id=\"Special_Replication_Variables\">Special\
      \ Replication Variables</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=10\"\
      \ title=\"Edit section: Special Replication Variables\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>When writing replication conditionals,\
      \ there are a few things you should be aware of. During replication, a few helpful\
      \ variables are set for your use in evaluating whether it should be replicated.\
      \ These variables are defined in actor, and are:</p>\n<dl>\n<dt>bNetInitial</dt>\n\
      <dd>true if this is the first time this actor is being replicated across the\
      \ network. Useful for variables that differ from the defaultproperties, yet\
      \ will not change over the life of the actor.</dd>\n<dt>bNetOwner</dt>\n<dd>true\
      \ if the player we are replicating to owns this actor directly.</dd>\n<dt>bSimulatedPawn</dt>\n\
      <dd>true if the actor is a pawn (or a pawn subclass) with Role == ROLE_SimulatedProxy.\
      \ In other words, true if it's a pawn that's not the client.</dd>\n<dt>bDemoRecording</dt>\n\
      <dt>bClientDemoRecording</dt>\n<dt>bClientDemoNetFunc</dt>\n<dd>used for demo\
      \ recording purposes.</dd>\n<dt>bNetRelevant</dt>\n<dt>bNetSee</dt>\n<dt>bNetHear</dt>\n\
      <dt>bNetFeel</dt>\n<dd>Not used anymore, never even set.</dd>\n</dl>\n<h3><span\
      \ class=\"mw-headline\" id=\"NetUpdateFrequency\">NetUpdateFrequency</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=11\" title=\"Edit section:\
      \ NetUpdateFrequency\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n\
      <p>NetUpdateFrequency is another variable useful in replication. It effectively\
      \ causes an otherwise relevant (not useful when the actor is not relevant) actor\
      \ to be relevant NetUpdateFrequency times per second. This is useful when the\
      \ data changes frequently but you only want periodic updates. For example, PlayerReplicationInfo\
      \ contains a lot of data about the client. Stuff like the various player's pings\
      \ may change quite frequently, and having the client keep track of such information\
      \ would be quite a network hog. But since PlayerReplicationInfo has a NetUpdateFrequency\
      \ of 2, it is only updated twice a second, which is much nicer for that player's\
      \ bandwidth. The list of the current NetUpdateFrequency's for all UT classes\
      \ are listed below:</p>\n<table>\n<tr>\n<td>Actor</td>\n<td>100 Hz</td>\n</tr>\n\
      <tr>\n<td>ZoneInfo</td>\n<td>4 Hz</td>\n</tr>\n<tr>\n<td>GameReplicationInfo</td>\n\
      <td>4 Hz</td>\n</tr>\n<tr>\n<td>PlayerReplicationInfo</td>\n<td>2 Hz</td>\n\
      </tr>\n<tr>\n<td>Inventory</td>\n<td>8 Hz</td>\n</tr>\n</table>\n<h3><span class=\"\
      mw-headline\" id=\"Reliable_versus_Unreliable\">Reliable versus Unreliable</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=12\" title=\"Edit section:\
      \ Reliable versus Unreliable\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Another optimization used in networking is the difference\
      \ between Reliable and Unreliable data. In the case of variables, all data is\
      \ reliable. It is all guaranteed to reach the client, even if it arrives in\
      \ the wrong order. (Pawns however, have code that prevent them from appearing\
      \ jumpy, although the effects of this can still be seen at times when the player\
      \ bounces back and forth in a somewhat laggy game.....location updates are being\
      \ received out of order.) Functions however, exist in both reliable and unreliable\
      \ forms. A reliable function, like reliable data, is guaranteed to reach the\
      \ client. An unreliable function however, is sent to the client, but it is not\
      \ guaranteed of reaching the client. Something that sends messages to the client,\
      \ like BroadcastMessage or BroadcastLocalizedMessage, are reliable to ensure\
      \ that the client gets the message. Something like a client's update to the\
      \ server about its position need not be reliable, however. Since the client\
      \ sends these update requests to the server every single tick (in ServerMove,\
      \ if you're wondering), it does not matter if they all reach the server. And\
      \ since each update is timestamped, the server knows which ones to regard because\
      \ they are out of order or lagged. And so, the server can be assured of getting\
      \ updates from the client, while not requiring that they ALL be sent. A reliable\
      \ function is repeatedly sent over the network until the client acknowledges\
      \ it. This can lead to a one second delay or more if it has to try to send the\
      \ message once or twice. Since you don't want to bog down the network connection\
      \ with reliable updates about where the client is looking or moving, unreliable\
      \ is best in this situation since the server only needs to get \"most\" of them\
      \ to work great.</p>\n<h3><span class=\"mw-headline\" id=\"Writing_Replication_Statements\"\
      >Writing Replication Statements</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=13\"\
      \ title=\"Edit section: Writing Replication Statements\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>There are a few useful things\
      \ to know about when writing your own replication statements. First, you cannot\
      \ override replication statements. If a replication statement exists in a parent\
      \ in regards to Location, Velocity, some function, or another variable you want\
      \ to change the conditions for...you can't. Sorry. Instead, you have to mold\
      \ your actor into fitting the requirements so that it's property or function\
      \ will be replicated. Usually you can accomplish this by setting a variable\
      \ or two (you can't set the \"const\" ones which are set natively of course),\
      \ or by fiddling with the RemoteRole until it matches up. However, don't go\
      \ around doing that blindly, or you're sure never to succeed. Instead, keep\
      \ reading, and you will discover (hopefully, if I do it right&#160;:), exactly\
      \ what each of the Roles are for, and what side effects they cause. Next, keep\
      \ them simple. We already discussed the importance of not doing anything overly\
      \ complicated, and that rule should be adhered to. Second, use the bNet* variables\
      \ if possible. These variables, like bNetInitial, bNetOwner, bSimulatedPawn\
      \ are quite useful, and are gratis. There is no additional CPU requirement to\
      \ use these variables, as they are set for you automatically. Another very important\
      \ thing to hinge your variables on is the Role and RemoteRole. \"if (Role ==\
      \ ROLE_Authority)\" would cause that variable/function to be replicated from\
      \ the server (where the Role equals ROLE_Authority) to the client. Something\
      \ like: \"if (Role &lt; ROLE_Authority)\" would cause the variable to be replicated\
      \ from the client (where the Role is less powerful than ROLE_Authority) to the\
      \ server. Checks can also be performed to do various things depending upon if\
      \ the Role/RemoteRole is a SimulatedProxy or a DumbProxy. The best place to\
      \ find examples of these more intricate checks is in the Engine classes, particularly\
      \ Actor, Pawn, and PlayerPawn. It should also go without saying that you should\
      \ not change anything in a replication statement. Doing i++ in a replication\
      \ statement causes i to change unpredictably as it is being replicated, which\
      \ is not something you really want to do. And finally, as the last word advice,\
      \ the server checks all incoming data to be sure it is legitimate. If the client\
      \ replicates something (a variable or a function) to the server, the server\
      \ will exchange the Role and RemoteRole variables temporarily, and evaluate\
      \ the replication condition to see if the other end had a legitimate reason\
      \ for sending that data. If the check fails, then the data (variable or function\
      \ call) is discarded. That means that when you are writing replication statements,\
      \ make sure that the server also has all the data needed to perform the replication\
      \ check. Otherwise, it will never be processed or accepted by the server.</p>\n\
      <h2><span class=\"mw-headline\" id=\"Variable_Replication\">Variable Replication</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=14\" title=\"Edit section:\
      \ Variable Replication\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Variables are one type of data that can be sent through replication statements.\
      \ The other is function calls (RPC, if that helps). Here, we'll be discussing\
      \ how data is replicated from the server to the client, and vice versa. There's\
      \ a lot of little things that server to complicate it more than the replication\
      \ described above. As I already stated above, all variables are considered reliable,\
      \ so the unreliable versus reliable discussion is irrelevant here.</p>\n<h3><span\
      \ class=\"mw-headline\" id=\"Newly_Relevant_Actors_.28Spawning.29\">Newly Relevant\
      \ Actors (Spawning)</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=15\" title=\"\
      Edit section: Newly Relevant Actors (Spawning)\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>When an actor becomes relevant to a client, it is\
      \ spawned on the client, with all the defaultproperties of the actor. If the\
      \ server set variables immediately after the spawning of the actor, (before\
      \ the relevancy checks), then those variables will be sent to the client as\
      \ an 'addendum' of sorts, assuming those variables meet the replication statements.\
      \ The server will send any variables that differ from the defaultproperties.\
      \ Things can get hairy though, when the server has a different idea of an actor's\
      \ defaultproperties than the client does. Initially, the defaultproperties on\
      \ the server should match up with what the client has. If a defaultproperty\
      \ is changed on the server, that change is not replicated to the client. You\
      \ must change it in a simulated function in order for that to occur. However,\
      \ what happens if the actor becomes irrelevant? In that case, bad things happen.\
      \ When the actor becomes relevant again, the default spawned actor on the client\
      \ will have different defaultproperties from the server. When the server then\
      \ proceeds to perform the checks on what to replicate, it sees that the default\
      \ var is the same as that var, and so that var is not replicated. The client\
      \ then never gets data, and so has the REAL default variable, of a fresh actor.\
      \ That variable can be incorrect, and cause strange behavior to occur.</p>\n\
      <p>As an example, for a particular class-based mod, a programmer (not me, this\
      \ time&#160;;-) had set both the Mesh and Default.Mesh to the playerclass that\
      \ the player had chosen. Players however, go in and out of scope, to save on\
      \ network bandwidth. Normally they are only relevant when you can see them,\
      \ and for about three seconds once them disappear from view. Let's say the player\
      \ changed their playerclass at that point. Or say they changed their class at\
      \ the start of the game while the round has not started and they are invisible,\
      \ and thus not relevant. When they did become relevant to the client, because\
      \ they turned a corner, or because the round just started and they are spawned\
      \ and made visible, the Mesh == Default.Mesh, and so the Mesh is never replicated.\
      \ The skin however, was still replicated normally. To clients in the game, they\
      \ saw the player as the original mesh, with a inappropriate skin that was intended\
      \ for another model. Like I said, strange behavior, that can be hard to trace\
      \ down. The way to handle this, is to not set the Default variables unless you\
      \ are really know what you are doing. Just setting the Default.Mesh because\
      \ it feels right will only cause problems. In this case, the Default.Mesh was\
      \ not needed for everything, and removing that assignment caused everything\
      \ to work fine.</p>\n<h3><span class=\"mw-headline\" id=\"A_Time_for_Replication\"\
      >A Time for Replication</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=16\"\
      \ title=\"Edit section: A Time for Replication\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Replicated variables are only replicated at the end\
      \ of each tick. That means that if you change the variable repeatedly during\
      \ a loop, or some other block of code, only the final value will be replicated.\
      \ If you change a variable many times during a tick, and change it back to its\
      \ original value when the tick completes, then no variable change will have\
      \ been seen, and no network bandwidth will have been spent.</p>\n<h3><span class=\"\
      mw-headline\" id=\"Client-Server_Replication\">Client-Server Replication</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=17\" title=\"Edit section:\
      \ Client-Server Replication\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Another quirk to be aware of is that client-server\
      \ replication exists ONLY for your own playerpawn. That means that if you want\
      \ a variable replicated from the client to the server, it needs to be done in\
      \ your current PlayerPawn (or one of its parent classes). (You can use function\
      \ replication to get around this limitation however.) Other playerpawns in the\
      \ level are not the one that you currently 'possess', so their variables will\
      \ not be replicated to the server. Just be aware of that when trying to replicate\
      \ your variables and they aren't working.&#160;:) Thinking about it, it makes\
      \ sense. What right does the client have to send any information to the server\
      \ about another playerpawn, or some inventory item? The client is only concerned\
      \ with variable changes that the player himself (or herself) makes, and thus\
      \ those are the only ones that are sent to the server.</p>\n<h3><span class=\"\
      mw-headline\" id=\"Replication_Only_When_Necessary\">Replication Only When Necessary</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=18\" title=\"Edit section:\
      \ Replication Only When Necessary\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Further optimizations exist for variable replications\
      \ as well. A variable will only be replicated if the server thinks the client\
      \ has the incorrect version compared to the server's latest version. This usually\
      \ happens when the server changes a variable, and it knows the clients do not\
      \ know about such a change. (They would if the function that changed them was\
      \ simulated and was called clientside, meaning that you technically would not\
      \ need to replicate that variable. This is explained later..&#160;:) This means\
      \ your code can change stuff clientside, and it will not be written over by\
      \ server-side data until the server's data changes. As an example, I used this\
      \ technique to implement a simple little static LOD back in the Unreal days\
      \ before Epic introduced their realtime LOD. The client determined how far away\
      \ the player was, and switched in variously detailed models depending on the\
      \ distance. This allowed more models onscreen at once. And in multiplayer games,\
      \ the client could change the mesh to the various LOD meshes, and it would work\
      \ fine. Since the server never saw a change in the server's mesh (assuming it\
      \ was a dedicated server), the client could change the LOD mesh without any\
      \ problems. When the server did change the mesh however, the client would get\
      \ a new mesh variable sent to it, and so it would have to then change it again.\
      \ As a bragging aside, it even modified the intensity at which is applied LOD\
      \ depending upon the framerate.&#160;;)</p>\n<h3><span class=\"mw-headline\"\
      \ id=\"Replication_Data_Approximation\">Replication Data Approximation</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=19\" title=\"Edit section:\
      \ Replication Data Approximation\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Another optimization is that of how Unreal sends vectors,\
      \ rotators, and arrays across the internet. The rules for this can best be described\
      \ from the Unreal Tech page's Networking document, and I've copied it here to\
      \ keep it in context:</p>\n<ul>\n<li>Vectors and Rotators: To improve bandwidth\
      \ efficiency, Unreal reduces the accuracy of vectors and rotators slightly,\
      \ a process known as quantizing. The X, Y, Z components of vectors are converted\
      \ to 16-bit signed integers before being sent, thus any fractional values or\
      \ values out of the range -32768..32767 are lost. The Pitch, Yaw, Roll components\
      \ of vectors are converted to bytes, of the form (Pitch8)&amp;255. So, you need\
      \ to be careful with vectors and rotators. If you absolutely must have full\
      \ precision, then use int or float variables for the individual components;\
      \ all other data types are sent with their complete precision.</li>\n<li>General\
      \ structs are replicated by sending all of their components. A struct is sent\
      \ as an \"all or nothing\" type of thing.</li>\n<li>Arrays of variables can\
      \ be replicated, but only of the size of the array (in bytes) is less than 448\
      \ bytes.</li>\n<li>Arrays are replicated efficiently; if a single element of\
      \ a large array changes, only that element is sent.</li>\n</ul>\n<h2><span class=\"\
      mw-headline\" id=\"Variable_Replication_Examples\">Variable Replication Examples</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=20\" title=\"Edit section:\
      \ Variable Replication Examples\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Now would probably be a good time to go through some\
      \ important examples of replication and how it is used with variables, to give\
      \ you a better idea of how things work, and to help give examples for your own\
      \ adventures in coding.</p>\n<p>Let's take a few examples, and describe exactly\
      \ what they do. We'll start off with the easy ones, and gradually work our way\
      \ up in complexity. The following examples are all taken from Actor, unless\
      \ specified otherwise.</p>\n<p>In PlayerPawn:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">reliable</span> <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> <span class=\"kw7\">Role</span> <span class=\"\
      sy0\">&lt;</span> <span class=\"kw7\">ROLE_Authority</span> <span class=\"br0\"\
      >)</span>\n\t\tPassword, bReadyToPlay;</pre></div>\n</div>\n<p>This here shows\
      \ where your Password is sent to the server, when trying to join passworded\
      \ servers, or to log in as an admin to that server. The server needs your password\
      \ in order to validate it, and this code sends it to the server. Let's evaluate\
      \ this check both on the server and on the client. Server: On the server, Role\
      \ == ROLE_Authority. Looking at the conditional, it can easily be shown to be\
      \ false, and so the Password is not replicated server-side. This means that\
      \ the server does not send the Password to the other end of the connection.\
      \ Client: Since on the client, the Role is not ROLE_Authority (remember it's\
      \ only Authority on the server itself), this replication check evaluations to\
      \ true on the client. And since variable replication only works in your current\
      \ PlayerPawn, it will be sent to the server for yourself alone. (It makes sense\
      \ not to send others' passwords, doesn't it?&#160;;)</p>\n<p>This also shows\
      \ how bReadyToPlay, which is used in Tournament style games, where everyone\
      \ has to click to start the game. Note that this is only sent for yourself,\
      \ since the client can only replicate variables to the server if they are part\
      \ of it's own playerpawn actor.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">unreliable</span> <span class=\"kw2\">if</span><span class=\"\
      br0\">(</span> <span class=\"kw7\">Role</span> <span class=\"sy0\">==</span>\
      \ <span class=\"kw7\">ROLE_Authority</span> <span class=\"br0\">)</span>\n\t\
      \t<span class=\"kw7\">Owner</span>, <span class=\"kw7\">Role</span>, <span class=\"\
      kw7\">RemoteRole</span>;</pre></div>\n</div>\n<p>This ensures that the owner\
      \ of an object is always replicated to the client. Remember that the owner's\
      \ variables themselves are not replicated, (because there is no recursive replication,)\
      \ but the actor itself is. This means that simple comparisons \"if (PlayerPawn\
      \ == Owner)\" will work fine because the reference to the Owner is replicated\
      \ to the client. Remember that the unreliable versus reliable makes no difference\
      \ in UT, as they are both treated equivilently. They may have had an effect\
      \ at sone point during the Unreal 1 days, but they no longer play a factor in\
      \ development. Don't let that confuse you.</p>\n<p>Replicating Role and RemoteRole\
      \ may seem strange at first, since they should be reversed on the client. However,\
      \ there's native code that causes that switch to be made. On the client, it\
      \ will ensure that those two variables are reversed, so that RemoteRole is ROLE_Authority.\
      \ You may wonder why they are even replicated in the first place. While the\
      \ client never has any direct use for these variables in the code, there is\
      \ one easy-to-overlook place where they are vitally important: Replication Statements.\
      \ When the client is evaluating whether it needs to replicate a certain function\
      \ call to the server, or a playerpawn's variable to the server, the client needs\
      \ accurate copies of what Role and RemoteRole are. Without those, it would be\
      \ unable to make the necessary decisions on what to send to the server. And\
      \ since the server checks the validity of the replication data sent to the server\
      \ with Role/RemoteRole, the client needs the latest copy in order to successfully\
      \ replicate that data.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">unreliable</span> <span class=\"kw2\">if</span><span class=\"br0\">(</span>\
      \ bNetOwner <span class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\">Role</span>\
      \ <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span> <span\
      \ class=\"br0\">)</span>\n\t\tbNetOwner, <span class=\"kw9\">Inventory</span>;</pre></div>\n\
      </div>\n<p>Inventory is the head of the linked list that lists the entire Inventory\
      \ for the Actor (usually only utilized with Pawn and PlayerPawn). We want the\
      \ inventory to be replicated to the client, so that he knows what Inventory\
      \ he has, to display on his HUD, and stuff (makes sense, right?). Simply replicating\
      \ the head of a linked list (where each object points to the next in the list)\
      \ is not enough however. Each actor must itself be relevant (satisfied by the\
      \ criterion that it must be owned by the current playerpawn), and each link\
      \ itself must be replicated. And since Inventory subclass Actor somewhere in\
      \ the chain, Inventory also has a replicated Inventory variable. And that's\
      \ how you are able to see your Inventory client-side. And since I don't need\
      \ to know the full Inventory list of what every other player in the game has\
      \ (the current weapon and the shieldbelt effect are transferred via other means),\
      \ the Inventory will only be replicated if the client is the owner.</p>\n<p>The\
      \ other variable in the above replication statement is bNetOwner. Since this\
      \ is set natively on both the client and server, this variable does not need\
      \ to be replicated. It could be argued that it adds a tiny amount to bandwidth,\
      \ but its effect is probably negligible. Perhaps it will be removed in a future\
      \ patch.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n\
      <div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\"\
      >unreliable</span> <span class=\"kw2\">if</span><span class=\"br0\">(</span>\
      \ <span class=\"kw7\">DrawType</span> <span class=\"sy0\">==</span> <span class=\"\
      kw7\">DT_Mesh</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\"\
      >Role</span> <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span>\
      \ <span class=\"br0\">)</span>\n\t\t<span class=\"kw5\">Mesh</span>, PrePivot,\
      \ bMeshEnviroMap, Skin, MultiSkins, Fatness, AmbientGlow, ScaleGlow, bUnlit;</pre></div>\n\
      </div>\n<p>Here we see that all these mesh-specific variables are ONLY replicated\
      \ if this actor is currently being displayed as a mesh. If it's a sprite, or\
      \ a brush, or even no drawtype at all, there is no reason to send these variables.</p>\n\
      <p>Now let's get into some of the more complex variable replication statements...</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">unreliable</span>\
      \ <span class=\"kw2\">if</span><span class=\"br0\">(</span> <span class=\"kw7\"\
      >RemoteRole</span> <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_SimulatedProxy</span>\
      \ <span class=\"br0\">)</span>\n\t\t<span class=\"kw7\">Base</span>;</pre></div>\n\
      </div>\n<p>Here we see a slightly more complex replication statement, that does\
      \ not involve Role == ROLE_Authority. Here we see that the current Base (set\
      \ via SetBase) is only replicated if the actor is set to be a simulated proxy.\
      \ If you set the actor to a DumbProxy, you'll see no Base change clientside,\
      \ and instead will get the jerky Location updates that the server sends to you,\
      \ (more on this later). So if you are using SetBase, make sure it's a SimulatedProxy,\
      \ or if it's not a SimulatedProxy, use something other than SetBase.&#160;:)\
      \ Or if you need both SetBase and a SimulatedProxy, the Base will not be replicated\
      \ for you. You'll have to work out some other mechanism to do that, probably\
      \ a simulated function that sets the base, so it is run on the client, (more\
      \ on this later, too.) You might still have troubles when the actor gets its\
      \ simulated function called while the actor was not relevant. This results in\
      \ the simulated function never being called clientside, and then when the actor\
      \ does finally become relevant, it's as if that function was never called (and\
      \ the base isn't set), which will result in those things affectionately referred\
      \ to as 'bugs.' You can make the actor being attached (and what it's being attached\
      \ to) bAlwaysRelevant so that the simulated functions will always be called,\
      \ but that might be a bit too harsh on network bandwidth.&#160;:)</p>\n<div\
      \ dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">unreliable</span>\
      \ <span class=\"kw2\">if</span><span class=\"br0\">(</span> <span class=\"kw7\"\
      >RemoteRole</span> <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_SimulatedProxy</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\">Physics</span> <span\
      \ class=\"sy0\">==</span> <span class=\"kw7\">PHYS_Rotating</span> <span class=\"\
      sy0\">&amp;&amp;</span> bNetInitial <span class=\"br0\">)</span>\n\t\tbFixedRotationDir,\
      \ bRotateToDesired, <span class=\"kw7\">RotationRate</span>, <span class=\"\
      kw7\">DesiredRotation</span>;</pre></div>\n</div>\n<p>This one is still relatively\
      \ easy, but it's getting more complex. Here we have similar logic to what was\
      \ seen above, with the server only sending these variables to the client if\
      \ the client is a SimulatedProxy. However, since all these variables apply ONLY\
      \ to PHYS_Rotating, there is no need to replicate these variables to the client\
      \ if the client is not using PHYS_Rotating. And finally, a very important clause\
      \ at the end is the bNetInitial one. This states that these variables will only\
      \ be replicated to the client when it is being replicated for the first time.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">unreliable</span>\
      \ <span class=\"kw2\">if</span><span class=\"br0\">(</span> bSimFall <span class=\"\
      sy0\">||</span> <span class=\"br0\">(</span><span class=\"kw7\">RemoteRole</span>\
      \ <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_SimulatedProxy</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> bNetInitial <span class=\"sy0\">&amp;&amp;</span>\
      \ <span class=\"sy0\">!</span>bSimulatedPawn<span class=\"br0\">)</span> <span\
      \ class=\"br0\">)</span>\n\t\t<span class=\"kw7\">Physics</span>, <span class=\"\
      kw7\">Acceleration</span>, bBounce;</pre></div>\n</div>\n<p>Here we have some\
      \ of the interesting variables replicated. We see that if the bSimFall is set\
      \ to true, it will replicate the Physics to the client. This is used when tossing\
      \ weapons from your inventory. When they are tossed, they require a Physics\
      \ change from PHYS_None while sitting in your Inventory to PHYS_Falling as they\
      \ fly through the air. The then get set back to PHYS_None when they land on\
      \ the ground. All these Physics changes are accomplished by setting bSimFall\
      \ at the key points during the TournamentWeapon's life. It is set to true when\
      \ it is thrown from the inventory, to capture the change, and left on until\
      \ it hits the ground, where it changes Physics again. After it finally hits\
      \ and has its physics reset, bSimFall is set to false so no further Physics\
      \ changes occur. Looking at the second half of the statement, we see that the\
      \ Physics is replicated ONLY if it's a SimulatedProxy, it's the first time this\
      \ actor is being replicated over the internet, AND it's not a simulated pawn.\
      \ The bSimulatedPawn variable is set to true if it's a Pawn with a RemoteRole\
      \ of ROLE_SimulatedProxy (who would have thought?&#160;:) This means any changes\
      \ to the Physics of a SimulatedProxy non-pawn actor before it is replicated\
      \ will be replicated to the client. The Physics are never replicated for pawns.\
      \ Rather, the code for their physics is hard-wired into the code to cause them\
      \ to be pushed to the ground. Basically, when a pawn jumps, the server sets\
      \ his vertical velocity so that he travels upwards. That Velocity is then replicated\
      \ to the client (described below). The client then checks if the pawn is a player\
      \ (eg: a bot or a playerpawn), that they are currently unable to fly (set via\
      \ the Pawn's bCanFly variable), and that they are not in a water zone (since\
      \ that involves different gravities and physics). So in fact, the Physics for\
      \ a pawn is never replicated to the client, it only appears to do so. If you\
      \ are attempting to create alternate physics with the playerpawn, you will need\
      \ to ensure that you set bCanFly to true so that the native code does not enforce\
      \ the falling Physics upon the player when he's on the wall or in the air. You\
      \ must then implement the alternate means of transportation yourself.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">unreliable</span>\
      \ <span class=\"kw2\">if</span><span class=\"br0\">(</span> <span class=\"sy0\"\
      >!</span>bCarriedItem <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\"\
      >(</span>bNetInitial <span class=\"sy0\">||</span> bSimulatedPawn <span class=\"\
      sy0\">||</span> <span class=\"kw7\">RemoteRole</span> <span class=\"sy0\">&lt;</span>\
      \ <span class=\"kw7\">ROLE_SimulatedProxy</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\">Role</span> <span\
      \ class=\"sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span> <span class=\"\
      br0\">)</span>\n\t\t<span class=\"kw7\">Location</span>;</pre></div>\n</div>\n\
      <p>Here we see another important variable, Location, and it's replication. We\
      \ see that it is not replicated for carried items. This is useful in the case\
      \ of Inventory. When a player is carrying it, there's no reason its location\
      \ should be replicated, since it isn't used for anything. replicating a player's\
      \ entire inventory would be quite the strain on network bandwidth. Let's look\
      \ at the next section of the statement. The location is replicated if this is\
      \ the first time the actor is being replicated (assuming the other parts of\
      \ the conditional are true). This is very useful, since all pawns will be spawned\
      \ in different locations when you enter the game, and rockets will need their\
      \ start locations set when they spawn out of a rocket launcher, etc. The location\
      \ is also sent if this is a bSimulatedPawn. This helps correct any errors that\
      \ may occur in replicating pawns. Since a pawn can change direction, and a client\
      \ may not always know about it (due to lag, etc), this location resetting is\
      \ the only way in which the locational updates can be 'corrected'. Note that\
      \ this is not used to correct your own location when you experience lag. When\
      \ that happens, you are an AutonomousProxy, and functions specific to PlayerPawn\
      \ handle that (namely ClientAdjustPosition). For example, PHYS_Walking is not\
      \ like PHYS_Projectile, where the position can be predicted with great accuracy.\
      \ PHYS_Walking just means \"keep them attached to the ground\", basically, The\
      \ client's only updates (without location) would have been their velocity, which\
      \ can easily lead to errors in the player's movements over any significant amount\
      \ of time. This location is used as a correcting factor, making sure the client's\
      \ view does not straw too far from where he expects the player to be, while\
      \ at the same time keeping the velocity's replication so he can be predicted\
      \ inbetween server updates. The other option for allowing the Location to replicate\
      \ is that of where the RemoteRole is less than a ROLE_SimulatedProxy, namely,\
      \ a ROLE_DumbProxy, since the ROLE_None prevents relevancy in the first place.\
      \ DumbProxies get periodic updates from the server every few ticks, and would\
      \ create a jumpy effect in netplay. It was the cause of a jerky puck in the\
      \ hockey mod I attempted awhile ago, although I knew nowhere near enough to\
      \ fix it at the time.&#160;:) A SimulatedProxy would not get sent Location updates,\
      \ since it would be predicted through the use of the Velocity and the current\
      \ Physics. Since DumbProxies aren't simulated client-side to achieve smoothness,\
      \ they only get the Location updates. I'm going to clear this all up after the\
      \ examples of the various replicated variables.</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">unreliable</span> <span class=\"kw2\"\
      >if</span><span class=\"br0\">(</span> <span class=\"sy0\">!</span>bCarriedItem\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span><span class=\"\
      kw7\">DrawType</span> <span class=\"sy0\">==</span> <span class=\"kw7\">DT_Mesh</span>\
      \ <span class=\"sy0\">||</span> <span class=\"kw7\">DrawType</span> <span class=\"\
      sy0\">==</span> <span class=\"kw7\">DT_Brush</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span>bNetInitial\
      \ <span class=\"sy0\">||</span> bSimulatedPawn <span class=\"sy0\">||</span>\
      \ <span class=\"kw7\">RemoteRole</span> <span class=\"sy0\">&lt;</span> <span\
      \ class=\"kw7\">ROLE_SimulatedProxy</span><span class=\"br0\">)</span> <span\
      \ class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\">Role</span> <span class=\"\
      sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span> <span class=\"br0\"\
      >)</span>\n\t\t<span class=\"kw7\">Rotation</span>;</pre></div>\n</div>\n<p>Here\
      \ we see another important variable, Rotation. This also has the same&#160;!bCarriedItem\
      \ clause, for the same reasons as described above. The rotation is also only\
      \ replicated if this actor is a mesh or a brush. Since sprites always face the\
      \ player, replicating their rotation is useless. The bNetInitial also causes\
      \ the rotation to be replicated the first time through, (again, assuming if\
      \ the other conditions are true,) since rockets need to be facing in the right\
      \ direction when it has them flying through the air. Their velocity determines\
      \ their direction of movement, but the direction they are facing which is equally\
      \ important, is determined by their rotation. The rotation is replicated if\
      \ they are a simulated pawn (every playerpawn and bot in the level except your\
      \ own self). This is so you can see what direction the other people are facing.\
      \ The ViewRotation (which determines where the client is looking), is sent to\
      \ the server via ServerMove, where it is translated into a rotation. it is this\
      \ rotation that is then replicated to the clients. And finally, if it is a DumbProxy\
      \ (the only valid one less than SimulatedProxy), it also gets the rotation updates.\
      \ Rotation updates do not need any interpolating between updates like location\
      \ does. Location lag is much more noticeable when the player is moving quickly,\
      \ but you never really notice Rotation lag. Besides, there is no real way to\
      \ predict or forecast rotation. It depends entirely upon the other user's mouse.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">unreliable</span>\
      \ <span class=\"kw2\">if</span><span class=\"br0\">(</span> bSimFall <span class=\"\
      sy0\">||</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span\
      \ class=\"kw7\">RemoteRole</span> <span class=\"sy0\">==</span> <span class=\"\
      kw7\">ROLE_SimulatedProxy</span> <span class=\"sy0\">&amp;&amp;</span> <span\
      \ class=\"br0\">(</span>bNetInitial <span class=\"sy0\">||</span> bSimulatedPawn<span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">||</span>\
      \ bIsMover<span class=\"br0\">)</span> <span class=\"br0\">)</span>\n\t\t<span\
      \ class=\"kw7\">Velocity</span>;</pre></div>\n</div>\n<p>Here's one of the last\
      \ important variables with a complex replication statement. The velocity is\
      \ replicated if it has bSimFall set, (used when throwing weapons from your inventory).\
      \ The PHYS_Falling alone isn't enough. It needs to know exactly what it's initial\
      \ velocity is when it is launched from the pawn. And no, bNetInitial will not\
      \ work here, since it's not the first time it's being replicated. It's existed\
      \ as a weapon for quite some time. It's just for the initial velocity of when\
      \ it's being thrown from the player that we want updates. Moving along, we see\
      \ that SimulatedProxies get their Velocities replicated if it the first time\
      \ on the replication channel, for newly spawned rockets, or for grenades, or\
      \ shock projectiles, etc. SimulatedProxies also get their velocities replicated\
      \ if they are a simulated pawn, as all the various pawns need their velocities\
      \ replicated so that they can be predicated locally. And finally, movers get\
      \ their velocities replicated, so that the client can accurately predict the\
      \ mover's movement locally. In the early Unreal 1 days, mover's velocity was\
      \ not replicated, and so the client got periodic update locations because it\
      \ was a DumbProxy. This resulted in very jumpy movers in netplay, something\
      \ that was fixed for Unreal 224+.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">unreliable</span> <span class=\"kw2\">if</span><span class=\"\
      br0\">(</span> <span class=\"kw7\">DrawType</span> <span class=\"sy0\">==</span>\
      \ <span class=\"kw7\">DT_Mesh</span> <span class=\"sy0\">&amp;&amp;</span> <span\
      \ class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw7\">RemoteRole</span>\
      \ <span class=\"sy0\">&lt;=</span> <span class=\"kw7\">ROLE_SimulatedProxy</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span><span class=\"\
      sy0\">!</span>bNetOwner <span class=\"sy0\">||</span> <span class=\"sy0\">!</span>bClientAnim<span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">||</span>\
      \ bDemoRecording<span class=\"br0\">)</span> <span class=\"br0\">)</span>\n\t\
      \tAnimSequence, SimAnim, AnimMinRate, bAnimNotify;</pre></div>\n</div>\n<p>There\
      \ are a few more variables here, all of which relate to animation. These variables\
      \ are only replicated if it is currently being drawn as a Mesh. If we are recording\
      \ a demo, then the animations are always sent. Otherwise, it checks the somewhat\
      \ confusing conditional. If the actor is a DumbProxy, and the player is not\
      \ the owner of this object, and bClientAnim is not set, then it replicates the\
      \ animation variables. In the case of weapons, you see those animations clientside,\
      \ and so the animation variables do not need to be replicated from the server.\
      \ That is because all TournamentWeapons have the bClientAnim set to true, indicating\
      \ that their animations are handled clientside. If the animations are not handled\
      \ clientside, and the actor is a dumb proxy, then it will send them from the\
      \ server. SimulatedProxies, which include pawns and rockets and other projectiles,\
      \ are all simulated proxies, and so they do not receive animations from the\
      \ server. Instead, the client animates them with its client-side prediction.\
      \ In the case of pawns, this is handled internally in the engine (for another\
      \ tutorial&#160;;), and you need not worry about it.</p>\n<h2><span class=\"\
      mw-headline\" id=\"Role_and_RemoteRole_Summary\">Role and RemoteRole Summary</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=21\" title=\"Edit section:\
      \ Role and RemoteRole Summary\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Hopefully this intricate look into some of the more\
      \ complex and confusing variables has helped you to grasp the concepts of replication\
      \ some more, and realize many of the differences between the various roles.\
      \ However, with the above knowledge in mind, I'd like to do a little re-cap,\
      \ emphasizing the use of dumb, simulated, and autonomous proxies, and help give\
      \ you a clearer idea of when each should be used.</p>\n<dl>\n<dt>ROLE_Authority</dt>\n\
      <dd>Again, this is the Role for all actors on the server, and is the RemoteRole\
      \ for all actors on the client. It basically means that I'm the authority on\
      \ this actor. This is the only one variable that Role is set to, server-side.\
      \ The remaining ones are all used for the RemoteRole when on the server.</dd>\n\
      <dt>ROLE_None</dt>\n<dd>This basically says: Never make this actor relevant.\
      \ This prevents replication conditions from even being run, and so does not\
      \ factor into any of the replication statements.</dd>\n<dt>ROLE_DumbProxy</dt>\n\
      <dd>This role is used for simple actors that require no real client-side prediction.\
      \ They don't need any Physics prediction, but they only need to be relevant\
      \ to the client to get their variables replicated. This is used for all Inventory\
      \ actors when they reside on the ground, which prevents any higher-bandwidth\
      \ SimulatedProxy stuff, but yet allows you to see all the stuff you need for\
      \ the inventory actor. If you do try to move this actor, the client will get\
      \ periodic updates, usually around every half-second or so on a regular connection.\
      \ This creates quite a jumpy effect if you are using DumbProxy with a particular\
      \ Physics type, since it really isn't intended for that. Rather, the Location\
      \ updates are useful for when moving the actor across the level with a flag\
      \ respawn, etc. The same is done with rotation updates, with periodic changes\
      \ coming in to the client every so often. This role also causes animation updates\
      \ to be sent from the server to the client, unless the client specifically tells\
      \ it not to. In summary, an actor with this role is force-fed data from the\
      \ server. It's intended for actor's that don't move (except in jumps like transportation,\
      \ respawn, etc), yet are still relevant.</dd>\n<dd><b>Other quirks</b>: There's\
      \ a few quirks that can have a significant effect on your netplay development.\
      \ DumbProxy actors do not have a variety of events run clientside. Simulated\
      \ Tick(), Timer(), and state code, along with the physics calculations, are\
      \ not performed on the client of a DumbProxy actor. They are supposed to be\
      \ a dumb proxy actor that gets data sent over the net, and so these events are\
      \ not called. One exception to the above rule is that physics are performed\
      \ clientside for DumbProxy actors if the actor has a falling physics, which\
      \ allows tossed weapons to fall correctly in netplay. In an early attempt at\
      \ the weapon in the tutorial at the bottom of this document, I attempted to\
      \ create a client-side physics that would combine with the location and rotation\
      \ updates that were inherently sent via the DumbProxy role, but the client would\
      \ not run my Tick()-based physics calculations, and so that idea had to be thrown\
      \ out the window.&#160;:)</dd>\n<dt>ROLE_AutonomousProxy</dt>\n<dd>This is used\
      \ for things that the client directly controls. In most cases, this will only\
      \ be used by the playerpawn. This RemoteRole value should only be set for the\
      \ one particular player, and it should be a SimulatedProxy for every other client\
      \ in the game. The player for which it is AutonomousProxy is the player possessing\
      \ that particular PlayerPawn. When it is set to AutonomousProxy, it appears\
      \ to be a SimulatedProxy for everyone BUT the owner of the proxy or the instigator.\
      \ This ensures that your PlayerPawn looks like a SimulatedProxy to everyone\
      \ but yourself. Note that this technique is also used with the guided redeemer,\
      \ to ensure that it works the same way. Having the server tell you where your\
      \ guided redeemer is flying would not be appropriate. Rather, you want to tell\
      \ the server where your guided redeemer is. While AutonomousProxy doesn't make\
      \ this just 'work' for you, it does differentiate you from the other people\
      \ viewing your redeemer, which is what is needed to have it act differently\
      \ for you, compared to everyone else.</dd>\n<dt>ROLE_SimulatedProxy</dt>\n<dd>There\
      \ are two different things that can happen with this particular type. It depends\
      \ on whether the actor with this role is a pawn or not a pawn. I'll discuss\
      \ the latter first.</dd>\n<dt>Non-Pawn ROLE_SimulatedProxy</dt>\n<dd>This one\
      \ is basically the opposite of DumbProxy. It expects full client-side prediction\
      \ of the actor, given initial values. It's like extrapolating out a curve given\
      \ some data, where the current Physics is the curve fit, and you have initial\
      \ data available to extrapolate from. ROLE_SimulatedProxy gives you an initial\
      \ Location, Rotation, and Physics. It then keeps you updated with the Velocities,\
      \ should they change. These variables should enable the client to perform full\
      \ client-side prediction on this object, assuming it continues along the physics\
      \ prediction. In the case of PHYS_Falling and PHYS_Projectile, this is the case.\
      \ There can be no aberration form these behaviors, (unless you play around with\
      \ the Physics variables bBounce and such, which are very useful in prediction.)\
      \ Perhaps I'll explain Physics in more detail in another tutorial. Perhaps.&#160;;)\
      \ Finally, for this role, you also get animation updates, assuming the client\
      \ is not the owner and it's not set for client-side animation. In summary, this\
      \ Role is for actors that smoothly predict their data on the client.</dd>\n\
      <dt>Pawn ROLE_SimulatedProxy</dt>\n<dd>When ROLE_SimulatedProxy is combined\
      \ with Pawns, a different sort of simulated proxy is created, that act differently\
      \ in netplay. Pawns are one of the most complex actors in terms of replication,\
      \ because of their need for clientside prediction, yet inherent unpredictability\
      \ in their movement. There is no way to duplicate this behavior except by subclassing\
      \ pawn, so don't expect to achieve it in your projectile subclass. A SimulatedPawn\
      \ gets the best of dumbproxy and simulatedproxy. It gets velocity updates for\
      \ the clientside prediction, while at the same time getting location updates\
      \ from the server to 'readjust' the player's locations. You might then wonder\
      \ why the pawn does not jump when a new location update comes in. Again, there\
      \ is native code that causes the actor to smoothly head towards the location\
      \ given by the server if the location position is too far off from the player's\
      \ real position. This again ensures seamless movement of players while keeping\
      \ them accurate to the server's version. All non-players will get by with velocity-only\
      \ client-side prediction. No physics will be taken into account for these pawns.\
      \ This is because some non-players can be PHYS_spider, or a variety of other\
      \ physics that don't work with the following always-walking/falling prediction.\
      \ Only players (bots and playerpawns) get the special client-side prediction\
      \ to have falling/walking physics. This physics is an assumed physics, which\
      \ is accomplished by applying the zone's gravity if the player is not on the\
      \ ground. This logic will be bypassed if the pawn's bCanFly variable is set,\
      \ which frees it of the clientside physics, but must be accounted for in your\
      \ code, since there is no physics replication in pawns. This logic is also bypassed\
      \ if the pawn is in a water zone, which also differs from the default walking/falling\
      \ physics. In water zones, actors are predicted using velocity alone, which\
      \ is sufficient with the low amount of gravity that exists in those zones. The\
      \ actor's get their locations 'adjusted' anyway, so it doesn't make any real\
      \ difference in the long run. Finally, pawns get rotation updates. Since rotation\
      \ (which is directly based off the ViewRotation, or the direction the player\
      \ is looking) can change quite radically, no prediction is done with it. Instead,\
      \ the player's rotation is adjusted as new player rotation information comes\
      \ in from the client. Animation is handled the same as any other non-pawn simulated\
      \ proxy.</dd>\n</dl>\n<h2><span class=\"mw-headline\" id=\"Function_Replication.2C_and_Simulation\"\
      >Function Replication, and Simulation</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=22\"\
      \ title=\"Edit section: Function Replication, and Simulation\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>In a network game,\
      \ functions can be called on the server, on the client, or on both. Sometimes\
      \ you will want one situation, and sometimes you will want another. Function\
      \ replication and simulation both achieve different pieces of these goals. Despite\
      \ what may at first seem like two different topics of discussion altogether,\
      \ they are actually quite related at their root. I will discuss them together,\
      \ and then finish with a clarification of their differences so that each can\
      \ be understood clearly.</p>\n<p>Internally, the Unreal Engine uses a very simple\
      \ system for its function stuff. It calls a function to determine if it can\
      \ call an UnrealScript function on that machine. if it can, it does, if it cannot,\
      \ then it does not. That's all that simulation and replication entails, and\
      \ the only additions to this system are the origin of UnrealScript simulation,\
      \ events, (which will be discussed later), and the function replication itself\
      \ (much of which you know already.)</p>\n<h3><span class=\"mw-headline\" id=\"\
      Rep.2FSim_Function_Rules\">Rep/Sim Function Rules</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=23\"\
      \ title=\"Edit section: Rep/Sim Function Rules\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>I will first present the basic simple rules to determine\
      \ if a client or server is able to execute the function locally. The following\
      \ conditions will determine whether that happens. Again, if a condition matches,\
      \ then the checking stops there, and it executes locally depending upon the\
      \ resulting clause of that condition.</p>\n<ol>\n<li>If it is a static function,\
      \ it can be called on that machine.</li>\n<li>If we're on a standalone server,\
      \ it can be called on that machine.</li>\n<li>If it's not a replicated function,\
      \ then go to step 10.</li>\n</ol>\n<p>(The rest apply ONLY to replicated functions,\
      \ per condition three.)</p>\n<ol start=\"4\">\n<li>If we are the server, and\
      \ there is no parent PlayerPawn to this actor, (at any point in the parent hierarchy,)\
      \ or if the player does not have a connection (listen servers for the player\
      \ on the server,) then it is executed locally.</li>\n<li>If the replication\
      \ condition is not met for the current machine, (meaning that it was replicated\
      \ to us, or that it is not a valid replication statement), then go to step 10.</li>\n\
      </ol>\n<p>(The rest apply ONLY to replicated functions where the replication\
      \ condition is met, and it is a valid function to replicate.)</p>\n<ol start=\"\
      6\">\n<li>If it is an unreliable function, and the connection (server-client\
      \ or client-server) is saturated, then 'pretend' it was executed remotely, (eg:\
      \ do not execute it locally.)</li>\n<li>Replicate the function, and then do\
      \ not execute it locally.</li>\n</ol>\n<p>This last step is only used if it\
      \ is called upon by the above steps.</p>\n<div style=\"list-style-type: latin;\
      \ margin-left: 2em\">\n<ol style=\"list-style-type: lower-roman;\">\n<li>If\
      \ we are on the server, then it can be called.</li>\n<li>If we are on the client\
      \ as an AutonomousProxy, it can be called locally.</li>\n<li>If we are on the\
      \ client as a DumbProxy or SimulatedProxy (NOT an AutonomousProxy,) and we are\
      \ a simulated function, then it can be called locally.</li>\n</ol>\n</div>\n\
      <p>While this may seem complex, it accurately describes in every detail how\
      \ Unreal does it's function handling, and RPC (remote procedure call) nature.\
      \ Hopefully, in the next paragraph or two, I'll be able to simplify it into\
      \ a few simple rules.</p>\n<h3><span class=\"mw-headline\" id=\"Rep.2FSim_Function_Rules_Restatement\"\
      >Rep/Sim Function Rules Restatement</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=24\"\
      \ title=\"Edit section: Rep/Sim Function Rules Restatement\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>In order for a function to\
      \ be replicated to the other end of the connection, it must be all of the following:</p>\n\
      <ol>\n<li>Owned by a network PlayerPawn at some point it it's parent hierarchy.</li>\n\
      <li>It must be a reliable function, or an unreliable function with available\
      \ bandwidth.</li>\n</ol>\n<p>In order for that replicated function to actually\
      \ be executed on the other end of the machine, it must pass rule number 10.\
      \ Additionally, if we are on the client, it must meet any of the following rules.</p>\n\
      <ol>\n<li>A static function.</li>\n<li>A simulated function.</li>\n<li>In an\
      \ actor with an AutonomousProxy Role (a local PlayerPawn or local GuidedWarhead\
      \ on the client.)</li>\n</ol>\n<p>The above rules need to be passed for ANY\
      \ function that is executed on the client, whether it is through simulation\
      \ or replication.</p>\n<h3><span class=\"mw-headline\" id=\"Rep.2FSim_Function_Summary\"\
      >Rep/Sim Function Summary</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=25\"\
      \ title=\"Edit section: Rep/Sim Function Summary\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>With those rules in mind, I'll try to summarize the\
      \ whole situation below.</p>\n<p>On a server, every function is executed, unless\
      \ it is a (client-server) replicated function and meets the checks above. So\
      \ you can be assured of all your functions running on the server, unless you\
      \ specifically tell them not to.</p>\n<p>On the client, every function has to\
      \ originate from a 'source.' A source can be a server-client replicated function,\
      \ an exec function, or an event. Events, while not covered previously, are quite\
      \ simple. An event is any function that is called from native code. Events happen\
      \ both on the server and on the client. The server does not directly tell the\
      \ client to execute the event, but the client knows to execute the event based\
      \ upon the game state (colliding actors, hitting a wall, a timer event, ticking\
      \ of the game state, etc). If that event is simulated, then it can also serve\
      \ as a 'source' of clientside function calls. A source can call any function\
      \ it wishes, assuming it meets the client-side execution conditions, which can\
      \ then call any...and so on.</p>\n<p>What happens if a function is called, but\
      \ doesn't meet the conditions for execution, either because it was replicated\
      \ to the other end, or because it does not meet the conditions for running client-side.\
      \ In that case, it is as if the function never ran in the first place. The return\
      \ value of such a function is 0, \"\", or None, depending upon the context.\
      \ Any out parameters defined by the function are passed back exactly as they\
      \ were entered. Relying on the result of a function that is never executed is\
      \ the source of many accessed nones that appear only on the client. Exec functions\
      \ (functions that can be bound to keystrokes) naturally evaluate on the client.\
      \ Again, remember to make it simulated, (unless you are in an AutonomousProxy,\
      \ like a PlayerPawn subclass.) In some cases, you may want to have it replicated\
      \ to the server, as in the case of a Server-Administrator command (there are\
      \ plenty of these defined in PlayerPawn.) Exec functions can be replicated to\
      \ the server, the same as any other function can.</p>\n<h3><span class=\"mw-headline\"\
      \ id=\"Spawning_Within_Simulated_Functions\">Spawning Within Simulated Functions</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=26\" title=\"Edit section:\
      \ Spawning Within Simulated Functions\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>There are other interesting hidden behaviors that\
      \ may not be immediately apparent. For example, because of the requirements\
      \ that an actor be owned by a playerpawn at some point in its parent hierarchy,\
      \ a function can only be replicated to a single player in the game. (No, making\
      \ a player owned by another player will not work.&#160;;) Multicast function\
      \ replication does not exist. You can try to get this behavior using simulated\
      \ functions, but no data can be passed between the server and the client, (since\
      \ they both originate on their local machine, and exist only on that local machine.)\
      \ Or you can use replicated variables, which can and are replicated to all players\
      \ in the game, assuming they are relevant to them.</p>\n<p>If a spawn is performed\
      \ in a simulated function (simulated functions are explained later), then multiple\
      \ copies of the actor are spawned: the server, and each of the clients that\
      \ the simulated function was run on. The server's version is normally then replicated\
      \ to the client, so the client would see two versions. This would create strange\
      \ behavior as the two became out of sync, and the client-spawned one could easily\
      \ be mistaken for the 'official one' that for some reason, isn't having it's\
      \ variables replicated.</p>\n<p>If you need to do a spawn in simulated code\
      \ (there are many valid reasons, like spawning effects clientside, etc), then\
      \ you must account for this. If you are attempting to make clientside effects,\
      \ then make sure you set the RemoteRole to ROLE_None immediately afterwards.\
      \ Since relevancy is only checked between ticks, this will ensure that when\
      \ that check does come around, it will not be relevant, and thus not replicated.\
      \ That way, the server and the client will each have their local copy of the\
      \ effects that run their course and then destroy themself. This is not useful\
      \ for permanent effects, since simulated functions are not run on ALL clients,\
      \ only clients where the actor containing the simulated function is relevant.\
      \ That means that if the simulated function didn't run (because it's actor was\
      \ not relevant at the time), then the effect will not be visible when you come\
      \ into view of that effect. That is why it should only be used for temporary\
      \ effects that run their course and then destroy themselves.</p>\n<p>If however,\
      \ you are spawning something that is intended to be permanent, or needs data\
      \ replicated from the server, (like a crosshair dot,) then you SHOULD NOT spawn\
      \ it on the client. Usually, you can accomplish this with a 'If (Level.NetMode&#160;!=\
      \ NM_Client)' check before you perform the spawn. This way, the spawned actor\
      \ will then become relevant (assuming the conditions match), and it's variables\
      \ will be replicated to the clients. If a client-side actor had been spawned,\
      \ then there would be two actors, one of which would just sit there without\
      \ information from the server</p>\n<h3><span class=\"mw-headline\" id=\"Networked-Function_Paramater_Optimizations\"\
      >Networked-Function Paramater Optimizations</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=27\"\
      \ title=\"Edit section: Networked-Function Paramater Optimizations\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>And finally, when\
      \ replicating functions, Unreal optimizes the parameters of a function call\
      \ through a few techniques. When sending a vector, (which is composed of three\
      \ floats,) the individual components are rounded to integers, and thus lose\
      \ their fractional values, and any values outside of -32768 to 32767. A common\
      \ technique is to multiply the values before they are sent to make them scaled\
      \ integers, and then dividing them on the other end back into their appropriate\
      \ values, so it is almost completely accurate. With rotators, the values are\
      \ scaled between 0 and 255, where the 128+ range corresponds to the normally\
      \ negative range of rotator component values. Then they are rounded to ints,\
      \ and sent over the network. They are then fixed back up again to their original\
      \ values (except they are left as positive values, since they are equivalent\
      \ to their negative counterpart that existed on the other end of the connection.\
      \ One approach that applies to both vectors and rotators is to send the X/Y/Z\
      \ or Pitch/Yaw/Roll values of the struct as individual floats so that complete\
      \ accuracy can be maintained. And finally, for completeness, planes (which are\
      \ not used much at all,) replicate their components as rounded integers.</p>\n\
      <h3><span class=\"mw-headline\" id=\"Simulated_States\">Simulated States</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=28\" title=\"Edit section:\
      \ Simulated States\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n\
      <p>Another, many times overlooked feature is that of simulated states. You probably\
      \ have already seen state code, code that exists outside of functions, but in\
      \ states, usually prefixed with labels. This code, when in a regular state,\
      \ is executed on the server alone. But by prefixing the state statename with\
      \ simulated, you can make the state code itself simulated. So the revised state\
      \ declaration would be simulated state statename. Just beware that state changes\
      \ are NOT replicated or sent to the client by default. However, if a gotostate\
      \ is executed in a function that is run on the client (either through replication\
      \ or simulation), then the client will know of the new state. Playerpawn's inherent\
      \ simulation allows all it's functions to be able to control the state, but\
      \ other classes would need to have simulated functions that are executed from\
      \ a simulated source and chain of function calls in order to know of the state\
      \ change. The current UT code makes no use of simulated states, but I thought\
      \ I would include this section for the sake of completeness, in case you ever\
      \ needed it.</p>\n<h2><span class=\"mw-headline\" id=\"Level_NetModes_and_their_Implications\"\
      >Level NetModes and their Implications</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=29\"\
      \ title=\"Edit section: Level NetModes and their Implications\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>In the Level variable,\
      \ which references a LevelInfo actor and is accessible from every object, is\
      \ a NetMode variable. The NetMode variable is used to describe what role or\
      \ position the current instance of UT plays in the overall scheme. The possible\
      \ values, and their uses are:</p>\n<dl>\n<dt>NM_Standalone</dt>\n<dd>This is\
      \ for when the game is played alone, like botmatches, the single player tournament\
      \ ladder, etc</dd>\n<dt>NM_DedicatedServer</dt>\n<dd>This is for when the server\
      \ is running alone, with no one playing directly in that instance of UT. This\
      \ is the netmode for the majority of servers that are online. It can be started\
      \ with 'ucc server', or by clicking 'Dedicated' when you select 'Start New Multiplayer\
      \ Game.'</dd>\n<dt>NM_ListenServer</dt>\n<dd>When you click 'Start' in the 'Start\
      \ New Multiplayer Game' window, you are starting a listen server, which is when\
      \ you are playing and hosting at the same time. This causes CPU to be spent\
      \ on rendering the world for you, as well as hosting the game for any connecting\
      \ players. Thus, dedicated servers are preferred to listen servers.</dd>\n<dt>NM_Client</dt>\n\
      <dd>When you are connected to a running UT server, no matter what type of server\
      \ it is, you are this netmode.</dd>\n</dl>\n<p>These netmodes are usually not\
      \ important as Roles and RemoteRoles can handle everything. However, when you\
      \ want to execute a block of code on the client, but don't want to replicate\
      \ it, these netmodes can help. For example, code is run on the client through\
      \ a chain of simulation. If the chain of simulation is upheld, then you can\
      \ do a 'if (Level.Netmode == NM_Client) {', then that code will be executed\
      \ on the client only, or on many clients, if that event exists in many places.\
      \ By combining that with a check on Owner, it is possible to ensure that it\
      \ is only run on one single client. One thing that makes the whole deal more\
      \ complex is that you want to ensure your code will run in standalone games,\
      \ and for the guy running and playing in listen servers. For this reason, you\
      \ will often see code that does 'if (Level.NetMode&#160;!= NM_DedicatedServer)\
      \ {', which probably does exactly what you want. Other examples include only\
      \ spawning non-relevant gibs if you aren't on a dedicated server (because of\
      \ the increase in CPU time). Another example is the use of spawning a gibbed\
      \ head. The gibbed head needs to travel in the same, but random, direction as\
      \ the server. Giving it a random velocity on the client would cause it to readjust\
      \ midflight when the network-replicated data came through the pipe. Instead,\
      \ the carcass head is not spawned clientside, but rather it lets the network\
      \ data create the head, and give it the server's random velocity, so that it\
      \ will be correctly in sync. Further uses are left to your imagination.&#160;:)</p>\n\
      <h2><span class=\"mw-headline\" id=\"Special_Properties_about_Special_Stuff\"\
      >Special Properties about Special Stuff</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=30\"\
      \ title=\"Edit section: Special Properties about Special Stuff\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<h3><span class=\"\
      mw-headline\" id=\"bNetOptional_Usage\">bNetOptional Usage</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=31\"\
      \ title=\"Edit section: bNetOptional Usage\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>You've seen bNetOptional talked about a few times.\
      \ Now's a good a time as any disucss what it was intended for, and when you\
      \ should use it. As was discussed earlier, any actors that have bNetOptional\
      \ set get put at the bottom of the list of actors. The effect of this is that\
      \ they get starved of bandwidth when the connection becomes full. If there's\
      \ bandwidth available however, then they'll be replicated. They have 150 ms\
      \ to be replicated, before they are forgotten about completely, and the client\
      \ never sees them. When should you use these? In most cases, you'll want to\
      \ use them for temporary effects that can be replicated to the client, and then\
      \ allowed to complete on their own. For example, a little puff of smoke coming\
      \ from a wall after you shoot it would be a good example. If your bandwidth\
      \ is overloaded, either from a big firefight, or from excessive lag, then the\
      \ little puff of smoke will not be seen. You probably won't notice it in either\
      \ case. bNetOptional actors will not be replicated after their initial replication,\
      \ either. They're conditions are evaluated only once, the first time they are\
      \ executed. They are expected to complete their actions without any interaction\
      \ of the server. This also saves a lot on bandwith. It wouldn't make sense to\
      \ have the server continually evaluate replication checks for these actors,\
      \ since that would only waste bandwidth. bNetOptional is not for everything\
      \ though. An explosion sprite, like a rocket's animated explosion, is necessary\
      \ for everyone in view. It's easy to miss a sprite puff of smoke in the heat\
      \ of battle, but a large explosion is not something easily missed. You'll want\
      \ to use the bNetOptional only for small, non-vital actors that aren't necessary.\
      \ In Unreal Tournament, they are used for decals, fragments (those little chunks\
      \ of 'wall' that fly off), shell casings, smoke puffs, the wall hits (the little\
      \ yellow 'spark' when you hit the wall), and the respawn effects. Note that\
      \ if the default lifespan is set to 0, then a bNetOptional actor will be treated\
      \ just like any other actor. If the bNetOptional actor does have a default lifespan\
      \ set, and it extends beyond the first 150 ms of it's lifetime, then it will\
      \ never be replicated. Any request to destroy an actor will be replicated to\
      \ the client regardless of at what point it exists in it's lifespan, as UT will\
      \ always make sure the client destroys what the server destroys.</p>\n<h3><span\
      \ class=\"mw-headline\" id=\"bNetTemporary_Usage\">bNetTemporary Usage</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=32\" title=\"Edit section:\
      \ bNetTemporary Usage\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n\
      <p>While we're at it, we might as well cover bNetTemporary here. bNetTemporary\
      \ actors are for 'tear-off replication', as someone once put it. They are replicated\
      \ when they are first spawned, and that is it. There is never any further connection\
      \ between the server and client in regards to that bNetTemporary actor. A bNetTemporary\
      \ actor is not necessarily temporary, just that the replication of it's variables\
      \ is temporary, (only once.) This is used in many places. In UT, all decals\
      \ and projectiles are bNetTemporary by default. A decal is replicated to every\
      \ client that it is relevant to, and then the connection is broken. this saves\
      \ significantly on bandwidth. This means that if you walk into view of a scene\
      \ where there was a battle that you did not witness, then you will not see any\
      \ of the decals in that room. They were temporarily replicated, and so you will\
      \ never see them if you weren't present for it's one-time replication. In Half-Life,\
      \ decals were not 'bNetTemporary', and so were sent to every client when they\
      \ came into view. This contributed to part of the lag that many experienced\
      \ because of the many decals and spraypaint decals that were spawned in a game.\
      \ bNetTemporary actors need to be destroyed in clientside simulated code, since\
      \ a server destruction of the actor will not replicate to the client, because\
      \ of it's bNetTemporary status. This is done when decals grow stale and need\
      \ to delete themselves based upon client information, since the server cannot\
      \ tell the client about that. Most projectiles utilize bNetTemporary. Take a\
      \ razorblade, for example. It gives the client the initial velocity, and the\
      \ client can work everything out from there. Since the razorblade is entirely\
      \ predictable and deterministic, it can be predicted on the client with 100%\
      \ accuracy. The wall it bounces off on the server.....it also bounces off the\
      \ equivalent wall on the client. Because it is entirely predictable, the server\
      \ only needs to send it once, and the client can figure it out. For that reason,\
      \ projectiles are bNetTemporary. Problems can happen when you enter a big room\
      \ that has razorblades flying around. Because the razorblades are bNetTemporary,\
      \ you will not know about them. So you can walk into what seems like a perfectly\
      \ empty room, and then get your head chopped off with a razorblade. However,\
      \ you'll since most people do not use 360 FOV, you'll probably attribute it\
      \ to just not seeing it coming. So no one ever notices that. Other projectiles\
      \ like the the guided redeemer missles, or even regular redeemer missles (which\
      \ can be shot down midflight) cannot be bNetTemporary because the server needs\
      \ to send status updates to the client. The green globs from the goop gun need\
      \ to be visible on the floor when you run into a room, (because they are sorta-long-lasting\
      \ land mines,) and so they too cannot be bNetTemporary. There are other examples\
      \ of where projectiles are not bNetTemporary, but I'm sure you get the idea.</p>\n\
      <h3><span class=\"mw-headline\" id=\"PlaySound.27s_and_PlayOwnedSound.27s_Special_Behaviors\"\
      >PlaySound's and PlayOwnedSound's Special Behaviors</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=33\"\
      \ title=\"Edit section: PlaySound's and PlayOwnedSound's Special Behaviors\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>This\
      \ one issue was brought to my attention when someone was trying to figure out\
      \ how come a sound wasn't playing correctly in his mod, even though it worked\
      \ fine in UT. After looking into it, I couldn't see how the sound was working\
      \ in UT. The replication and simulation behavior was not set up for it. Turns\
      \ out that it had hidden behavior, depending upon where and how it was called.\
      \ In theory, PlaySound is used to have an actor play a sound. The game will\
      \ determine how loud to play it, depending upon occlusion and distance, etc.\
      \ UT tries to determine the 'right' and intelligent way to propogate the sound,\
      \ depending upon how it was called. First, we'll cover PlaySound. It can be\
      \ called in two contexts:</p>\n<p>From a simulated function, or from a replicated-to-client\
      \ function</p>\n<ul>\n<li>In this scenario, the sound is being played in many\
      \ places. The simulated nature means that any player that can see the actor,\
      \ is getting the simulation events. So each client will play the sound on it's\
      \ own, due to the simulation. In the case of a replicated function, (where it's\
      \ being run on the client,) UT assumes you know what you're doing, and that\
      \ you want the sound to be played on that client only. You may wonder why there\
      \ is a check for a replicated-to-client function when there's already a simulated\
      \ function check, (since all replicated-to-client functions need to be simulated,)\
      \ but if you remember, a PlayerPawn that is operating under ROLE_AutonomousProxy\
      \ can execute replicated functions that do not have the simulated prefix. This\
      \ case covers those. In general, this play-locally behavior is what you want,\
      \ when you call PlaySound from within a simulated function.</li>\n</ul>\n<p>From\
      \ a non-simulated, non-replicated-to-client function</p>\n<ul>\n<li>When you\
      \ call PlaySound in this context, UT does more work for you. In this scenario,\
      \ the PlaySound is being called server-side. That does absolutely no good in\
      \ a real game, since that sound would then not be heard by anyone. You might\
      \ think it only has to be replicated, but if you'll remember, function replication\
      \ is not multicast, so the sound would only be heard by the owner of the actor\
      \ PlaySound is being called upon. Simulation doesn't help, since that would\
      \ only happen if the sound was being called on the client. Simulation does not\
      \ actually send anything over the network. So, UT performs some special magic\
      \ instead. In Pawn, there is a ClientHearSound, whose definition is:</li>\n\
      </ul>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"\
      uscript source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">native</span>\
      \ <span class=\"kw1\">simulated</span> <span class=\"kw1\">event</span> ClientHearSound\
      \ <span class=\"br0\">(</span>\n\t<span class=\"kw9\">actor</span> <span class=\"\
      kw9\">Actor</span>,\n\t<span class=\"kw5\">int</span> Id,\n\t<span class=\"\
      kw5\">sound</span> S,\n\t<span class=\"kw5\">vector</span> SoundLocation,\n\t\
      <span class=\"kw5\">vector</span> Parameters\n<span class=\"br0\">)</span>;</pre></div>\n\
      </div>\n<p>This ClientHearSound is replicated from the server to the client,\
      \ per the replication definition in Pawn. Remembering that it only goes to it's\
      \ owner, this works fine, since calling Pawn.ClientHearSound(someactor...) on\
      \ the server will cause that one pawn to hear the sound on the client, as if\
      \ the sound came from someactor's direction. The special magic performed, is\
      \ that UT effectively turns the call to PlaySound into a multicast function\
      \ replication on ClientHearSound. When PlaySound is called, it iterates through\
      \ all nearby players that should hear the sound, and replicates a call to ClientHearSound\
      \ to each player. In this fashion, each player that should hear it, does hear\
      \ it. And the original identity of the actor playing the sound is maintained\
      \ through the first parameter to ClientHearSound.</p>\n<p>This is actually quite\
      \ the nifty behavior for PlaySound, as it causes the function to work the way\
      \ it 'should,' in most cases. In the cases where it doesn't, you'll need to\
      \ figure in it's dual nature, and figure out how to call it, (or call some other\
      \ home-grown sound replication feature,) to make it work.</p>\n<p>The other\
      \ interesting behavior to talk about is that of PlayOwnedSound. The purpose\
      \ of this function is to play the sound for everyone but the owner. This may\
      \ seem strange at first, but there are a few uses for it. In UT, it used in\
      \ most of the weapons. When a client fires a gun, they should get immediate\
      \ feedback about the shot. That is why you see the weapon animations plya clientside,\
      \ and hear the sounds clientside. However, the client cannot force sounds to\
      \ be played elsewhere. What is done, is that the weapon plays a sound clientside\
      \ immediately when the shot is fired. The client then tells the server it fired\
      \ the gun, which then calls PlayOwnedSound with the sound, so that the sound\
      \ can be heard by all the other clients. You wouldn't want the sound to be played\
      \ on the player firing the gun, since they already played the sound. Hopefully\
      \ that example is clear, but you can check the examples provided in UT's weapons\
      \ if it does not satisfy you. One final note: when UT determines who is the\
      \ owner, it only checks the actor itself (to see if it is the pawn or the playerpawn),\
      \ and the immediate owner of the actor. It does not follow the hierarchy up\
      \ like some other functions do.</p>\n<h3><span class=\"mw-headline\" id=\"ClientPlaySound_and_ClientReliablePlaySound\"\
      >ClientPlaySound and ClientReliablePlaySound</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=34\"\
      \ title=\"Edit section: ClientPlaySound and ClientReliablePlaySound\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>Here's a simple\
      \ example, but still noteworthy nonetheless. ClientPlaySound is an unreliable\
      \ function that plays a sound on the client. Calling PlayerPawn.ClientPlaySound(...)\
      \ causes that player to play the sound locally on their machine. It is a location-less\
      \ sound, and the sound is played as if it came from within their head, (as opposed\
      \ to next to them, or in front of them, etc.) When called on the client, it\
      \ is guaranteed to run, since no replication is involved, (it's a simulated\
      \ function being called from a simulated function...) When it is called from\
      \ the server, it is not guaranteed to reach the other end, however. What happens\
      \ if you want to ensure that the sound is played? You call ClientReliablePlaySound,\
      \ of course. This is a reliable function, which ensures that the sound reaches\
      \ the client and is played. I'll just rip the whole ClientReliablePlaySound\
      \ function, so you can see what is going on:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">simulated</span> <span class=\"kw1\"\
      >function</span> ClientReliablePlaySound<span class=\"br0\">(</span><span class=\"\
      kw5\">sound</span> ASound, <span class=\"kw1\">optional</span> <span class=\"\
      kw5\">bool</span> bInterrupt, <span class=\"kw1\">optional</span> <span class=\"\
      kw5\">bool</span> bVolumeControl <span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n\tClientPlaySound<span class=\"br0\">(</span>ASound, bInterrupt,\
      \ bVolumeControl<span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>You can see that the reliable definition which is farther above in\
      \ PlayerPawn ensures that ClientReliablePlaySound is run. Once that happens,\
      \ the body of ClientReliablePlaySound is run on the client. There, it calls\
      \ ClientPlaySound which ensures that the sound is played.</p>\n<h2><span class=\"\
      mw-headline\" id=\"When_Things_Go_Awry\">When Things Go Awry</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=35\"\
      \ title=\"Edit section: When Things Go Awry\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>What should you do when things go awry? There's two\
      \ main techniques that I use, when trying to figure out what's going on. Technically,\
      \ everything can be figured out with the first technique alone, but the second\
      \ helps a lot in figuring out the applying technique.</p>\n<h2><span class=\"\
      mw-headline\" id=\"Figure_Out_What.27s_Going_On\">Figure Out What's Going On</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=36\" title=\"Edit section:\
      \ Figure Out What's Going On\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>You need to isolate your problem. Know exactly what's\
      \ happening. What stuff is being replicated, and what isn't. Then realize that\
      \ those are only your assumptions, and that no matter what, you cannot be positive\
      \ about them. With all the native stuff happening with replication, it's so\
      \ easy to blame your problems on what's going on under the hood. In fact, after\
      \ readinng this guide, you should be able to solve your problems yourself. I\
      \ think I've covered just about every native replication aspect there is in\
      \ this document. It's why it's so big. When I was having replication troubles,\
      \ I remember that I wished there was documentation. I'd (and I'm sure others)\
      \ would rather have too much than too little. Anyways, now that I've had access\
      \ to the source, and have been able to know exactly what's been going on, I've\
      \ been able to figure out why problems are happening in netplay, even ones that\
      \ aren't my own. I say this only to point out that just knowing and understanding\
      \ what's going on under the hood can make any problem solvable. You don't need\
      \ extensivle trial and error to figure out where things are screwing up. Just\
      \ thinking the problem through, and checking the unrealscript code, can provide\
      \ you with the answer.</p>\n<p>First, figure out what you believe is not replicating.\
      \ Is it a function? A variable? What's going on exactly? Sometimes, because\
      \ of intricate relationships in your code, you'll be unable to tell exactly\
      \ what is 'missing' on the client. In that case, you'll need to use logging\
      \ to figure out what's there and what's not. Logging is the second technique\
      \ I mentioned. I'll discuss more on how to use it properly in debugging networking\
      \ problems in a bit.</p>\n<h3><span class=\"mw-headline\" id=\"Check_the_Replication_Statements\"\
      >Check the Replication Statements</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=37\"\
      \ title=\"Edit section: Check the Replication Statements\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>Anyways, once you figure out\
      \ what's not being replicated, check the replication statement. 98% of the time,\
      \ you can figure out why something is not replicating, by evaluating the replication\
      \ statement yourself. I went through a great many replication statements in\
      \ actor up above in the variable replication section. You might want to check\
      \ there for some of the more common ones. But thinking about each part of the\
      \ statement in turn will help you figure it out. Many times, stuff has a bNetInitial\
      \ clause, which only happens the first time the actor is sent over the network\
      \ when becoming relevant. This causes problems when your data isn't getting\
      \ replicated midstream, or is at odd points, like when it goes out of and then\
      \ comes back into relevancy. You can follow the function replication and simulation\
      \ guidelines listed above to see if the function meets the criteria for being\
      \ sent accross the network, or evaluated client-side.</p>\n<p>Another programmer\
      \ I've talked to had problems with his velocity not replicating when the grenades\
      \ were thrown, but it was because they were only replicated on bNetInitial,\
      \ and so that's why he never saw his velocity updates. Fiddling with the variables,\
      \ he found that a RemoteRole of ROLE_DumbProxy seemed to work, as the grenades\
      \ did seem to be moving. It may be hard to tell that's what is going on when\
      \ you're on a LAN or even connecting to your own server, because of the small\
      \ ping, and high bandwidth. But you can be sure that you're players playing\
      \ over their modems will notice it.&#160;:) Remember the various properties\
      \ of ROLE_DumbProxy, and ROLE_SimulatedProxy, and what side effects each causes,\
      \ in terms of what is replicated. I've seen a few cases where that is the reason\
      \ for their strange behavior. The problem with his approach was that he was\
      \ getting the spoon-fed location updates from the server, and so in a real environment\
      \ online, that would never work, since players cannot get location updates over\
      \ the net and expect it to work right. In that case, the grenades should never\
      \ be thrown from the inventory. ROLE_SimulatedProxy was a perfect fit for what\
      \ he was trying to do, except for the fact that when he threw it, it was not\
      \ bNetInitial. Instead, he just had to spawn a new actor, and give it the 'thrown'\
      \ properties. That satisfied the criteria needed for the variable replication\
      \ for ROLE_SimulatedProxy, and allowed the grenades to be thrown correctly,\
      \ be simulated correctly, and it to all just work.</p>\n<h3><span class=\"mw-headline\"\
      \ id=\"Logging_is_Your_Friend\">Logging is Your Friend</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=38\"\
      \ title=\"Edit section: Logging is Your Friend\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>If that doesn't help you, try sticking logging statements\
      \ in there. When you have two copies of UT running, a server and a client, two\
      \ different logs are generated. One is a server log, and one is a client log.\
      \ (doh&#160;:) If you aren't sure if a function is executing clientside, place\
      \ a log in it. Then, check to see if that log appears in the clientside log.\
      \ If it does, then the function is running on the client, and your strange behavior\
      \ must be coming from elsewhere. If there is no log happening, then the function\
      \ is not being executed. You may think it must be, because it is the only explanation\
      \ for behavior you are seeing. But the logs do not lie. What is more often the\
      \ case is that the function is being run on the server, and modifying variables,\
      \ which are being replicated to the client, giving the appearance that the function\
      \ ran on the client. As i talked about before, it can be easy to overlook this\
      \ in LAN settings, but it will surely be found in real world conditions. I'll\
      \ discuss how to test things in 'real-world' conditions in just a bit. Logging\
      \ is your friend, and you should become quite familiar with it. Most Unreal\
      \ Tournament programmers are already familiar with it, and if they've gotten\
      \ bogged down in replication problems already, they're just about gunaranteed\
      \ to have logged stuff in trying to figure things out. However, combine logging\
      \ with a knowledge of what's actually going on, and you increase your chances\
      \ of success manifold. I'll be covering a few 'case studies' of sorts at the\
      \ end of the document. You'll be able to see exactly what's going on as each\
      \ part is done, and hopefully the real-world examples of replication will make\
      \ things clearer.</p>\n<h2><span class=\"mw-headline\" id=\"Testing_Real-World_Conditions\"\
      >Testing Real-World Conditions</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=39\"\
      \ title=\"Edit section: Testing Real-World Conditions\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h2>\n<h3><span class=\"mw-headline\"\
      \ id=\"Testing_a_Mod_in_Netplay_without_a_Network\">Testing a Mod in Netplay\
      \ without a Network</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=40\" title=\"\
      Edit section: Testing a Mod in Netplay without a Network\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>It's always important to test\
      \ your mod in netplay. Sometimes, it can be hard, when you don't have a bunch\
      \ of people available to test with. However, there is nothing preventing you\
      \ from running a server and a client on the same machine. This allows you to\
      \ test netplay on a single machine.</p>\n<h4><span class=\"mw-headline\" id=\"\
      Windows_9x\">Windows 9x</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=41\"\
      \ title=\"Edit section: Windows 9x\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>On Windows 9x, the UT client will consume 100% of\
      \ the CPU by default. This is so that extraneous programs like ICQ, mirc, or\
      \ whatever else you might have open do not steal CPU resources from your UT\
      \ client, which should get full priority. This means that if you run a client\
      \ and server on the same machine, the server will be starved of CPU cycles,\
      \ and your UT client will experience extreme lag and packet loss. While you\
      \ may want to simulate these at some point, this is not the way to go about\
      \ doing it. Luckily, someone wrote a simple program that helps solve this dilemma\
      \ of testing a UT server and client together. It was originally intended to\
      \ solve this same problem for QuakeWorld servers, but it is perfectly applicable\
      \ to our situation.</p>\n<p>Let's disucss how to use it. First, download priority\
      \ and extract it somewhere safe. I have mine in my UnrealTournament\\System\
      \ directory. Next start your server. Your best bet is to do this with the 'ucc\
      \ server' commandlet. The general format for testing your mods should be:</p>\n\
      <p>ucc server mapname.unr?game=packagename.classname?packagename1.classname1,packagename2.classname2</p>\n\
      <p>Some example commandlines follow:</p>\n<ul>\n<li>ucc server DM-Morbias][</li>\n\
      <li>ucc server DM-Morpheus?game=RocketArena.RocketArenaGame</li>\n<li>ucc server\
      \ CTF-Face?mutators=Botpack.InstaGibDM,Botpack.LowGrav</li>\n</ul>\n<p>Next,\
      \ you have to tell priority to give more priority to our UT server. You can\
      \ read the readme associated with priority if you're interested in exactly what\
      \ commandline parameters do what. But for our UT client/server testing purposes,\
      \ just type the following in another window or command prompt:</p>\n<p>ucc -title\
      \ ucc</p>\n<p>Now, our UT server will have the necessary CPU time it needs to\
      \ run, even if a UT client is running. Now run the UT client, connecting to\
      \ your local machine, with:</p>\n<p>unrealtournament 127.0.0.1</p>\n<p>Test\
      \ your mod, and make sure it all works as you have planned. Of course, some\
      \ things will require the use of more than one person to test, but at least\
      \ you should be able to test and fix a large portion of your problems yourself,\
      \ without requiring someone's valuable time, or requiring you to waste your\
      \ own organizing a beta team and stuff.</p>\n<h4><span class=\"mw-headline\"\
      \ id=\"Windows_NT.2F2000\">Windows NT/2000</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=42\"\
      \ title=\"Edit section: Windows NT/2000\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>On Windows NT/2000, this is not a problem, since NT\
      \ supports true multi-tasking, and so the use of priority.exe is not an issue.\
      \ ////////////////////////////</p>\n<h3><span class=\"mw-headline\" id=\"Simulating_Lag_and_PacketLoss\"\
      >Simulating Lag and PacketLoss</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=43\"\
      \ title=\"Edit section: Simulating Lag and PacketLoss\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>Testing multiplayer as described\
      \ above only solves one problem. It helps you see if your code will execute\
      \ in multiplayer correctly. However, the successful completion of that test\
      \ does not mean that your mod will work in netplay. When testing netplay on\
      \ your machine, your computer connects directly to itself, accross an incredibly\
      \ fast and large connection. Testing on a LAN has the same 'problem', in that\
      \ you will not be simulating the effect of people playing over modems on servers\
      \ halfway around the world. Luckily, UT includes commandline options to help\
      \ you simulate this type of behavior. They are: PktLoss, PktOrder, PktLag, and\
      \ PktDup. These variables only affect data as it is being sent, so you will\
      \ need to place them on the server and client to accomplish true lag. But first,\
      \ if you check your UnrealTournament.ini, you'll notice references to SimPacketLoss\
      \ and SimLatency. These worked once, in a land far, far away in a time long,\
      \ long ago. They do absolutely nothing now, so you might as well remove them\
      \ from your ini.</p>\n<p>The true way to simulate lag is to use the commandline\
      \ parameters when you start UT. We'll cover and document all of these variables\
      \ here. To use these variables, you need to start UT like this: unrealtournament.exe\
      \ server.ip.addr?PktLoss=4?PktLag=400. This will cause your UT client to experience\
      \ this amount of lag when sending data to the server. Data sent from the server\
      \ to the client till still travel at full speed, however. By the same token,\
      \ you can also pass these variables to ucc with ucc server mapname.unr?PktLoss=10?PktLag=600.\
      \ This will create a very 'bad' server with terrible conditions...probably too\
      \ extreme even for real-life conditions. (If you play under 600 ping and 10%\
      \ packetloss, then I feel bad for you.&#160;:) Let's get into the documentation\
      \ of the individual variables. PktLoss will work all the time. The remaining\
      \ three, PktOrder, PktLag, and PktDup are mutually exclusive, and if multiple\
      \ options are passed on the commandline, the order just stated is the order\
      \ they are checked. For example, if you pass PktLoss, PktLag, and PktOrder,\
      \ then only PktOrder and PktLoss will be used. PktOrder has a higher priority\
      \ than PktLag, and PktLoss always works.</p>\n<h4><span class=\"mw-headline\"\
      \ id=\"PktLoss\">PktLoss</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=44\"\
      \ title=\"Edit section: PktLoss\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>The first, PktLoss. is set a percentage of packets\
      \ sent. It determines the percentage of packets lost over the connection. Passing\
      \ 10 will mean that 10% of the packets sent to the client will be lost to the\
      \ bandwidth graveyard. Any packetloss usually will hurt a connection in real\
      \ world connection, as many people complain about anything over 0% packetloss.\
      \ So when testing, this value doesn't need to be that high, and probably should\
      \ only range between 0 and 10. PktLoss set with: PktLoss=5</p>\n<h4><span class=\"\
      mw-headline\" id=\"PktOrder\">PktOrder</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=45\"\
      \ title=\"Edit section: PktOrder\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>The next, PktOrder, determines whether packets will\
      \ be sent out of order. This is simply a boolean flag, meaning that the only\
      \ option for it is on/off, not a variable as in PktLoss. If this flag is set\
      \ to on, it preclues the use of PktLag and PktDup, described below. PktOrder\
      \ works like this: Every time a packet is going to be sent, it gets put at the\
      \ end of a 'to-send' list. Then UT goes through the 'to-send' list, and sends\
      \ half of the variables over the connection. While this is not truly random,\
      \ it doesn't matter. It succeeds in it's goal in sending packets out of order,\
      \ since they can be kept on the list for an indefinite length of time. PktOrder\
      \ set with: PktOrder=1</p>\n<h4><span class=\"mw-headline\" id=\"PktLag\">PktLag</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Replication_De-Obfuscation?section=46\" title=\"Edit section:\
      \ PktLag\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h4>\n\
      <p>If you want to delay packets and simulate lag, then PktLag is the variable\
      \ you want. Precluding the use of PktDup, and only working if PktOrder is not\
      \ set, PktLag is set as a value of milliseconds. All packets being sent over\
      \ the connection will be delayed by PktLag milliseconds. PktLag set with: PktLag=450</p>\n\
      <h4><span class=\"mw-headline\" id=\"PktDup\">PktDup</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=47\"\
      \ title=\"Edit section: PktDup\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>If you want to simulate the effects of sending packets\
      \ twice over the network, PktDup fits the bill. Only working if both PktOrder\
      \ and PktLag are not set, PktDup is set as a percentage of packets that are\
      \ duplicated. Every packet that is sent has a PktDup chance of being sent twice.\
      \ All packets will be sent once. PktDup set with PktDup=20</p>\n<h4><span class=\"\
      mw-headline\" id=\"Using_the_Variables\">Using the Variables</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=48\"\
      \ title=\"Edit section: Using the Variables\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<p>Now that you know how the variables work, here's a\
      \ little lesson in how to use them. Remember that they only work for packets\
      \ being sent. So if you set PktLag to 500 on the server, the client will experience\
      \ 500 ms lag between what the server sent and what the client sees. Client packets\
      \ sent to the server will go at their regular speed, however, which is usually\
      \ around 40 ms each way on my machine. To truly test lag, you will need to use\
      \ PktLag on both the client and the server. Ping, if you remember, is the time\
      \ it takes for a packet to go round trip from client to server and back to client.\
      \ To simulate a 500 ping, the best way would be to give a 250 PktLag on both\
      \ the server and the client. All clients to connect to the server would then\
      \ experience 250 ms additional lag, regardless of their local settings. The\
      \ client would then add 250 ms additional lag itself through PktLag, resulting\
      \ in a 500 ms effective ping.</p>\n<p>Of the variables above, you will find\
      \ yourself using PktLoss and PktLag most often. The others were more intended\
      \ for Epic to test the results of it's own network code, and test it under extreme\
      \ conditions that it could not duplicate. I doubt you will have need of PktDup\
      \ or PktOrder unless you are unable to reproduce the player-reported problems\
      \ about your mod being unresponsive or ineffective.</p>\n<h2><span class=\"\
      mw-headline\" id=\"Conclusion\">Conclusion</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=49\"\
      \ title=\"Edit section: Conclusion\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>That's it, folks. Hopefully you now understand replication\
      \ a lot more than you did before. Granted, it all may seem COMPLETELY overwhelming\
      \ and confusing at first, and it is. But through application and testing of\
      \ these principles, you will become more familiar with what is going on, and\
      \ will better grasp network coding as time passes. You may need to read this\
      \ document through a few times, before it all sinks in. If you find a section\
      \ that is confusing even after you've read it through, send me an email at mongo-replication@jall.org.\
      \ Don't expect me to help you out personally however, since I imagine I will\
      \ probably get countless emails from new people that don't meet the basic assumptions\
      \ I made and stated at the beginning of the document. It is always inevitable.\
      \ Of course, those people probably haven't even read this far, so they'll be\
      \ emailing me anyway, but I'm just letting you faithful readers know.&#160;:)\
      \ I'm planning to read all your emails, and if they have good or valid suggestions\
      \ for things to cover, or describe ambiguous or confusing aspects of my tutorial,\
      \ then I'll make corrections and updates to this document in the future.</p>\n\
      <p>When something doesn't work, don't assume it's UT's native code in regards\
      \ to replication. I believe I have successfully delineated all such hidden tricks\
      \ in this document. The error has to be in your code, however much you don't\
      \ like hearing that. Trust me, this is from experience.&#160;;) Check your replication\
      \ statements to make sure their logic is correct, and run through your code\
      \ as both the server and the client, following the flow of logic to figure out\
      \ what's going on. Make sure what you're expecting to be replicated or simulated\
      \ IS ACTUALLY replicated or simulated, by following the checklists I've given\
      \ in the document above. And as I stated before, LOG LOG LOG LOG. Fill your\
      \ code chock-full of logs, to make sure that things are happening the way you\
      \ want. After following all the guidelines, the only true test to make sure\
      \ things are happening the way you expect is to put logs in, and see what is\
      \ happening where. With all this in mind, I'm sure you will be successful in\
      \ your future networking endeavors.</p>\n<p>Good luck!</p>\n<p>Mongo</p>\n<p>Still\
      \ to cover:</p>\n<h2><span class=\"mw-headline\" id=\"Special_Networking_Tricks_.28Case_Studies.29\"\
      >Special Networking Tricks (Case Studies)</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Replication_De-Obfuscation?section=50\"\
      \ title=\"Edit section: Special Networking Tricks (Case Studies)\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Let's take a look\
      \ at a few examples and problems that people have had, and an approach to solving\
      \ them. Hopefully, this will help you solve your own problem, or at the very\
      \ least, help you see how others have approached their problems, and fixed them.</p>\n\
      <p>thoroughly read through above sections on special properties of special stuff,\
      \ realworld conditions, things go awry serverpackages packageflags native final\
      \ functions are simulated automatically (?) state changes only seen for playerpawns,\
      \ unless changed in simulated functions (then they cause problems for newly\
      \ relevant actors) window stuff on client functions usually replicated before\
      \ variables, cannot be sure Case Studies:</p>\n<ul>\n<li>HUDMutators (everyone\
      \ wants them&#160;:/ )</li>\n<li>DrSiN's Window Replication Info</li>\n<li>How\
      \ to get custom pris: RAUT's PRI extra stuff (avoid spawnnotifies)</li>\n<li>Laser-Guided-Ripper\
      \ Tutorial get a better laserdot</li>\n<li>UT's method for sending data to the\
      \ server for playerpawns</li>\n<li>How they did the GuidedWarhead in netplay</li>\n\
      </ul>\n<p>Weapon Replication/Networking overview (where?)</p>\n<p>Other Neat\
      \ Tricks</p>\n<ul>\n<li>Faking replication of parent-variables that wouldn't\
      \ normally replicate</li>\n<li>Faking multicast replication with specially-owned\
      \ objects by each player, that get functions called on them from a general function.</li>\n\
      <li>Use physics to your advantage Use of PHYS_Trailer for Halo, Shieldbelt</li>\n\
      <li>Use of Simulated ticks to accomplish clientside manual physics just a discussion,\
      \ as complex code: Taliesin's code for inverse IK (hey, it's cool, too!)</li>\n\
      <li>Other ways of doing non-standard variable replication with functions, like\
      \ Taliesin's code for seekers</li>\n</ul>\n\n<!-- \nNewPP limit report\nCPU\
      \ time usage: 0.454 seconds\nReal time usage: 1.216 seconds\nPreprocessor visited\
      \ node count: 322/1000000\nPreprocessor generated node count: 476/1000000\n\
      Post‐expand include size: 0/2097152 bytes\nTemplate argument size: 0/2097152\
      \ bytes\nHighest expansion depth: 2/40\nExpensive parser function count: 0/100\n\
      -->\n\n<!-- \nTransclusion expansion time report (%,ms,calls,template)\n100.00%\
      \    0.000      1 - -total\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:2714-0!*!*!!en!*!*\
      \ and timestamp 20221118022504 and revision id 44258\n -->\n"
  categories: []
  links: []
  templates: []
  images: []
  externallinks:
  - "http://unreal.epicgames.com/Network.htm"
  - "http://unreal.epicgames.com/UTMods.html"
  - "http://unreal.jall.org/tutorials/replication.html"
  - "http://web.archive.org/web/20060813220553/http://unreal.jall.org/tutorials/replication.html"
  sections:
  - toclevel: 1
    level: "2"
    line: "Introduction"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 292
    anchor: "Introduction"
  - toclevel: 2
    level: "3"
    line: "Server as Authority"
    number: "1.1"
    index: "2"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 3181
    anchor: "Server_as_Authority"
  - toclevel: 1
    level: "2"
    line: "Replication Overview"
    number: "2"
    index: "3"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 6227
    anchor: "Replication_Overview"
  - toclevel: 1
    level: "2"
    line: "Relevant Actors"
    number: "3"
    index: "4"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 8501
    anchor: "Relevant_Actors"
  - toclevel: 1
    level: "2"
    line: "NetPriorities"
    number: "4"
    index: "5"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 15006
    anchor: "NetPriorities"
  - toclevel: 1
    level: "2"
    line: "Roles and RemoteRoles Introduction"
    number: "5"
    index: "6"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 18864
    anchor: "Roles_and_RemoteRoles_Introduction"
  - toclevel: 1
    level: "2"
    line: "General Replication"
    number: "6"
    index: "7"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 22148
    anchor: "General_Replication"
  - toclevel: 2
    level: "3"
    line: "No Recursive Relevancy"
    number: "6.1"
    index: "8"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 23448
    anchor: "No_Recursive_Relevancy"
  - toclevel: 2
    level: "3"
    line: "Replication Checks"
    number: "6.2"
    index: "9"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 24573
    anchor: "Replication_Checks"
  - toclevel: 2
    level: "3"
    line: "Special Replication Variables"
    number: "6.3"
    index: "10"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 26195
    anchor: "Special_Replication_Variables"
  - toclevel: 2
    level: "3"
    line: "NetUpdateFrequency"
    number: "6.4"
    index: "11"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 27100
    anchor: "NetUpdateFrequency"
  - toclevel: 2
    level: "3"
    line: "Reliable versus Unreliable"
    number: "6.5"
    index: "12"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 28010
    anchor: "Reliable_versus_Unreliable"
  - toclevel: 2
    level: "3"
    line: "Writing Replication Statements"
    number: "6.6"
    index: "13"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 29813
    anchor: "Writing_Replication_Statements"
  - toclevel: 1
    level: "2"
    line: "Variable Replication"
    number: "7"
    index: "14"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 32639
    anchor: "Variable_Replication"
  - toclevel: 2
    level: "3"
    line: "Newly Relevant Actors (Spawning)"
    number: "7.1"
    index: "15"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 33128
    anchor: "Newly_Relevant_Actors_.28Spawning.29"
  - toclevel: 2
    level: "3"
    line: "A Time for Replication"
    number: "7.2"
    index: "16"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 35832
    anchor: "A_Time_for_Replication"
  - toclevel: 2
    level: "3"
    line: "Client-Server Replication"
    number: "7.3"
    index: "17"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 36279
    anchor: "Client-Server_Replication"
  - toclevel: 2
    level: "3"
    line: "Replication Only When Necessary"
    number: "7.4"
    index: "18"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 37185
    anchor: "Replication_Only_When_Necessary"
  - toclevel: 2
    level: "3"
    line: "Replication Data Approximation"
    number: "7.5"
    index: "19"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 38686
    anchor: "Replication_Data_Approximation"
  - toclevel: 1
    level: "2"
    line: "Variable Replication Examples"
    number: "8"
    index: "20"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 39942
    anchor: "Variable_Replication_Examples"
  - toclevel: 1
    level: "2"
    line: "Role and RemoteRole Summary"
    number: "9"
    index: "21"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 57177
    anchor: "Role_and_RemoteRole_Summary"
  - toclevel: 1
    level: "2"
    line: "Function Replication, and Simulation"
    number: "10"
    index: "22"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 65191
    anchor: "Function_Replication.2C_and_Simulation"
  - toclevel: 2
    level: "3"
    line: "Rep/Sim Function Rules"
    number: "10.1"
    index: "23"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 66204
    anchor: "Rep.2FSim_Function_Rules"
  - toclevel: 2
    level: "3"
    line: "Rep/Sim Function Rules Restatement"
    number: "10.2"
    index: "24"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 68453
    anchor: "Rep.2FSim_Function_Rules_Restatement"
  - toclevel: 2
    level: "3"
    line: "Rep/Sim Function Summary"
    number: "10.3"
    index: "25"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 69250
    anchor: "Rep.2FSim_Function_Summary"
  - toclevel: 2
    level: "3"
    line: "Spawning Within Simulated Functions"
    number: "10.4"
    index: "26"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 71375
    anchor: "Spawning_Within_Simulated_Functions"
  - toclevel: 2
    level: "3"
    line: "Networked-Function Paramater Optimizations"
    number: "10.5"
    index: "27"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 74256
    anchor: "Networked-Function_Paramater_Optimizations"
  - toclevel: 2
    level: "3"
    line: "Simulated States"
    number: "10.6"
    index: "28"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 75543
    anchor: "Simulated_States"
  - toclevel: 1
    level: "2"
    line: "Level NetModes and their Implications"
    number: "11"
    index: "29"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 76662
    anchor: "Level_NetModes_and_their_Implications"
  - toclevel: 1
    level: "2"
    line: "Special Properties about Special Stuff"
    number: "12"
    index: "30"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 79409
    anchor: "Special_Properties_about_Special_Stuff"
  - toclevel: 2
    level: "3"
    line: "bNetOptional Usage"
    number: "12.1"
    index: "31"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 79455
    anchor: "bNetOptional_Usage"
  - toclevel: 2
    level: "3"
    line: "bNetTemporary Usage"
    number: "12.2"
    index: "32"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 81897
    anchor: "bNetTemporary_Usage"
  - toclevel: 2
    level: "3"
    line: "PlaySound's and PlayOwnedSound's Special Behaviors"
    number: "12.3"
    index: "33"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 84882
    anchor: "PlaySound.27s_and_PlayOwnedSound.27s_Special_Behaviors"
  - toclevel: 2
    level: "3"
    line: "ClientPlaySound and ClientReliablePlaySound"
    number: "12.4"
    index: "34"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 89814
    anchor: "ClientPlaySound_and_ClientReliablePlaySound"
  - toclevel: 1
    level: "2"
    line: "When Things Go Awry"
    number: "13"
    index: "35"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 91254
    anchor: "When_Things_Go_Awry"
  - toclevel: 1
    level: "2"
    line: "Figure Out What's Going On"
    number: "14"
    index: "36"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 91547
    anchor: "Figure_Out_What.27s_Going_On"
  - toclevel: 2
    level: "3"
    line: "Check the Replication Statements"
    number: "14.1"
    index: "37"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 93266
    anchor: "Check_the_Replication_Statements"
  - toclevel: 2
    level: "3"
    line: "Logging is Your Friend"
    number: "14.2"
    index: "38"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 95778
    anchor: "Logging_is_Your_Friend"
  - toclevel: 1
    level: "2"
    line: "Testing Real-World Conditions"
    number: "15"
    index: "39"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 97504
    anchor: "Testing_Real-World_Conditions"
  - toclevel: 2
    level: "3"
    line: "Testing a Mod in Netplay without a Network"
    number: "15.1"
    index: "40"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 97541
    anchor: "Testing_a_Mod_in_Netplay_without_a_Network"
  - toclevel: 3
    level: "4"
    line: "Windows 9x"
    number: "15.1.1"
    index: "41"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 97884
    anchor: "Windows_9x"
  - toclevel: 3
    level: "4"
    line: "Windows NT/2000"
    number: "15.1.2"
    index: "42"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 100067
    anchor: "Windows_NT.2F2000"
  - toclevel: 2
    level: "3"
    line: "Simulating Lag and PacketLoss"
    number: "15.2"
    index: "43"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 100253
    anchor: "Simulating_Lag_and_PacketLoss"
  - toclevel: 3
    level: "4"
    line: "PktLoss"
    number: "15.2.1"
    index: "44"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 102517
    anchor: "PktLoss"
  - toclevel: 3
    level: "4"
    line: "PktOrder"
    number: "15.2.2"
    index: "45"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 103031
    anchor: "PktOrder"
  - toclevel: 3
    level: "4"
    line: "PktLag"
    number: "15.2.3"
    index: "46"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 103733
    anchor: "PktLag"
  - toclevel: 3
    level: "4"
    line: "PktDup"
    number: "15.2.4"
    index: "47"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 104061
    anchor: "PktDup"
  - toclevel: 3
    level: "4"
    line: "Using the Variables"
    number: "15.2.5"
    index: "48"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 104421
    anchor: "Using_the_Variables"
  - toclevel: 1
    level: "2"
    line: "Conclusion"
    number: "16"
    index: "49"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 105782
    anchor: "Conclusion"
  - toclevel: 1
    level: "2"
    line: "Special Networking Tricks (Case Studies)"
    number: "17"
    index: "50"
    fromtitle: "Legacy:Replication_De-Obfuscation"
    byteoffset: 108017
    anchor: "Special_Networking_Tricks_.28Case_Studies.29"
  displaytitle: "Legacy:Replication De-Obfuscation"
  iwlinks: []
  wikitext:
    text: "'''A blatant \"copy\" from [http://unreal.jall.org/tutorials/replication.html\
      \ http://unreal.jall.org/tutorials/replication.html], since that link seems\
      \ to be down (Web Archive copy [http://web.archive.org/web/20060813220553/http://unreal.jall.org/tutorials/replication.html\
      \ is available])'''\n\n\n== Introduction ==\n\nAsk any halfway decent UnrealScript\
      \ programmer what the most confusing aspect of Unreal coding, and he'll be sure\
      \ to tell you replication. (or perhaps PlayerMovement or pawn/bot AI :) I've\
      \ been there myself, and I still have trouble with it sometimes, but I think\
      \ I know enough to write some documentation. Lots of trial and error helped\
      \ me get far, along with various insights from people that had the source code\
      \ to the engine. I've tried to piece it all together to create this document.\
      \ I have however, recently gotten a lot more information about exactly how replication\
      \ works, which has helped me immensely in understanding replication. Since I\
      \ can't post that information directly because of NDA, I'll try my best to explain\
      \ it to you through this networking documentation. Hopefully I'll be able to\
      \ expand upon what was described in Epic's documents at: http://unreal.epicgames.com/Network.htm\
      \ and http://unreal.epicgames.com/UTMods.html. Please read it first, as it will\
      \ help a lot with background and context. In writing this document, I'm going\
      \ to assume you've programmed in UnrealScript before, you have at the very least\
      \ considered the problems of replication, you are reasonably intelligent, you\
      \ know how to read, and you think my jokes are funny.\n\nFirst, Unreal Tournament\
      \ uses a client-server architecture. The client is basically a dumb terminal,\
      \ that sends data to the server about where the player moved, if they're jumping,\
      \ if they're shooting, etc. It displays to the user what is given to it by the\
      \ server. The client's information is necessarily out of date with what exists\
      \ on the server, because of lag, ping time, and other factors. So in order to\
      \ present a believable world, the client has logic to simulate what it thinks\
      \ the server will be sending it. It knows the laws of physics, and that if something\
      \ is travelling in a straight line, then it will contine to travel with that\
      \ same velocity. Likewise, if it's falling through the air, it's likely to continue\
      \ to be accelerated under the force of gravity. The dumb terminal predicts where\
      \ how the game state will be progressing, and so can provide the user with a\
      \ more believable game. On the other end of the connection is the server, which\
      \ holds the authoritative state of what's going on in the game. If the server\
      \ thinks you are dead, then you are dead. Like your teachers, they're never\
      \ wrong, no matter how much evidence you've seen to the contrary (like how you\
      \ *thought* you dodged that rocket). The client gets information sent to it\
      \ by the server (like where other people are, what things have been shot, etc)\
      \ , and sends other information back to the server (like where the client wants\
      \ to move, shoot, etc). In the client-server architecture, the client only communicates\
      \ with the server, and the server communicates with all of the clients (people\
      \ connected to the server).\n\n=== Server as Authority ===\n\nWith the recent\
      \ brew-ha-ha regarding the ZeroPing mod, which aims to give the client more\
      \ control, there have been two sides to the issue of why the server as authority\
      \ is the best model.\n\nA good description of the history of the networking\
      \ architectures in games can be found at the top of the tech page's networking\
      \ document. Go read the \"History\" section now, and then come back. The current\
      \ model is that of a client-server architecture, where the client has prediction\
      \ to minimize the effects of lag. In current versions of UT, the client tells\
      \ the server all about it's input. Where is the user looking, in which direction\
      \ are they moving, and are they firing primary or secondary fires.. The server\
      \ then uses that data to calculate information about the player, and to tell\
      \ other clients about that player. For the most part, that is all there is to\
      \ it. ZeroPing pioneered an idea of giving the client more power. It allowed\
      \ the client to decide whether they hit the other player. In theory, this sounds\
      \ great. The user gets to decide what's happening, and if they hit the player,\
      \ then they hit the player. Unfortunately, there are problems with this idea.\n\
      \nIn a large-scale game like UT or Q3A, many people try to cheat. The people\
      \ that make the game have to prevent that from happening. With these games,\
      \ the client does so little logic, that there is little room to cheat. The client\
      \ sends its data to the server, and the trusted server decides whether they\
      \ hit the player or not. Cheats are extremely limited in what they can do, as\
      \ they can only modify the direction the player is going, and whether to cheat\
      \ or not. It's not something that is really worthwhile. However, when you have\
      \ something like ZeroPing, you are letting the client decide whether or not\
      \ you hit the player. A cheat can pretend that it hit every player, and can\
      \ wreck havoc in such a game, where it is killing everyone the moment they enter\
      \ view, and sometimes even getting repeated kills ten times in a row on a single\
      \ player as they respawn and then are 'hit' again. Mods like ZeroPing are mods,\
      \ and so do not ahve the same public appeal that a full game does. As such,\
      \ mods are less likely to be hacked for cheats. But it does not make them immune.\
      \ If game makers were to use the approach that ZeroPing uses, there would be\
      \ a flood of cheats within weeks of the game's release. You can understand the\
      \ resistance that the game companies have for such an approach. It is not because\
      \ it's the 'not-invented-here' syndrome as many have suggested, but rather that\
      \ it really is much more open to cheating.\n\nAs a side note, I guess the ZeroPing\
      \ author does realize this. He has hidden his code to make it impossible to\
      \ cheat with. He took the security through obfuscation approach. This will work\
      \ for awhile, until code decompilers become available, or the code gets out.\
      \ While I am not working on any of these myself, I do know of some UnrealScript\
      \ code decompilers in the works. So this approach really will not work in the\
      \ long run.\n\n== Replication Overview ==\n\nReplication deals with how information\
      \ is sent from the server to the client and vice versa. Because of bandwidth\
      \ limitations for modems, not everything can be sent, and because of the unpredictability\
      \ of the Internet, not everything can be ensured of arriving on time. Only a\
      \ subset of all the information is sent to the client, and replication deals\
      \ with that subset that travels from the server to the client, and deals with\
      \ how the client sends its relevant information back to the server.\n\nWhile\
      \ the definition of replication may sound simple, there is a lot of underlying\
      \ assumptions and quirks that you must be aware of, which UT uses in the interest\
      \ of optimum bandwidth and speed. It's an unmapped jungle out there, and many\
      \ an explorer has been lost to the dangerous native inhabitants. This guide\
      \ you are reading is your map and survival guide.\n\nFirst, the Unreal server\
      \ does some logic like the following for each client connected:\n\n#Run all\
      \ events (like tick, timer, hitwall, etc)\n#Go through each client connected\
      \ to the server\n#Get the list of relevant actors for this client.\n#For each\
      \ actor, replicate variables that need to be replicated.\n#Replicate any function\
      \ calls that should be replicated to that particular client, if they were called\
      \ during the previous server-side events run above. \n\nThe client does the\
      \ following logic:\n\n#Receive data from the server, and update its local copies\
      \ of the actors\n#Run any replicated calls that were called on the server\n\
      #Run any simulated events (like tick, timer, hitwall, etc), and do the local\
      \ playerpawn handling\n#Find out what replicated were called on the client and\
      \ need to be replicated to the server, and send them \n\nIf that didn't make\
      \ any sense, don't worry about it. They just outline the main parts of replication,\
      \ and they will all be explained later.\n\nIf you did understand that, there's\
      \ still plenty to learn. UT has a lot of logic going on under the hood in regards\
      \ to replication, most of which is not immediately apparent. That was the purpose\
      \ of this document, to explain these mysteries to you, the reader, so that your\
      \ networking development will go that much more smoothly. Again, all this will\
      \ be explained in due time, assuming you read the whole document. :)\n\n== Relevant\
      \ Actors ==\n\nFirst, we need to define what a relevant actor is. A client,\
      \ as the dumb terminal, needs to know about everything that it will need to\
      \ display on screen. It needs to know about the other players, and weapons in\
      \ the level, if any projectiles are visible, if the flag is visible, health\
      \ packs, etc. All of these actors constitute the relevant set of actors. how\
      \ is the relevant set of actors determined? If an actor is not relevant, no\
      \ amount of replication statements or voodoo magic will cause its information\
      \ to be sent to the client. It must be relevant to that particular client in\
      \ order for data to be sent to that client. For Unreal / Unreal Tournament,\
      \ the method of determining relevant actors is as follows (ripped from the tech\
      \ page's networking document):\n\nThe following logic is performed on each actor,\
      \ and you should be able to tell whether it is relevant. The actor must pass\
      \ two discrete sets of steps in order to be considered relevant. One it passes\
      \ the first test, it must then pass the second. The rules higher in the list\
      \ have precedence over rules that follow them:\n\n#If it is bNetTemporary, then\
      \ it does not pass the first stage.\n#If it is not bStatic and not bNoDelete,\
      \ then it passes the first stage.\n#If it is a LevelInfo, it passes the first\
      \ stage.\n#If it is a temporary network actor, (as defined by bNetTemporary),\
      \ and it's been sent to this client already, then it does not pass the first\
      \ stage. These types of actors will be decribed in more detail later.\n#If its\
      \ Role is ROLE_None, then does not pass the first stage.\n#If it is bAlwaysRelevant,\
      \ and time since the last relevancy is less than 1 / NetUpdateFrequency (described\
      \ farther below) seconds, then it does not pass the first stage. This basically\
      \ means an actor will only update it's variables to the client NetUpdateFrequency\
      \ times per second. (NetUpdateFrequency values: Actor: 100, ZoneInfo: 4, GameReplicationInfo:\
      \ 4, PlayerReplicationInfo: 2, or Inventory: 8).\n#If it is bNetOptional, and\
      \ it has a non-zero LifeSpan (meaning it does not exist forever), and it is\
      \ not in the first 150 ms of its lifetime, then it passes the first stage. Any\
      \ attempt at replicating a bNetOptional actor after the first 150 ms, (because\
      \ it was pushed off the replication list due to bandwidth contraints for that\
      \ client, etc,) will fail.\n#If the time since the last relevancy is greater\
      \ than 1 / ~NetUpdateFrequency seconds, it passes the first stage. (This is\
      \ a more finely tuned optimization of NetUpdateFrequency, tuned to the type\
      \ of actor. It will only perform the calculations needed if it has passed through\
      \ the weeding techniques above.)\n#It does not pass the first stage. \n\nIf\
      \ it passed all of those steps, it's not through and clear to be relevant yet.\
      \ It has another step to go through. If it is deemed relevant during the following\
      \ steps, then it is relevant to this client.\n\n#If it is bAlwaysRelevant, then\
      \ it is relevant.\n#If it is owned by the client or owned by the actor we are\
      \ viewing through (as returned by PlayerCalcView), then it is relevant.\n#If\
      \ it is the client or the actor we are viewing through (as returned by PlayerCalcView),\
      \ then it is relevant.\n#If its Instigator is the client, then it is relevant.\n\
      #If it has an ambient sound and is within 'audible distance', then it is relevant.\n\
      #If it is a weapon that is owned by a visible Pawn owner, then it is relevant.\n\
      #If it is bHidden or and not bBlockPlayers and the AmbientSound is none, then\
      \ the actor is not relevant.\n#If it is not relevant (per the above tests),\
      \ but if any of the above conditions made it relevant within the last RelevantTimeout\
      \ seconds, (by default, five seconds, but is defined in UnrealTournament.ini:[IpDrv.TcpNetDriver],)\
      \ then it is relevant.\n#It is not relevant. \n\nThose rules, while seeming\
      \ complicated, are exactly how UT determines what is relevant to each client.\
      \ Many times such checks are not related to what you are doing, but they are\
      \ always good to know. Thinking about it, it makes sense. If something is not\
      \ visible, then the client probably does not need to know about it. If it's\
      \ a player on the other side of CTF-LavaGiant, what use does this client have\
      \ for it? Or if it's an invisible pathnode used for Bot AI, the client also\
      \ has no use for it. Sending data and variables for such actors would be wasteful\
      \ on a tiny little 28.8 kbps modem.\n\nWorking this discussion into a guideline\
      \ for your own code, you should set your actors' bAlwaysRelevant to true if\
      \ they are data storage units that the client needs to know about, like PlayerReplicationInfo\
      \ or GameReplicationInfo. Things like PlayerReplicationInfo, which store information\
      \ about the player, are always relevant. This allows a client to view the Scoreboard\
      \ and see the information (name, score, ping, packetloss, etc) for everyone\
      \ in the level, regardless of whether that player actor is relevant to the client.\
      \ PlayerReplicationInfo's allow precious information that's small, bandwidth\
      \ wise, to be relevant and replicated to each client, yet have information like\
      \ the location, velocity, weapon, animations, etc of the player to not be replicated\
      \ when it's not necessary (because it's in the Pawn/PlayerPawn, which is not\
      \ always relevant.) Hopefully I've not lost you here. It's an important thing\
      \ to know and remember about Unreal replication. Where to put your variables,\
      \ and how to make them relevant to the client. If you needed some important\
      \ game information to be seen by all clients, your best bet would be to subclass\
      \ ReplicationInfo and utilize that for your data variables. Information that\
      \ is only needed when it's seen is best put in regular actors, that will go\
      \ in and out of relevancy as time passes.\n\nIn a nutshell, if the client needs\
      \ to know about it, they will. All inventory is relevant to the client, as is\
      \ all nearby players. All projectiles and weapon effects that are visible are\
      \ relelvant. Anything that affects the player's world on the client, will be\
      \ replicated. This includes things that block the player's movement, or actors\
      \ that play ambient music. There is an overhead to spawning a new actor in netplay,\
      \ and so UT does not immediately remove an actor from the relevancy list when\
      \ it goes out of view. It gives it a few seconds before it is really considered\
      \ not relevant. Oh, and UT takes into account the fact that a player may be\
      \ viewing through another actor's eyes, as in the case of the GuidedWarhead,\
      \ or the teammate views when you hit the number keys on the right side of your\
      \ keyboard.\n\n== NetPriorities ==\n\nWhile that's the \"simple\" description,\
      \ figuring out why things happen can get a bit more complicated. Unreal Tournament\
      \ gives different priorities for different types of actors. NetPriority, which\
      \ should typically be between 1 and 3, determines how to prioritize a given\
      \ actor's bandwidth \"allocation\" in the stream being sent to each client.\
      \ Actors are first sorted by a calculation based upon their priority (adjusted\
      \ to take into account how close the client is looking at them, etc.) Actors\
      \ marked bNetOptional are sent to the bottom of the list. So....actors with\
      \ a higher priority are sent first in the bandwidth stream, and when the connection\
      \ becomes saturated, any remaining actors are starved of bandwidth until later.\
      \ (UT remembers which actors have not been replicated, and so it can give bNetOptional\
      \ actors 150 ms to get replicated before they are discarded. See the above relevancy\
      \ list for more information.)\n\nHere's a wide and almost complete sampling\
      \ of UT's NetPriorities:\n\n{|\n|Bots\n|3.0\n|-\n|PlayerPawns\n|3.0\n|-\n|GuidedRedeemer\n\
      |3.0\n|-\n|Movers\n|2.7\n|-\n|Projectiles\n|2.5\n|-\n|Carcasses\n|2.5\n|-\n\
      |Other Pawns (Spectators, Titans, Bunny Rabbits, etc)\n|2.0 \n|-\n|Effects (sparks,\
      \ blood, smoke)\n|2.0 \n|-\n|Simpler effects (shell casings)\n|1.4 \n|-\n|Inventory\n\
      |1.4 or 2.5\n|-\n|Everything else\n|1.0\n|}\n\nThis shows that the server considers\
      \ a Player's (be it bot or playerpawn) information to be much more important\
      \ than something like bullet casings from a gun. And it makes sense. A guided\
      \ redeemer also has unpredictability to it, since it is controlled by a player,\
      \ and thus needs a higher NetPriority. A projectile follows the simple Physics\
      \ given to it, eg: PHYS_Falling, PHYS_Projectile, and so they are not very unpredictable.\
      \ Thus, its NetPriority is not as high as a player's. However, projectiles are\
      \ still quite important to gameplay (doesn't it suck to get hit by that rocket\
      \ you never saw? :), and they get a high NetPriority. It's the same with the\
      \ carcasses, since their animations as they fly through the air or fall to the\
      \ ground are quite important (not to gameplay, but to that touchy-feel-good\
      \ feeling when you kill someone.) You should use these examples as a guide when\
      \ creating your own actors that need a different priority.\n\nOne additional\
      \ thing to note is that you can change the NetPriority on the fly. This is done\
      \ with Inventory, for example. It exists as 1.4 for most of its life, but when\
      \ it is thrown from a player's inventory, it now is a moving actor with more\
      \ importance attached to it. It is then given a higher NetPriority. Once it\
      \ hits the ground, it gets a NetPriority of 1.4 again, since it does not need\
      \ to be updated as often when it is sitting stationary on the ground.\n\nIn\
      \ general, all of the relevant actors for a particular client are put in an\
      \ array each tick, and then sorted by their priorities. The server then starts\
      \ replication the actors, starting with the highest NetPrioritized actor, working\
      \ it's way down. UT then stops replicating actors when the bandwidth becomes\
      \ saturated. That's why it's important to prioritize your actors correctly,\
      \ so that when a lot of actors are on screen, or on the lowly 28.8K connections,\
      \ UT will know how to perform triage, and who to starve of bandwidth first.\
      \ If an actor is not replicated, the variables it was supposed to tell the client\
      \ about are not forgotten. They will be put on the list during the next tick,\
      \ to have another go at getting replicated. Note that doubling the size of the\
      \ actor's NetPriority does not actually change anything in regards to giving\
      \ it more bandwidth, since a NetPriority only has meaning in relation to other\
      \ NetPriorities. Since 3.0 is the highest on the list, there is no real difference\
      \ between giving your actor a NetPriority of 4.0 and 4000.0, since they will\
      \ both be placed at the top of the list.\n\n== Roles and RemoteRoles Introduction\
      \ ==\n\nNow is a good a time as any to explain the purposes of the various roles\
      \ in Unreal. Roles simply guide UT in determining what role this particular\
      \ actor plays in the game of replication. For example, a player needs to be\
      \ replicated quite differently from an ammo box sitting on the ground, or a\
      \ projectile moving according to the rules of physics. On a server, the Role\
      \ will be ROLE_Authority, which makes sense since that actor is currently being\
      \ evaluated on the authoritative server. The RemoteRole of that actor will be\
      \ set to any of a variety of roles, defined below. On the client, the Role and\
      \ RemoteRole will be reversed. On the client, the RemoteRole will be ROLE_Authority,\
      \ and the Role will be one of the other role types. Let's go through the various\
      \ roles (which will be set in the RemoteRole default properties), in order of\
      \ increasing 'control.'\n\n;ROLE_None\n:This role is probably the simplest.\
      \ It simply tells the server not to make this actor relevant to the client.\
      \ No information will be sent about it, and it will exist where it was created\
      \ only. If it was created on both the client and the server (via a simulated\
      \ function, described later), and given a Role of ROLE_None, then it would exist\
      \ both on the server and on the client, and they would both operate independently\
      \ of each other. \n;ROLE_DumbProxy\n:This role is used for objects that don't\
      \ move much, yet still need information about them updated to the client. The\
      \ server does this by sending periodic updates about this actor's location and\
      \ velocity to the client. If the actor has any sort of logic to it, with Physics,\
      \ for example, it's much better to use the following role. \n;ROLE_SimulatedProxy\n\
      :This is used for anything that should be simulated over the network, via prediction.\
      \ Take a rocket, for example. It always travels in a straight line, and is an\
      \ ideal candidate for SimulatedProxy. By the same token, UT can predict the\
      \ falling physics clientside, and so grenades, and falling people are also good\
      \ candidates for this role. Anything that can be predicted clientside because\
      \ of Physics or clientside physics should use this Role. All Bots and PlayerPawns\
      \ use this role as well, since when a player is running, he's more than likely\
      \ to continue to run. It's the best prediction method that can be used for unpredictable\
      \ players. The only exception to this is the playerpawn you yourself are playing\
      \ as. \n;ROLE_AutonomousProxy\n:This is used for you. When you play online,\
      \ you yourself should be treated differently from all other playerpawns. You\
      \ don't want your own self being predicted based upon the server's expectations.\
      \ Rather, you want to control yourself and tell the server where you are moving.\
      \ With this Role, that's easily possible. Many things that should only be done\
      \ for your own playerpawn, like server-corrections of your location when you\
      \ get lagged out, are only done with this role. \n;ROLE_Authority\n:This role\
      \ is different from the others in that it is always the Role on the server.\
      \ On the server, all Roles will be ROLE_Authority, and the RemoteRole will be\
      \ one of the above. On the client, the reverse will be true. This role doesn't\
      \ have any real significance, beyond it's use in replication statements, described\
      \ below. \n\n== General Replication ==\n\nFor each actor that is deemed to be\
      \ relevant to a particular client, the server needs to determine what subset\
      \ of its variables will be sent to the client. The most obvious rule is to only\
      \ send variables if they change. Unfortunately, that rule alone is not enough\
      \ to fit data over a modem. Instead, the server has to further whittle down\
      \ its list of variables, and it does this through replication statements. These\
      \ replication statements are executed for each client, for each relevant actor\
      \ to that client. When a subset of the variables of a subset of the actors are\
      \ sent over the network, only then can it be fit on a regular modem. But how\
      \ can a client operate without all of the information in the game? Once you\
      \ stop and think about it, it's not quite that unthinkable. Do all of a Bot's\
      \ AI variables need to be replicated to the client? Only the result of the AI\
      \ needs to be sent, which basically consists of the same thing for any other\
      \ Pawn in the game. Also, depending upon the RemoteRole, different things are\
      \ replicated. Some cause the Location to be updated periodically as a poor man's\
      \ simulation of its motion, while another role causes the physics to be replicated,\
      \ and the location not to be, creating true client-side simulation of the actor's\
      \ motion.\n\n=== No Recursive Relevancy ===\n\nPlease note one important point\
      \ that can easily be overlooked. Relevancy is not recursive with replicated\
      \ references to variables. Let's say that Actor A contains a reference to Actor\
      \ B in Property C, and Actor A replicates Property C (currently set to Actor\
      \ B). Let's also say that Actor A is relevant, and Actor B is not. (Don't worry,\
      \ there's only three letters in this example.) In this example, Actor A is relevant,\
      \ and so it's Property C variable will be replicated to the client. Now what\
      \ does the client know? The client knows about Actor B through Actor A's reference,\
      \ but Actor B is not relevant. All of Actor B's variables are not checked for\
      \ replication. The client only knows about Actor B, which really is of no use\
      \ whatsoever, since the variables are not replicated. I initially thought that\
      \ replicated variables to actors caused those actors to be relevant and parsed\
      \ themselves for replicated variables, but that view is false. An actor can\
      \ only be relevant according to the rules stated above, which make no provision\
      \ for a reliable reference to them from a relevant actor.\n\n=== Replication\
      \ Checks ===\n\nWhen you think about the number of clients in a server, and\
      \ the number of relevant actors for each client, and the number of replication\
      \ checks on variables for each actor, there's a large number of such checks.\
      \ Special care should be taken when implementing replication statements. As\
      \ each conditional is evaluated, you should be considerate of the server's limited\
      \ processing ability. Don't call functions from within replication statements,\
      \ as function calls are much too slow for replication statements. Along the\
      \ same lines, you should try to keep your checks as simple as possible, only\
      \ evaluating a condition if its necessary. Finally, note that Epic had a problem\
      \ with replication checks taking too long for some important actors like Actor\
      \ or Inventory, both of which replicate many variables. To alleviate the situation\
      \ on servers, Epic moved the checks to native code. That's why you will see\
      \ the 'nativereplication' on a few of the Engine classes. Any variables being\
      \ evaluated in those classes will be covered by the nativereplication code,\
      \ making any UnrealScript replication statements useless in that class, (except\
      \ as a form of documentation for UnrealScript programmers.) Any variables that\
      \ are not defined in a nativereplication class, (defined in a non-nativereplication\
      \ subclass or superclass,) will be replicated via the unrealscript definitions.\
      \ Despite the fact that the nativereplication checks are in C++, the UnrealScript\
      \ checks that remain in those classes are still accurate, and a good guide to\
      \ go by in determining problems with replication, and ways around it.\n\n===\
      \ Special Replication Variables ===\n\nWhen writing replication conditionals,\
      \ there are a few things you should be aware of. During replication, a few helpful\
      \ variables are set for your use in evaluating whether it should be replicated.\
      \ These variables are defined in actor, and are:\n\n;bNetInitial\n:true if this\
      \ is the first time this actor is being replicated across the network. Useful\
      \ for variables that differ from the defaultproperties, yet will not change\
      \ over the life of the actor. \n;bNetOwner\n:true if the player we are replicating\
      \ to owns this actor directly. \n;bSimulatedPawn\n:true if the actor is a pawn\
      \ (or a pawn subclass) with Role == ROLE_SimulatedProxy. In other words, true\
      \ if it's a pawn that's not the client. \n;bDemoRecording\n;bClientDemoRecording\n\
      ;bClientDemoNetFunc\n:used for demo recording purposes. \n;bNetRelevant\n;bNetSee\n\
      ;bNetHear\n;bNetFeel\n:Not used anymore, never even set. \n\n=== NetUpdateFrequency\
      \ ===\n\nNetUpdateFrequency is another variable useful in replication. It effectively\
      \ causes an otherwise relevant (not useful when the actor is not relevant) actor\
      \ to be relevant NetUpdateFrequency times per second. This is useful when the\
      \ data changes frequently but you only want periodic updates. For example, PlayerReplicationInfo\
      \ contains a lot of data about the client. Stuff like the various player's pings\
      \ may change quite frequently, and having the client keep track of such information\
      \ would be quite a network hog. But since PlayerReplicationInfo has a NetUpdateFrequency\
      \ of 2, it is only updated twice a second, which is much nicer for that player's\
      \ bandwidth. The list of the current NetUpdateFrequency's for all UT classes\
      \ are listed below:\n\n{|\n| Actor\n| 100 Hz\n|-\n| ZoneInfo\t\n| 4 Hz\n|-\n\
      | GameReplicationInfo\n| 4 Hz\n|-\n| PlayerReplicationInfo\n| 2 Hz\n|-\n| Inventory\n\
      | 8 Hz\n|}\n\n=== Reliable versus Unreliable ===\n\nAnother optimization used\
      \ in networking is the difference between Reliable and Unreliable data. In the\
      \ case of variables, all data is reliable. It is all guaranteed to reach the\
      \ client, even if it arrives in the wrong order. (Pawns however, have code that\
      \ prevent them from appearing jumpy, although the effects of this can still\
      \ be seen at times when the player bounces back and forth in a somewhat laggy\
      \ game.....location updates are being received out of order.) Functions however,\
      \ exist in both reliable and unreliable forms. A reliable function, like reliable\
      \ data, is guaranteed to reach the client. An unreliable function however, is\
      \ sent to the client, but it is not guaranteed of reaching the client. Something\
      \ that sends messages to the client, like BroadcastMessage or BroadcastLocalizedMessage,\
      \ are reliable to ensure that the client gets the message. Something like a\
      \ client's update to the server about its position need not be reliable, however.\
      \ Since the client sends these update requests to the server every single tick\
      \ (in ServerMove, if you're wondering), it does not matter if they all reach\
      \ the server. And since each update is timestamped, the server knows which ones\
      \ to regard because they are out of order or lagged. And so, the server can\
      \ be assured of getting updates from the client, while not requiring that they\
      \ ALL be sent. A reliable function is repeatedly sent over the network until\
      \ the client acknowledges it. This can lead to a one second delay or more if\
      \ it has to try to send the message once or twice. Since you don't want to bog\
      \ down the network connection with reliable updates about where the client is\
      \ looking or moving, unreliable is best in this situation since the server only\
      \ needs to get \"most\" of them to work great.\n\n=== Writing Replication Statements\
      \ ===\n\nThere are a few useful things to know about when writing your own replication\
      \ statements. First, you cannot override replication statements. If a replication\
      \ statement exists in a parent in regards to Location, Velocity, some function,\
      \ or another variable you want to change the conditions for...you can't. Sorry.\
      \ Instead, you have to mold your actor into fitting the requirements so that\
      \ it's property or function will be replicated. Usually you can accomplish this\
      \ by setting a variable or two (you can't set the \"const\" ones which are set\
      \ natively of course), or by fiddling with the RemoteRole until it matches up.\
      \ However, don't go around doing that blindly, or you're sure never to succeed.\
      \ Instead, keep reading, and you will discover (hopefully, if I do it right\
      \ :), exactly what each of the Roles are for, and what side effects they cause.\
      \ Next, keep them simple. We already discussed the importance of not doing anything\
      \ overly complicated, and that rule should be adhered to. Second, use the bNet*\
      \ variables if possible. These variables, like bNetInitial, bNetOwner, bSimulatedPawn\
      \ are quite useful, and are gratis. There is no additional CPU requirement to\
      \ use these variables, as they are set for you automatically. Another very important\
      \ thing to hinge your variables on is the Role and RemoteRole. \"if (Role ==\
      \ ROLE_Authority)\" would cause that variable/function to be replicated from\
      \ the server (where the Role equals ROLE_Authority) to the client. Something\
      \ like: \"if (Role < ROLE_Authority)\" would cause the variable to be replicated\
      \ from the client (where the Role is less powerful than ROLE_Authority) to the\
      \ server. Checks can also be performed to do various things depending upon if\
      \ the Role/RemoteRole is a SimulatedProxy or a DumbProxy. The best place to\
      \ find examples of these more intricate checks is in the Engine classes, particularly\
      \ Actor, Pawn, and PlayerPawn. It should also go without saying that you should\
      \ not change anything in a replication statement. Doing i++ in a replication\
      \ statement causes i to change unpredictably as it is being replicated, which\
      \ is not something you really want to do. And finally, as the last word advice,\
      \ the server checks all incoming data to be sure it is legitimate. If the client\
      \ replicates something (a variable or a function) to the server, the server\
      \ will exchange the Role and RemoteRole variables temporarily, and evaluate\
      \ the replication condition to see if the other end had a legitimate reason\
      \ for sending that data. If the check fails, then the data (variable or function\
      \ call) is discarded. That means that when you are writing replication statements,\
      \ make sure that the server also has all the data needed to perform the replication\
      \ check. Otherwise, it will never be processed or accepted by the server.\n\n\
      == Variable Replication ==\n\nVariables are one type of data that can be sent\
      \ through replication statements. The other is function calls (RPC, if that\
      \ helps). Here, we'll be discussing how data is replicated from the server to\
      \ the client, and vice versa. There's a lot of little things that server to\
      \ complicate it more than the replication described above. As I already stated\
      \ above, all variables are considered reliable, so the unreliable versus reliable\
      \ discussion is irrelevant here.\n\n=== Newly Relevant Actors (Spawning) ===\n\
      \nWhen an actor becomes relevant to a client, it is spawned on the client, with\
      \ all the defaultproperties of the actor. If the server set variables immediately\
      \ after the spawning of the actor, (before the relevancy checks), then those\
      \ variables will be sent to the client as an 'addendum' of sorts, assuming those\
      \ variables meet the replication statements. The server will send any variables\
      \ that differ from the defaultproperties. Things can get hairy though, when\
      \ the server has a different idea of an actor's defaultproperties than the client\
      \ does. Initially, the defaultproperties on the server should match up with\
      \ what the client has. If a defaultproperty is changed on the server, that change\
      \ is not replicated to the client. You must change it in a simulated function\
      \ in order for that to occur. However, what happens if the actor becomes irrelevant?\
      \ In that case, bad things happen. When the actor becomes relevant again, the\
      \ default spawned actor on the client will have different defaultproperties\
      \ from the server. When the server then proceeds to perform the checks on what\
      \ to replicate, it sees that the default var is the same as that var, and so\
      \ that var is not replicated. The client then never gets data, and so has the\
      \ REAL default variable, of a fresh actor. That variable can be incorrect, and\
      \ cause strange behavior to occur.\n\nAs an example, for a particular class-based\
      \ mod, a programmer (not me, this time ;-) had set both the Mesh and Default.Mesh\
      \ to the playerclass that the player had chosen. Players however, go in and\
      \ out of scope, to save on network bandwidth. Normally they are only relevant\
      \ when you can see them, and for about three seconds once them disappear from\
      \ view. Let's say the player changed their playerclass at that point. Or say\
      \ they changed their class at the start of the game while the round has not\
      \ started and they are invisible, and thus not relevant. When they did become\
      \ relevant to the client, because they turned a corner, or because the round\
      \ just started and they are spawned and made visible, the Mesh == Default.Mesh,\
      \ and so the Mesh is never replicated. The skin however, was still replicated\
      \ normally. To clients in the game, they saw the player as the original mesh,\
      \ with a inappropriate skin that was intended for another model. Like I said,\
      \ strange behavior, that can be hard to trace down. The way to handle this,\
      \ is to not set the Default variables unless you are really know what you are\
      \ doing. Just setting the Default.Mesh because it feels right will only cause\
      \ problems. In this case, the Default.Mesh was not needed for everything, and\
      \ removing that assignment caused everything to work fine.\n\n=== A Time for\
      \ Replication ===\n\nReplicated variables are only replicated at the end of\
      \ each tick. That means that if you change the variable repeatedly during a\
      \ loop, or some other block of code, only the final value will be replicated.\
      \ If you change a variable many times during a tick, and change it back to its\
      \ original value when the tick completes, then no variable change will have\
      \ been seen, and no network bandwidth will have been spent.\n\n=== Client-Server\
      \ Replication ===\n\nAnother quirk to be aware of is that client-server replication\
      \ exists ONLY for your own playerpawn. That means that if you want a variable\
      \ replicated from the client to the server, it needs to be done in your current\
      \ PlayerPawn (or one of its parent classes). (You can use function replication\
      \ to get around this limitation however.) Other playerpawns in the level are\
      \ not the one that you currently 'possess', so their variables will not be replicated\
      \ to the server. Just be aware of that when trying to replicate your variables\
      \ and they aren't working. :) Thinking about it, it makes sense. What right\
      \ does the client have to send any information to the server about another playerpawn,\
      \ or some inventory item? The client is only concerned with variable changes\
      \ that the player himself (or herself) makes, and thus those are the only ones\
      \ that are sent to the server.\n\n=== Replication Only When Necessary ===\n\n\
      Further optimizations exist for variable replications as well. A variable will\
      \ only be replicated if the server thinks the client has the incorrect version\
      \ compared to the server's latest version. This usually happens when the server\
      \ changes a variable, and it knows the clients do not know about such a change.\
      \ (They would if the function that changed them was simulated and was called\
      \ clientside, meaning that you technically would not need to replicate that\
      \ variable. This is explained later.. :) This means your code can change stuff\
      \ clientside, and it will not be written over by server-side data until the\
      \ server's data changes. As an example, I used this technique to implement a\
      \ simple little static LOD back in the Unreal days before Epic introduced their\
      \ realtime LOD. The client determined how far away the player was, and switched\
      \ in variously detailed models depending on the distance. This allowed more\
      \ models onscreen at once. And in multiplayer games, the client could change\
      \ the mesh to the various LOD meshes, and it would work fine. Since the server\
      \ never saw a change in the server's mesh (assuming it was a dedicated server),\
      \ the client could change the LOD mesh without any problems. When the server\
      \ did change the mesh however, the client would get a new mesh variable sent\
      \ to it, and so it would have to then change it again. As a bragging aside,\
      \ it even modified the intensity at which is applied LOD depending upon the\
      \ framerate. ;)\n\n=== Replication Data Approximation ===\n\nAnother optimization\
      \ is that of how Unreal sends vectors, rotators, and arrays across the internet.\
      \ The rules for this can best be described from the Unreal Tech page's Networking\
      \ document, and I've copied it here to keep it in context:\n\n*Vectors and Rotators:\
      \ To improve bandwidth efficiency, Unreal reduces the accuracy of vectors and\
      \ rotators slightly, a process known as quantizing. The X, Y, Z components of\
      \ vectors are converted to 16-bit signed integers before being sent, thus any\
      \ fractional values or values out of the range -32768..32767 are lost. The Pitch,\
      \ Yaw, Roll components of vectors are converted to bytes, of the form (Pitch8)&255.\
      \ So, you need to be careful with vectors and rotators. If you absolutely must\
      \ have full precision, then use int or float variables for the individual components;\
      \ all other data types are sent with their complete precision.\n*General structs\
      \ are replicated by sending all of their components. A struct is sent as an\
      \ \"all or nothing\" type of thing.\n*Arrays of variables can be replicated,\
      \ but only of the size of the array (in bytes) is less than 448 bytes.\n*Arrays\
      \ are replicated efficiently; if a single element of a large array changes,\
      \ only that element is sent. \n\n== Variable Replication Examples ==\n\nNow\
      \ would probably be a good time to go through some important examples of replication\
      \ and how it is used with variables, to give you a better idea of how things\
      \ work, and to help give examples for your own adventures in coding.\n\nLet's\
      \ take a few examples, and describe exactly what they do. We'll start off with\
      \ the easy ones, and gradually work our way up in complexity. The following\
      \ examples are all taken from Actor, unless specified otherwise.\n\nIn PlayerPawn:\n\
      \n<uscript>\nreliable if ( Role < ROLE_Authority )\n\t\tPassword, bReadyToPlay;\n\
      </uscript>\n\nThis here shows where your Password is sent to the server, when\
      \ trying to join passworded servers, or to log in as an admin to that server.\
      \ The server needs your password in order to validate it, and this code sends\
      \ it to the server. Let's evaluate this check both on the server and on the\
      \ client. Server: On the server, Role == ROLE_Authority. Looking at the conditional,\
      \ it can easily be shown to be false, and so the Password is not replicated\
      \ server-side. This means that the server does not send the Password to the\
      \ other end of the connection. Client: Since on the client, the Role is not\
      \ ROLE_Authority (remember it's only Authority on the server itself), this replication\
      \ check evaluations to true on the client. And since variable replication only\
      \ works in your current PlayerPawn, it will be sent to the server for yourself\
      \ alone. (It makes sense not to send others' passwords, doesn't it? ;) \n\n\
      This also shows how bReadyToPlay, which is used in Tournament style games, where\
      \ everyone has to click to start the game. Note that this is only sent for yourself,\
      \ since the client can only replicate variables to the server if they are part\
      \ of it's own playerpawn actor. \n\n<uscript>\nunreliable if( Role == ROLE_Authority\
      \ )\n\t\tOwner, Role, RemoteRole;\n</uscript>\n\nThis ensures that the owner\
      \ of an object is always replicated to the client. Remember that the owner's\
      \ variables themselves are not replicated, (because there is no recursive replication,)\
      \ but the actor itself is. This means that simple comparisons \"if (PlayerPawn\
      \ == Owner)\" will work fine because the reference to the Owner is replicated\
      \ to the client. Remember that the unreliable versus reliable makes no difference\
      \ in UT, as they are both treated equivilently. They may have had an effect\
      \ at sone point during the Unreal 1 days, but they no longer play a factor in\
      \ development. Don't let that confuse you. \n\nReplicating Role and RemoteRole\
      \ may seem strange at first, since they should be reversed on the client. However,\
      \ there's native code that causes that switch to be made. On the client, it\
      \ will ensure that those two variables are reversed, so that RemoteRole is ROLE_Authority.\
      \ You may wonder why they are even replicated in the first place. While the\
      \ client never has any direct use for these variables in the code, there is\
      \ one easy-to-overlook place where they are vitally important: Replication Statements.\
      \ When the client is evaluating whether it needs to replicate a certain function\
      \ call to the server, or a playerpawn's variable to the server, the client needs\
      \ accurate copies of what Role and RemoteRole are. Without those, it would be\
      \ unable to make the necessary decisions on what to send to the server. And\
      \ since the server checks the validity of the replication data sent to the server\
      \ with Role/RemoteRole, the client needs the latest copy in order to successfully\
      \ replicate that data. \n\n<uscript>\nunreliable if( bNetOwner && Role == ROLE_Authority\
      \ )\n\t\tbNetOwner, Inventory;\n</uscript>\n\nInventory is the head of the linked\
      \ list that lists the entire Inventory for the Actor (usually only utilized\
      \ with Pawn and PlayerPawn). We want the inventory to be replicated to the client,\
      \ so that he knows what Inventory he has, to display on his HUD, and stuff (makes\
      \ sense, right?). Simply replicating the head of a linked list (where each object\
      \ points to the next in the list) is not enough however. Each actor must itself\
      \ be relevant (satisfied by the criterion that it must be owned by the current\
      \ playerpawn), and each link itself must be replicated. And since Inventory\
      \ subclass Actor somewhere in the chain, Inventory also has a replicated Inventory\
      \ variable. And that's how you are able to see your Inventory client-side. And\
      \ since I don't need to know the full Inventory list of what every other player\
      \ in the game has (the current weapon and the shieldbelt effect are transferred\
      \ via other means), the Inventory will only be replicated if the client is the\
      \ owner. \n\nThe other variable in the above replication statement is bNetOwner.\
      \ Since this is set natively on both the client and server, this variable does\
      \ not need to be replicated. It could be argued that it adds a tiny amount to\
      \ bandwidth, but its effect is probably negligible. Perhaps it will be removed\
      \ in a future patch. \n\n<uscript>\nunreliable if( DrawType == DT_Mesh && Role\
      \ == ROLE_Authority )\n\t\tMesh, PrePivot, bMeshEnviroMap, Skin, MultiSkins,\
      \ Fatness, AmbientGlow, ScaleGlow, bUnlit;\n</uscript>\n\nHere we see that all\
      \ these mesh-specific variables are ONLY replicated if this actor is currently\
      \ being displayed as a mesh. If it's a sprite, or a brush, or even no drawtype\
      \ at all, there is no reason to send these variables. \n\nNow let's get into\
      \ some of the more complex variable replication statements... \n\n<uscript>\n\
      unreliable if( RemoteRole == ROLE_SimulatedProxy )\n\t\tBase;\n</uscript>\n\n\
      Here we see a slightly more complex replication statement, that does not involve\
      \ Role == ROLE_Authority. Here we see that the current Base (set via SetBase)\
      \ is only replicated if the actor is set to be a simulated proxy. If you set\
      \ the actor to a DumbProxy, you'll see no Base change clientside, and instead\
      \ will get the jerky Location updates that the server sends to you, (more on\
      \ this later). So if you are using SetBase, make sure it's a SimulatedProxy,\
      \ or if it's not a SimulatedProxy, use something other than SetBase. :) Or if\
      \ you need both SetBase and a SimulatedProxy, the Base will not be replicated\
      \ for you. You'll have to work out some other mechanism to do that, probably\
      \ a simulated function that sets the base, so it is run on the client, (more\
      \ on this later, too.) You might still have troubles when the actor gets its\
      \ simulated function called while the actor was not relevant. This results in\
      \ the simulated function never being called clientside, and then when the actor\
      \ does finally become relevant, it's as if that function was never called (and\
      \ the base isn't set), which will result in those things affectionately referred\
      \ to as 'bugs.' You can make the actor being attached (and what it's being attached\
      \ to) bAlwaysRelevant so that the simulated functions will always be called,\
      \ but that might be a bit too harsh on network bandwidth. :) \n\n<uscript>\n\
      unreliable if( RemoteRole == ROLE_SimulatedProxy && Physics == PHYS_Rotating\
      \ && bNetInitial )\n\t\tbFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation;\n\
      </uscript>\n\nThis one is still relatively easy, but it's getting more complex.\
      \ Here we have similar logic to what was seen above, with the server only sending\
      \ these variables to the client if the client is a SimulatedProxy. However,\
      \ since all these variables apply ONLY to PHYS_Rotating, there is no need to\
      \ replicate these variables to the client if the client is not using PHYS_Rotating.\
      \ And finally, a very important clause at the end is the bNetInitial one. This\
      \ states that these variables will only be replicated to the client when it\
      \ is being replicated for the first time. \n\n<uscript>\nunreliable if( bSimFall\
      \ || (RemoteRole == ROLE_SimulatedProxy && bNetInitial && !bSimulatedPawn) )\n\
      \t\tPhysics, Acceleration, bBounce;\n</uscript>\n\nHere we have some of the\
      \ interesting variables replicated. We see that if the bSimFall is set to true,\
      \ it will replicate the Physics to the client. This is used when tossing weapons\
      \ from your inventory. When they are tossed, they require a Physics change from\
      \ PHYS_None while sitting in your Inventory to PHYS_Falling as they fly through\
      \ the air. The then get set back to PHYS_None when they land on the ground.\
      \ All these Physics changes are accomplished by setting bSimFall at the key\
      \ points during the TournamentWeapon's life. It is set to true when it is thrown\
      \ from the inventory, to capture the change, and left on until it hits the ground,\
      \ where it changes Physics again. After it finally hits and has its physics\
      \ reset, bSimFall is set to false so no further Physics changes occur. Looking\
      \ at the second half of the statement, we see that the Physics is replicated\
      \ ONLY if it's a SimulatedProxy, it's the first time this actor is being replicated\
      \ over the internet, AND it's not a simulated pawn. The bSimulatedPawn variable\
      \ is set to true if it's a Pawn with a RemoteRole of ROLE_SimulatedProxy (who\
      \ would have thought? :) This means any changes to the Physics of a SimulatedProxy\
      \ non-pawn actor before it is replicated will be replicated to the client. The\
      \ Physics are never replicated for pawns. Rather, the code for their physics\
      \ is hard-wired into the code to cause them to be pushed to the ground. Basically,\
      \ when a pawn jumps, the server sets his vertical velocity so that he travels\
      \ upwards. That Velocity is then replicated to the client (described below).\
      \ The client then checks if the pawn is a player (eg: a bot or a playerpawn),\
      \ that they are currently unable to fly (set via the Pawn's bCanFly variable),\
      \ and that they are not in a water zone (since that involves different gravities\
      \ and physics). So in fact, the Physics for a pawn is never replicated to the\
      \ client, it only appears to do so. If you are attempting to create alternate\
      \ physics with the playerpawn, you will need to ensure that you set bCanFly\
      \ to true so that the native code does not enforce the falling Physics upon\
      \ the player when he's on the wall or in the air. You must then implement the\
      \ alternate means of transportation yourself. \n\n<uscript>\nunreliable if(\
      \ !bCarriedItem && (bNetInitial || bSimulatedPawn || RemoteRole < ROLE_SimulatedProxy)\
      \ && Role == ROLE_Authority )\n\t\tLocation;\n</uscript>\n\nHere we see another\
      \ important variable, Location, and it's replication. We see that it is not\
      \ replicated for carried items. This is useful in the case of Inventory. When\
      \ a player is carrying it, there's no reason its location should be replicated,\
      \ since it isn't used for anything. replicating a player's entire inventory\
      \ would be quite the strain on network bandwidth. Let's look at the next section\
      \ of the statement. The location is replicated if this is the first time the\
      \ actor is being replicated (assuming the other parts of the conditional are\
      \ true). This is very useful, since all pawns will be spawned in different locations\
      \ when you enter the game, and rockets will need their start locations set when\
      \ they spawn out of a rocket launcher, etc. The location is also sent if this\
      \ is a bSimulatedPawn. This helps correct any errors that may occur in replicating\
      \ pawns. Since a pawn can change direction, and a client may not always know\
      \ about it (due to lag, etc), this location resetting is the only way in which\
      \ the locational updates can be 'corrected'. Note that this is not used to correct\
      \ your own location when you experience lag. When that happens, you are an AutonomousProxy,\
      \ and functions specific to PlayerPawn handle that (namely ClientAdjustPosition).\
      \ For example, PHYS_Walking is not like PHYS_Projectile, where the position\
      \ can be predicted with great accuracy. PHYS_Walking just means \"keep them\
      \ attached to the ground\", basically, The client's only updates (without location)\
      \ would have been their velocity, which can easily lead to errors in the player's\
      \ movements over any significant amount of time. This location is used as a\
      \ correcting factor, making sure the client's view does not straw too far from\
      \ where he expects the player to be, while at the same time keeping the velocity's\
      \ replication so he can be predicted inbetween server updates. The other option\
      \ for allowing the Location to replicate is that of where the RemoteRole is\
      \ less than a ROLE_SimulatedProxy, namely, a ROLE_DumbProxy, since the ROLE_None\
      \ prevents relevancy in the first place. DumbProxies get periodic updates from\
      \ the server every few ticks, and would create a jumpy effect in netplay. It\
      \ was the cause of a jerky puck in the hockey mod I attempted awhile ago, although\
      \ I knew nowhere near enough to fix it at the time. :) A SimulatedProxy would\
      \ not get sent Location updates, since it would be predicted through the use\
      \ of the Velocity and the current Physics. Since DumbProxies aren't simulated\
      \ client-side to achieve smoothness, they only get the Location updates. I'm\
      \ going to clear this all up after the examples of the various replicated variables.\
      \ \n\n<uscript>\nunreliable if( !bCarriedItem && (DrawType == DT_Mesh || DrawType\
      \ == DT_Brush) && (bNetInitial || bSimulatedPawn || RemoteRole < ROLE_SimulatedProxy)\
      \ && Role == ROLE_Authority )\n\t\tRotation;\n</uscript>\n\nHere we see another\
      \ important variable, Rotation. This also has the same !bCarriedItem clause,\
      \ for the same reasons as described above. The rotation is also only replicated\
      \ if this actor is a mesh or a brush. Since sprites always face the player,\
      \ replicating their rotation is useless. The bNetInitial also causes the rotation\
      \ to be replicated the first time through, (again, assuming if the other conditions\
      \ are true,) since rockets need to be facing in the right direction when it\
      \ has them flying through the air. Their velocity determines their direction\
      \ of movement, but the direction they are facing which is equally important,\
      \ is determined by their rotation. The rotation is replicated if they are a\
      \ simulated pawn (every playerpawn and bot in the level except your own self).\
      \ This is so you can see what direction the other people are facing. The ViewRotation\
      \ (which determines where the client is looking), is sent to the server via\
      \ ServerMove, where it is translated into a rotation. it is this rotation that\
      \ is then replicated to the clients. And finally, if it is a DumbProxy (the\
      \ only valid one less than SimulatedProxy), it also gets the rotation updates.\
      \ Rotation updates do not need any interpolating between updates like location\
      \ does. Location lag is much more noticeable when the player is moving quickly,\
      \ but you never really notice Rotation lag. Besides, there is no real way to\
      \ predict or forecast rotation. It depends entirely upon the other user's mouse.\
      \ \n\n<uscript>\nunreliable if( bSimFall || ((RemoteRole == ROLE_SimulatedProxy\
      \ && (bNetInitial || bSimulatedPawn)) || bIsMover) )\n\t\tVelocity;\n</uscript>\n\
      \nHere's one of the last important variables with a complex replication statement.\
      \ The velocity is replicated if it has bSimFall set, (used when throwing weapons\
      \ from your inventory). The PHYS_Falling alone isn't enough. It needs to know\
      \ exactly what it's initial velocity is when it is launched from the pawn. And\
      \ no, bNetInitial will not work here, since it's not the first time it's being\
      \ replicated. It's existed as a weapon for quite some time. It's just for the\
      \ initial velocity of when it's being thrown from the player that we want updates.\
      \ Moving along, we see that SimulatedProxies get their Velocities replicated\
      \ if it the first time on the replication channel, for newly spawned rockets,\
      \ or for grenades, or shock projectiles, etc. SimulatedProxies also get their\
      \ velocities replicated if they are a simulated pawn, as all the various pawns\
      \ need their velocities replicated so that they can be predicated locally. And\
      \ finally, movers get their velocities replicated, so that the client can accurately\
      \ predict the mover's movement locally. In the early Unreal 1 days, mover's\
      \ velocity was not replicated, and so the client got periodic update locations\
      \ because it was a DumbProxy. This resulted in very jumpy movers in netplay,\
      \ something that was fixed for Unreal 224+. \n\n<uscript>\nunreliable if( DrawType\
      \ == DT_Mesh && ((RemoteRole <= ROLE_SimulatedProxy && (!bNetOwner || !bClientAnim))\
      \ || bDemoRecording) )\n\t\tAnimSequence, SimAnim, AnimMinRate, bAnimNotify;\n\
      </uscript>\n\nThere are a few more variables here, all of which relate to animation.\
      \ These variables are only replicated if it is currently being drawn as a Mesh.\
      \ If we are recording a demo, then the animations are always sent. Otherwise,\
      \ it checks the somewhat confusing conditional. If the actor is a DumbProxy,\
      \ and the player is not the owner of this object, and bClientAnim is not set,\
      \ then it replicates the animation variables. In the case of weapons, you see\
      \ those animations clientside, and so the animation variables do not need to\
      \ be replicated from the server. That is because all TournamentWeapons have\
      \ the bClientAnim set to true, indicating that their animations are handled\
      \ clientside. If the animations are not handled clientside, and the actor is\
      \ a dumb proxy, then it will send them from the server. SimulatedProxies, which\
      \ include pawns and rockets and other projectiles, are all simulated proxies,\
      \ and so they do not receive animations from the server. Instead, the client\
      \ animates them with its client-side prediction. In the case of pawns, this\
      \ is handled internally in the engine (for another tutorial ;), and you need\
      \ not worry about it. \n\n== Role and RemoteRole Summary ==\n\nHopefully this\
      \ intricate look into some of the more complex and confusing variables has helped\
      \ you to grasp the concepts of replication some more, and realize many of the\
      \ differences between the various roles. However, with the above knowledge in\
      \ mind, I'd like to do a little re-cap, emphasizing the use of dumb, simulated,\
      \ and autonomous proxies, and help give you a clearer idea of when each should\
      \ be used.\n\n;ROLE_Authority\n:Again, this is the Role for all actors on the\
      \ server, and is the RemoteRole for all actors on the client. It basically means\
      \ that I'm the authority on this actor. This is the only one variable that Role\
      \ is set to, server-side. The remaining ones are all used for the RemoteRole\
      \ when on the server.\n;ROLE_None\n:This basically says: Never make this actor\
      \ relevant. This prevents replication conditions from even being run, and so\
      \ does not factor into any of the replication statements. \n;ROLE_DumbProxy\n\
      :This role is used for simple actors that require no real client-side prediction.\
      \ They don't need any Physics prediction, but they only need to be relevant\
      \ to the client to get their variables replicated. This is used for all Inventory\
      \ actors when they reside on the ground, which prevents any higher-bandwidth\
      \ SimulatedProxy stuff, but yet allows you to see all the stuff you need for\
      \ the inventory actor. If you do try to move this actor, the client will get\
      \ periodic updates, usually around every half-second or so on a regular connection.\
      \ This creates quite a jumpy effect if you are using DumbProxy with a particular\
      \ Physics type, since it really isn't intended for that. Rather, the Location\
      \ updates are useful for when moving the actor across the level with a flag\
      \ respawn, etc. The same is done with rotation updates, with periodic changes\
      \ coming in to the client every so often. This role also causes animation updates\
      \ to be sent from the server to the client, unless the client specifically tells\
      \ it not to. In summary, an actor with this role is force-fed data from the\
      \ server. It's intended for actor's that don't move (except in jumps like transportation,\
      \ respawn, etc), yet are still relevant. \n:'''Other quirks''': There's a few\
      \ quirks that can have a significant effect on your netplay development. DumbProxy\
      \ actors do not have a variety of events run clientside. Simulated Tick(), Timer(),\
      \ and state code, along with the physics calculations, are not performed on\
      \ the client of a DumbProxy actor. They are supposed to be a dumb proxy actor\
      \ that gets data sent over the net, and so these events are not called. One\
      \ exception to the above rule is that physics are performed clientside for DumbProxy\
      \ actors if the actor has a falling physics, which allows tossed weapons to\
      \ fall correctly in netplay. In an early attempt at the weapon in the tutorial\
      \ at the bottom of this document, I attempted to create a client-side physics\
      \ that would combine with the location and rotation updates that were inherently\
      \ sent via the DumbProxy role, but the client would not run my Tick()-based\
      \ physics calculations, and so that idea had to be thrown out the window. :)\n\
      ;ROLE_AutonomousProxy\n:This is used for things that the client directly controls.\
      \ In most cases, this will only be used by the playerpawn. This RemoteRole value\
      \ should only be set for the one particular player, and it should be a SimulatedProxy\
      \ for every other client in the game. The player for which it is AutonomousProxy\
      \ is the player possessing that particular PlayerPawn. When it is set to AutonomousProxy,\
      \ it appears to be a SimulatedProxy for everyone BUT the owner of the proxy\
      \ or the instigator. This ensures that your PlayerPawn looks like a SimulatedProxy\
      \ to everyone but yourself. Note that this technique is also used with the guided\
      \ redeemer, to ensure that it works the same way. Having the server tell you\
      \ where your guided redeemer is flying would not be appropriate. Rather, you\
      \ want to tell the server where your guided redeemer is. While AutonomousProxy\
      \ doesn't make this just 'work' for you, it does differentiate you from the\
      \ other people viewing your redeemer, which is what is needed to have it act\
      \ differently for you, compared to everyone else. \n;ROLE_SimulatedProxy\n:There\
      \ are two different things that can happen with this particular type. It depends\
      \ on whether the actor with this role is a pawn or not a pawn. I'll discuss\
      \ the latter first. \n;Non-Pawn ROLE_SimulatedProxy\n:This one is basically\
      \ the opposite of DumbProxy. It expects full client-side prediction of the actor,\
      \ given initial values. It's like extrapolating out a curve given some data,\
      \ where the current Physics is the curve fit, and you have initial data available\
      \ to extrapolate from. ROLE_SimulatedProxy gives you an initial Location, Rotation,\
      \ and Physics. It then keeps you updated with the Velocities, should they change.\
      \ These variables should enable the client to perform full client-side prediction\
      \ on this object, assuming it continues along the physics prediction. In the\
      \ case of PHYS_Falling and PHYS_Projectile, this is the case. There can be no\
      \ aberration form these behaviors, (unless you play around with the Physics\
      \ variables bBounce and such, which are very useful in prediction.) Perhaps\
      \ I'll explain Physics in more detail in another tutorial. Perhaps. ;) Finally,\
      \ for this role, you also get animation updates, assuming the client is not\
      \ the owner and it's not set for client-side animation. In summary, this Role\
      \ is for actors that smoothly predict their data on the client. \n;Pawn ROLE_SimulatedProxy\n\
      :When ROLE_SimulatedProxy is combined with Pawns, a different sort of simulated\
      \ proxy is created, that act differently in netplay. Pawns are one of the most\
      \ complex actors in terms of replication, because of their need for clientside\
      \ prediction, yet inherent unpredictability in their movement. There is no way\
      \ to duplicate this behavior except by subclassing pawn, so don't expect to\
      \ achieve it in your projectile subclass. A SimulatedPawn gets the best of dumbproxy\
      \ and simulatedproxy. It gets velocity updates for the clientside prediction,\
      \ while at the same time getting location updates from the server to 'readjust'\
      \ the player's locations. You might then wonder why the pawn does not jump when\
      \ a new location update comes in. Again, there is native code that causes the\
      \ actor to smoothly head towards the location given by the server if the location\
      \ position is too far off from the player's real position. This again ensures\
      \ seamless movement of players while keeping them accurate to the server's version.\
      \ All non-players will get by with velocity-only client-side prediction. No\
      \ physics will be taken into account for these pawns. This is because some non-players\
      \ can be PHYS_spider, or a variety of other physics that don't work with the\
      \ following always-walking/falling prediction. Only players (bots and playerpawns)\
      \ get the special client-side prediction to have falling/walking physics. This\
      \ physics is an assumed physics, which is accomplished by applying the zone's\
      \ gravity if the player is not on the ground. This logic will be bypassed if\
      \ the pawn's bCanFly variable is set, which frees it of the clientside physics,\
      \ but must be accounted for in your code, since there is no physics replication\
      \ in pawns. This logic is also bypassed if the pawn is in a water zone, which\
      \ also differs from the default walking/falling physics. In water zones, actors\
      \ are predicted using velocity alone, which is sufficient with the low amount\
      \ of gravity that exists in those zones. The actor's get their locations 'adjusted'\
      \ anyway, so it doesn't make any real difference in the long run. Finally, pawns\
      \ get rotation updates. Since rotation (which is directly based off the ViewRotation,\
      \ or the direction the player is looking) can change quite radically, no prediction\
      \ is done with it. Instead, the player's rotation is adjusted as new player\
      \ rotation information comes in from the client. Animation is handled the same\
      \ as any other non-pawn simulated proxy. \n\n== Function Replication, and Simulation\
      \ ==\n\nIn a network game, functions can be called on the server, on the client,\
      \ or on both. Sometimes you will want one situation, and sometimes you will\
      \ want another. Function replication and simulation both achieve different pieces\
      \ of these goals. Despite what may at first seem like two different topics of\
      \ discussion altogether, they are actually quite related at their root. I will\
      \ discuss them together, and then finish with a clarification of their differences\
      \ so that each can be understood clearly.\n\nInternally, the Unreal Engine uses\
      \ a very simple system for its function stuff. It calls a function to determine\
      \ if it can call an UnrealScript function on that machine. if it can, it does,\
      \ if it cannot, then it does not. That's all that simulation and replication\
      \ entails, and the only additions to this system are the origin of UnrealScript\
      \ simulation, events, (which will be discussed later), and the function replication\
      \ itself (much of which you know already.)\n\n=== Rep/Sim Function Rules ===\n\
      \nI will first present the basic simple rules to determine if a client or server\
      \ is able to execute the function locally. The following conditions will determine\
      \ whether that happens. Again, if a condition matches, then the checking stops\
      \ there, and it executes locally depending upon the resulting clause of that\
      \ condition.\n\n<ol> <!-- wiki list syntax doesn't support start attribute -->\n\
      <li>If it is a static function, it can be called on that machine.</li>\n<li>If\
      \ we're on a standalone server, it can be called on that machine.</li>\n<li>If\
      \ it's not a replicated function, then go to step 10. </li>\n</ol>\n(The rest\
      \ apply ONLY to replicated functions, per condition three.)\n<ol start=\"4\"\
      >\n<li>If we are the server, and there is no parent PlayerPawn to this actor,\
      \ (at any point in the parent hierarchy,) or if the player does not have a connection\
      \ (listen servers for the player on the server,) then it is executed locally.</li>\n\
      <li>If the replication condition is not met for the current machine, (meaning\
      \ that it was replicated to us, or that it is not a valid replication statement),\
      \ then go to step 10.</li>\n</ol>\n(The rest apply ONLY to replicated functions\
      \ where the replication condition is met, and it is a valid function to replicate.)\n\
      <ol start=\"6\">\n<li>If it is an unreliable function, and the connection (server-client\
      \ or client-server) is saturated, then 'pretend' it was executed remotely, (eg:\
      \ do not execute it locally.)</li>\n<li>Replicate the function, and then do\
      \ not execute it locally. </li>\n</ol>\nThis last step is only used if it is\
      \ called upon by the above steps.\n<ol style=\"list-style-type: latin;\">\n\
      <ol style=\"list-style-type: lower-roman;\">\n<li>If we are on the server, then\
      \ it can be called.</li>\n<li>If we are on the client as an AutonomousProxy,\
      \ it can be called locally.</li>\n<li>If we are on the client as a DumbProxy\
      \ or SimulatedProxy (NOT an AutonomousProxy,) and we are a simulated function,\
      \ then it can be called locally.</li>\n</ol></ol>\n\nWhile this may seem complex,\
      \ it accurately describes in every detail how Unreal does it's function handling,\
      \ and RPC (remote procedure call) nature. Hopefully, in the next paragraph or\
      \ two, I'll be able to simplify it into a few simple rules.\n\n=== Rep/Sim Function\
      \ Rules Restatement ===\n\nIn order for a function to be replicated to the other\
      \ end of the connection, it must be all of the following:\n\n#Owned by a network\
      \ PlayerPawn at some point it it's parent hierarchy.\n#It must be a reliable\
      \ function, or an unreliable function with available bandwidth. \n\nIn order\
      \ for that replicated function to actually be executed on the other end of the\
      \ machine, it must pass rule number 10. Additionally, if we are on the client,\
      \ it must meet any of the following rules.\n\n#A static function.\n#A simulated\
      \ function.\n#In an actor with an AutonomousProxy Role (a local PlayerPawn or\
      \ local GuidedWarhead on the client.) \n\nThe above rules need to be passed\
      \ for ANY function that is executed on the client, whether it is through simulation\
      \ or replication.\n\n=== Rep/Sim Function Summary ===\n\nWith those rules in\
      \ mind, I'll try to summarize the whole situation below.\n\nOn a server, every\
      \ function is executed, unless it is a (client-server) replicated function and\
      \ meets the checks above. So you can be assured of all your functions running\
      \ on the server, unless you specifically tell them not to.\n\nOn the client,\
      \ every function has to originate from a 'source.' A source can be a server-client\
      \ replicated function, an exec function, or an event. Events, while not covered\
      \ previously, are quite simple. An event is any function that is called from\
      \ native code. Events happen both on the server and on the client. The server\
      \ does not directly tell the client to execute the event, but the client knows\
      \ to execute the event based upon the game state (colliding actors, hitting\
      \ a wall, a timer event, ticking of the game state, etc). If that event is simulated,\
      \ then it can also serve as a 'source' of clientside function calls. A source\
      \ can call any function it wishes, assuming it meets the client-side execution\
      \ conditions, which can then call any...and so on.\n\nWhat happens if a function\
      \ is called, but doesn't meet the conditions for execution, either because it\
      \ was replicated to the other end, or because it does not meet the conditions\
      \ for running client-side. In that case, it is as if the function never ran\
      \ in the first place. The return value of such a function is 0, \"\", or None,\
      \ depending upon the context. Any out parameters defined by the function are\
      \ passed back exactly as they were entered. Relying on the result of a function\
      \ that is never executed is the source of many accessed nones that appear only\
      \ on the client. Exec functions (functions that can be bound to keystrokes)\
      \ naturally evaluate on the client. Again, remember to make it simulated, (unless\
      \ you are in an AutonomousProxy, like a PlayerPawn subclass.) In some cases,\
      \ you may want to have it replicated to the server, as in the case of a Server-Administrator\
      \ command (there are plenty of these defined in PlayerPawn.) Exec functions\
      \ can be replicated to the server, the same as any other function can.\n\n===\
      \ Spawning Within Simulated Functions ===\n\nThere are other interesting hidden\
      \ behaviors that may not be immediately apparent. For example, because of the\
      \ requirements that an actor be owned by a playerpawn at some point in its parent\
      \ hierarchy, a function can only be replicated to a single player in the game.\
      \ (No, making a player owned by another player will not work. ;) Multicast function\
      \ replication does not exist. You can try to get this behavior using simulated\
      \ functions, but no data can be passed between the server and the client, (since\
      \ they both originate on their local machine, and exist only on that local machine.)\
      \ Or you can use replicated variables, which can and are replicated to all players\
      \ in the game, assuming they are relevant to them.\n\nIf a spawn is performed\
      \ in a simulated function (simulated functions are explained later), then multiple\
      \ copies of the actor are spawned: the server, and each of the clients that\
      \ the simulated function was run on. The server's version is normally then replicated\
      \ to the client, so the client would see two versions. This would create strange\
      \ behavior as the two became out of sync, and the client-spawned one could easily\
      \ be mistaken for the 'official one' that for some reason, isn't having it's\
      \ variables replicated.\n\nIf you need to do a spawn in simulated code (there\
      \ are many valid reasons, like spawning effects clientside, etc), then you must\
      \ account for this. If you are attempting to make clientside effects, then make\
      \ sure you set the RemoteRole to ROLE_None immediately afterwards. Since relevancy\
      \ is only checked between ticks, this will ensure that when that check does\
      \ come around, it will not be relevant, and thus not replicated. That way, the\
      \ server and the client will each have their local copy of the effects that\
      \ run their course and then destroy themself. This is not useful for permanent\
      \ effects, since simulated functions are not run on ALL clients, only clients\
      \ where the actor containing the simulated function is relevant. That means\
      \ that if the simulated function didn't run (because it's actor was not relevant\
      \ at the time), then the effect will not be visible when you come into view\
      \ of that effect. That is why it should only be used for temporary effects that\
      \ run their course and then destroy themselves.\n\nIf however, you are spawning\
      \ something that is intended to be permanent, or needs data replicated from\
      \ the server, (like a crosshair dot,) then you SHOULD NOT spawn it on the client.\
      \ Usually, you can accomplish this with a 'If (Level.NetMode != NM_Client)'\
      \ check before you perform the spawn. This way, the spawned actor will then\
      \ become relevant (assuming the conditions match), and it's variables will be\
      \ replicated to the clients. If a client-side actor had been spawned, then there\
      \ would be two actors, one of which would just sit there without information\
      \ from the server\n\n=== Networked-Function Paramater Optimizations ===\n\n\
      And finally, when replicating functions, Unreal optimizes the parameters of\
      \ a function call through a few techniques. When sending a vector, (which is\
      \ composed of three floats,) the individual components are rounded to integers,\
      \ and thus lose their fractional values, and any values outside of -32768 to\
      \ 32767. A common technique is to multiply the values before they are sent to\
      \ make them scaled integers, and then dividing them on the other end back into\
      \ their appropriate values, so it is almost completely accurate. With rotators,\
      \ the values are scaled between 0 and 255, where the 128+ range corresponds\
      \ to the normally negative range of rotator component values. Then they are\
      \ rounded to ints, and sent over the network. They are then fixed back up again\
      \ to their original values (except they are left as positive values, since they\
      \ are equivalent to their negative counterpart that existed on the other end\
      \ of the connection. One approach that applies to both vectors and rotators\
      \ is to send the X/Y/Z or Pitch/Yaw/Roll values of the struct as individual\
      \ floats so that complete accuracy can be maintained. And finally, for completeness,\
      \ planes (which are not used much at all,) replicate their components as rounded\
      \ integers.\n\n=== Simulated States ===\n\nAnother, many times overlooked feature\
      \ is that of simulated states. You probably have already seen state code, code\
      \ that exists outside of functions, but in states, usually prefixed with labels.\
      \ This code, when in a regular state, is executed on the server alone. But by\
      \ prefixing the state statename with simulated, you can make the state code\
      \ itself simulated. So the revised state declaration would be simulated state\
      \ statename. Just beware that state changes are NOT replicated or sent to the\
      \ client by default. However, if a gotostate is executed in a function that\
      \ is run on the client (either through replication or simulation), then the\
      \ client will know of the new state. Playerpawn's inherent simulation allows\
      \ all it's functions to be able to control the state, but other classes would\
      \ need to have simulated functions that are executed from a simulated source\
      \ and chain of function calls in order to know of the state change. The current\
      \ UT code makes no use of simulated states, but I thought I would include this\
      \ section for the sake of completeness, in case you ever needed it.\n\n== Level\
      \ NetModes and their Implications ==\n\nIn the Level variable, which references\
      \ a LevelInfo actor and is accessible from every object, is a NetMode variable.\
      \ The NetMode variable is used to describe what role or position the current\
      \ instance of UT plays in the overall scheme. The possible values, and their\
      \ uses are:\n\n;NM_Standalone\n:This is for when the game is played alone, like\
      \ botmatches, the single player tournament ladder, etc \n;NM_DedicatedServer\n\
      :This is for when the server is running alone, with no one playing directly\
      \ in that instance of UT. This is the netmode for the majority of servers that\
      \ are online. It can be started with 'ucc server', or by clicking 'Dedicated'\
      \ when you select 'Start New Multiplayer Game.' \n;NM_ListenServer\n:When you\
      \ click 'Start' in the 'Start New Multiplayer Game' window, you are starting\
      \ a listen server, which is when you are playing and hosting at the same time.\
      \ This causes CPU to be spent on rendering the world for you, as well as hosting\
      \ the game for any connecting players. Thus, dedicated servers are preferred\
      \ to listen servers. \n;NM_Client\n:When you are connected to a running UT server,\
      \ no matter what type of server it is, you are this netmode. \n\nThese netmodes\
      \ are usually not important as Roles and RemoteRoles can handle everything.\
      \ However, when you want to execute a block of code on the client, but don't\
      \ want to replicate it, these netmodes can help. For example, code is run on\
      \ the client through a chain of simulation. If the chain of simulation is upheld,\
      \ then you can do a 'if (Level.Netmode == NM_Client) {', then that code will\
      \ be executed on the client only, or on many clients, if that event exists in\
      \ many places. By combining that with a check on Owner, it is possible to ensure\
      \ that it is only run on one single client. One thing that makes the whole deal\
      \ more complex is that you want to ensure your code will run in standalone games,\
      \ and for the guy running and playing in listen servers. For this reason, you\
      \ will often see code that does 'if (Level.NetMode != NM_DedicatedServer) {',\
      \ which probably does exactly what you want. Other examples include only spawning\
      \ non-relevant gibs if you aren't on a dedicated server (because of the increase\
      \ in CPU time). Another example is the use of spawning a gibbed head. The gibbed\
      \ head needs to travel in the same, but random, direction as the server. Giving\
      \ it a random velocity on the client would cause it to readjust midflight when\
      \ the network-replicated data came through the pipe. Instead, the carcass head\
      \ is not spawned clientside, but rather it lets the network data create the\
      \ head, and give it the server's random velocity, so that it will be correctly\
      \ in sync. Further uses are left to your imagination. :)\n\n== Special Properties\
      \ about Special Stuff ==\n\n=== bNetOptional Usage ===\n\nYou've seen bNetOptional\
      \ talked about a few times. Now's a good a time as any disucss what it was intended\
      \ for, and when you should use it. As was discussed earlier, any actors that\
      \ have bNetOptional set get put at the bottom of the list of actors. The effect\
      \ of this is that they get starved of bandwidth when the connection becomes\
      \ full. If there's bandwidth available however, then they'll be replicated.\
      \ They have 150 ms to be replicated, before they are forgotten about completely,\
      \ and the client never sees them. When should you use these? In most cases,\
      \ you'll want to use them for temporary effects that can be replicated to the\
      \ client, and then allowed to complete on their own. For example, a little puff\
      \ of smoke coming from a wall after you shoot it would be a good example. If\
      \ your bandwidth is overloaded, either from a big firefight, or from excessive\
      \ lag, then the little puff of smoke will not be seen. You probably won't notice\
      \ it in either case. bNetOptional actors will not be replicated after their\
      \ initial replication, either. They're conditions are evaluated only once, the\
      \ first time they are executed. They are expected to complete their actions\
      \ without any interaction of the server. This also saves a lot on bandwith.\
      \ It wouldn't make sense to have the server continually evaluate replication\
      \ checks for these actors, since that would only waste bandwidth. bNetOptional\
      \ is not for everything though. An explosion sprite, like a rocket's animated\
      \ explosion, is necessary for everyone in view. It's easy to miss a sprite puff\
      \ of smoke in the heat of battle, but a large explosion is not something easily\
      \ missed. You'll want to use the bNetOptional only for small, non-vital actors\
      \ that aren't necessary. In Unreal Tournament, they are used for decals, fragments\
      \ (those little chunks of 'wall' that fly off), shell casings, smoke puffs,\
      \ the wall hits (the little yellow 'spark' when you hit the wall), and the respawn\
      \ effects. Note that if the default lifespan is set to 0, then a bNetOptional\
      \ actor will be treated just like any other actor. If the bNetOptional actor\
      \ does have a default lifespan set, and it extends beyond the first 150 ms of\
      \ it's lifetime, then it will never be replicated. Any request to destroy an\
      \ actor will be replicated to the client regardless of at what point it exists\
      \ in it's lifespan, as UT will always make sure the client destroys what the\
      \ server destroys.\n\n=== bNetTemporary Usage ===\n\nWhile we're at it, we might\
      \ as well cover bNetTemporary here. bNetTemporary actors are for 'tear-off replication',\
      \ as someone once put it. They are replicated when they are first spawned, and\
      \ that is it. There is never any further connection between the server and client\
      \ in regards to that bNetTemporary actor. A bNetTemporary actor is not necessarily\
      \ temporary, just that the replication of it's variables is temporary, (only\
      \ once.) This is used in many places. In UT, all decals and projectiles are\
      \ bNetTemporary by default. A decal is replicated to every client that it is\
      \ relevant to, and then the connection is broken. this saves significantly on\
      \ bandwidth. This means that if you walk into view of a scene where there was\
      \ a battle that you did not witness, then you will not see any of the decals\
      \ in that room. They were temporarily replicated, and so you will never see\
      \ them if you weren't present for it's one-time replication. In Half-Life, decals\
      \ were not 'bNetTemporary', and so were sent to every client when they came\
      \ into view. This contributed to part of the lag that many experienced because\
      \ of the many decals and spraypaint decals that were spawned in a game. bNetTemporary\
      \ actors need to be destroyed in clientside simulated code, since a server destruction\
      \ of the actor will not replicate to the client, because of it's bNetTemporary\
      \ status. This is done when decals grow stale and need to delete themselves\
      \ based upon client information, since the server cannot tell the client about\
      \ that. Most projectiles utilize bNetTemporary. Take a razorblade, for example.\
      \ It gives the client the initial velocity, and the client can work everything\
      \ out from there. Since the razorblade is entirely predictable and deterministic,\
      \ it can be predicted on the client with 100% accuracy. The wall it bounces\
      \ off on the server.....it also bounces off the equivalent wall on the client.\
      \ Because it is entirely predictable, the server only needs to send it once,\
      \ and the client can figure it out. For that reason, projectiles are bNetTemporary.\
      \ Problems can happen when you enter a big room that has razorblades flying\
      \ around. Because the razorblades are bNetTemporary, you will not know about\
      \ them. So you can walk into what seems like a perfectly empty room, and then\
      \ get your head chopped off with a razorblade. However, you'll since most people\
      \ do not use 360 FOV, you'll probably attribute it to just not seeing it coming.\
      \ So no one ever notices that. Other projectiles like the the guided redeemer\
      \ missles, or even regular redeemer missles (which can be shot down midflight)\
      \ cannot be bNetTemporary because the server needs to send status updates to\
      \ the client. The green globs from the goop gun need to be visible on the floor\
      \ when you run into a room, (because they are sorta-long-lasting land mines,)\
      \ and so they too cannot be bNetTemporary. There are other examples of where\
      \ projectiles are not bNetTemporary, but I'm sure you get the idea.\n\n=== PlaySound's\
      \ and PlayOwnedSound's Special Behaviors ===\n\nThis one issue was brought to\
      \ my attention when someone was trying to figure out how come a sound wasn't\
      \ playing correctly in his mod, even though it worked fine in UT. After looking\
      \ into it, I couldn't see how the sound was working in UT. The replication and\
      \ simulation behavior was not set up for it. Turns out that it had hidden behavior,\
      \ depending upon where and how it was called. In theory, PlaySound is used to\
      \ have an actor play a sound. The game will determine how loud to play it, depending\
      \ upon occlusion and distance, etc. UT tries to determine the 'right' and intelligent\
      \ way to propogate the sound, depending upon how it was called. First, we'll\
      \ cover PlaySound. It can be called in two contexts:\n\nFrom a simulated function,\
      \ or from a replicated-to-client function \n*In this scenario, the sound is\
      \ being played in many places. The simulated nature means that any player that\
      \ can see the actor, is getting the simulation events. So each client will play\
      \ the sound on it's own, due to the simulation. In the case of a replicated\
      \ function, (where it's being run on the client,) UT assumes you know what you're\
      \ doing, and that you want the sound to be played on that client only. You may\
      \ wonder why there is a check for a replicated-to-client function when there's\
      \ already a simulated function check, (since all replicated-to-client functions\
      \ need to be simulated,) but if you remember, a PlayerPawn that is operating\
      \ under ROLE_AutonomousProxy can execute replicated functions that do not have\
      \ the simulated prefix. This case covers those. In general, this play-locally\
      \ behavior is what you want, when you call PlaySound from within a simulated\
      \ function.\n\nFrom a non-simulated, non-replicated-to-client function \n*When\
      \ you call PlaySound in this context, UT does more work for you. In this scenario,\
      \ the PlaySound is being called server-side. That does absolutely no good in\
      \ a real game, since that sound would then not be heard by anyone. You might\
      \ think it only has to be replicated, but if you'll remember, function replication\
      \ is not multicast, so the sound would only be heard by the owner of the actor\
      \ PlaySound is being called upon. Simulation doesn't help, since that would\
      \ only happen if the sound was being called on the client. Simulation does not\
      \ actually send anything over the network. So, UT performs some special magic\
      \ instead. In Pawn, there is a ClientHearSound, whose definition is:\n\n<uscript>\n\
      native simulated event ClientHearSound (\n\tactor Actor,\n\tint Id,\n\tsound\
      \ S,\n\tvector SoundLocation,\n\tvector Parameters\n);\n</uscript>\n\nThis ClientHearSound\
      \ is replicated from the server to the client, per the replication definition\
      \ in Pawn. Remembering that it only goes to it's owner, this works fine, since\
      \ calling Pawn.ClientHearSound(someactor...) on the server will cause that one\
      \ pawn to hear the sound on the client, as if the sound came from someactor's\
      \ direction. The special magic performed, is that UT effectively turns the call\
      \ to PlaySound into a multicast function replication on ClientHearSound. When\
      \ PlaySound is called, it iterates through all nearby players that should hear\
      \ the sound, and replicates a call to ClientHearSound to each player. In this\
      \ fashion, each player that should hear it, does hear it. And the original identity\
      \ of the actor playing the sound is maintained through the first parameter to\
      \ ClientHearSound.\n\nThis is actually quite the nifty behavior for PlaySound,\
      \ as it causes the function to work the way it 'should,' in most cases. In the\
      \ cases where it doesn't, you'll need to figure in it's dual nature, and figure\
      \ out how to call it, (or call some other home-grown sound replication feature,)\
      \ to make it work.\n\nThe other interesting behavior to talk about is that of\
      \ PlayOwnedSound. The purpose of this function is to play the sound for everyone\
      \ but the owner. This may seem strange at first, but there are a few uses for\
      \ it. In UT, it used in most of the weapons. When a client fires a gun, they\
      \ should get immediate feedback about the shot. That is why you see the weapon\
      \ animations plya clientside, and hear the sounds clientside. However, the client\
      \ cannot force sounds to be played elsewhere. What is done, is that the weapon\
      \ plays a sound clientside immediately when the shot is fired. The client then\
      \ tells the server it fired the gun, which then calls PlayOwnedSound with the\
      \ sound, so that the sound can be heard by all the other clients. You wouldn't\
      \ want the sound to be played on the player firing the gun, since they already\
      \ played the sound. Hopefully that example is clear, but you can check the examples\
      \ provided in UT's weapons if it does not satisfy you. One final note: when\
      \ UT determines who is the owner, it only checks the actor itself (to see if\
      \ it is the pawn or the playerpawn), and the immediate owner of the actor. It\
      \ does not follow the hierarchy up like some other functions do.\n\n=== ClientPlaySound\
      \ and ClientReliablePlaySound ===\n\nHere's a simple example, but still noteworthy\
      \ nonetheless. ClientPlaySound is an unreliable function that plays a sound\
      \ on the client. Calling PlayerPawn.ClientPlaySound(...) causes that player\
      \ to play the sound locally on their machine. It is a location-less sound, and\
      \ the sound is played as if it came from within their head, (as opposed to next\
      \ to them, or in front of them, etc.) When called on the client, it is guaranteed\
      \ to run, since no replication is involved, (it's a simulated function being\
      \ called from a simulated function...) When it is called from the server, it\
      \ is not guaranteed to reach the other end, however. What happens if you want\
      \ to ensure that the sound is played? You call ClientReliablePlaySound, of course.\
      \ This is a reliable function, which ensures that the sound reaches the client\
      \ and is played. I'll just rip the whole ClientReliablePlaySound function, so\
      \ you can see what is going on:\n\n<uscript>\nsimulated function ClientReliablePlaySound(sound\
      \ ASound, optional bool bInterrupt, optional bool bVolumeControl )\n{\n\tClientPlaySound(ASound,\
      \ bInterrupt, bVolumeControl);\n}\n</uscript>\n\nYou can see that the reliable\
      \ definition which is farther above in PlayerPawn ensures that ClientReliablePlaySound\
      \ is run. Once that happens, the body of ClientReliablePlaySound is run on the\
      \ client. There, it calls ClientPlaySound which ensures that the sound is played.\n\
      \n== When Things Go Awry ==\n\nWhat should you do when things go awry? There's\
      \ two main techniques that I use, when trying to figure out what's going on.\
      \ Technically, everything can be figured out with the first technique alone,\
      \ but the second helps a lot in figuring out the applying technique.\n\n== Figure\
      \ Out What's Going On ==\n\nYou need to isolate your problem. Know exactly what's\
      \ happening. What stuff is being replicated, and what isn't. Then realize that\
      \ those are only your assumptions, and that no matter what, you cannot be positive\
      \ about them. With all the native stuff happening with replication, it's so\
      \ easy to blame your problems on what's going on under the hood. In fact, after\
      \ readinng this guide, you should be able to solve your problems yourself. I\
      \ think I've covered just about every native replication aspect there is in\
      \ this document. It's why it's so big. When I was having replication troubles,\
      \ I remember that I wished there was documentation. I'd (and I'm sure others)\
      \ would rather have too much than too little. Anyways, now that I've had access\
      \ to the source, and have been able to know exactly what's been going on, I've\
      \ been able to figure out why problems are happening in netplay, even ones that\
      \ aren't my own. I say this only to point out that just knowing and understanding\
      \ what's going on under the hood can make any problem solvable. You don't need\
      \ extensivle trial and error to figure out where things are screwing up. Just\
      \ thinking the problem through, and checking the unrealscript code, can provide\
      \ you with the answer.\n\nFirst, figure out what you believe is not replicating.\
      \ Is it a function? A variable? What's going on exactly? Sometimes, because\
      \ of intricate relationships in your code, you'll be unable to tell exactly\
      \ what is 'missing' on the client. In that case, you'll need to use logging\
      \ to figure out what's there and what's not. Logging is the second technique\
      \ I mentioned. I'll discuss more on how to use it properly in debugging networking\
      \ problems in a bit.\n\n=== Check the Replication Statements ===\n\nAnyways,\
      \ once you figure out what's not being replicated, check the replication statement.\
      \ 98% of the time, you can figure out why something is not replicating, by evaluating\
      \ the replication statement yourself. I went through a great many replication\
      \ statements in actor up above in the variable replication section. You might\
      \ want to check there for some of the more common ones. But thinking about each\
      \ part of the statement in turn will help you figure it out. Many times, stuff\
      \ has a bNetInitial clause, which only happens the first time the actor is sent\
      \ over the network when becoming relevant. This causes problems when your data\
      \ isn't getting replicated midstream, or is at odd points, like when it goes\
      \ out of and then comes back into relevancy. You can follow the function replication\
      \ and simulation guidelines listed above to see if the function meets the criteria\
      \ for being sent accross the network, or evaluated client-side.\n\nAnother programmer\
      \ I've talked to had problems with his velocity not replicating when the grenades\
      \ were thrown, but it was because they were only replicated on bNetInitial,\
      \ and so that's why he never saw his velocity updates. Fiddling with the variables,\
      \ he found that a RemoteRole of ROLE_DumbProxy seemed to work, as the grenades\
      \ did seem to be moving. It may be hard to tell that's what is going on when\
      \ you're on a LAN or even connecting to your own server, because of the small\
      \ ping, and high bandwidth. But you can be sure that you're players playing\
      \ over their modems will notice it. :) Remember the various properties of ROLE_DumbProxy,\
      \ and ROLE_SimulatedProxy, and what side effects each causes, in terms of what\
      \ is replicated. I've seen a few cases where that is the reason for their strange\
      \ behavior. The problem with his approach was that he was getting the spoon-fed\
      \ location updates from the server, and so in a real environment online, that\
      \ would never work, since players cannot get location updates over the net and\
      \ expect it to work right. In that case, the grenades should never be thrown\
      \ from the inventory. ROLE_SimulatedProxy was a perfect fit for what he was\
      \ trying to do, except for the fact that when he threw it, it was not bNetInitial.\
      \ Instead, he just had to spawn a new actor, and give it the 'thrown' properties.\
      \ That satisfied the criteria needed for the variable replication for ROLE_SimulatedProxy,\
      \ and allowed the grenades to be thrown correctly, be simulated correctly, and\
      \ it to all just work.\n\n=== Logging is Your Friend ===\n\nIf that doesn't\
      \ help you, try sticking logging statements in there. When you have two copies\
      \ of UT running, a server and a client, two different logs are generated. One\
      \ is a server log, and one is a client log. (doh :) If you aren't sure if a\
      \ function is executing clientside, place a log in it. Then, check to see if\
      \ that log appears in the clientside log. If it does, then the function is running\
      \ on the client, and your strange behavior must be coming from elsewhere. If\
      \ there is no log happening, then the function is not being executed. You may\
      \ think it must be, because it is the only explanation for behavior you are\
      \ seeing. But the logs do not lie. What is more often the case is that the function\
      \ is being run on the server, and modifying variables, which are being replicated\
      \ to the client, giving the appearance that the function ran on the client.\
      \ As i talked about before, it can be easy to overlook this in LAN settings,\
      \ but it will surely be found in real world conditions. I'll discuss how to\
      \ test things in 'real-world' conditions in just a bit. Logging is your friend,\
      \ and you should become quite familiar with it. Most Unreal Tournament programmers\
      \ are already familiar with it, and if they've gotten bogged down in replication\
      \ problems already, they're just about gunaranteed to have logged stuff in trying\
      \ to figure things out. However, combine logging with a knowledge of what's\
      \ actually going on, and you increase your chances of success manifold. I'll\
      \ be covering a few 'case studies' of sorts at the end of the document. You'll\
      \ be able to see exactly what's going on as each part is done, and hopefully\
      \ the real-world examples of replication will make things clearer.\n\n== Testing\
      \ Real-World Conditions ==\n\n=== Testing a Mod in Netplay without a Network\
      \ ===\n\nIt's always important to test your mod in netplay. Sometimes, it can\
      \ be hard, when you don't have a bunch of people available to test with. However,\
      \ there is nothing preventing you from running a server and a client on the\
      \ same machine. This allows you to test netplay on a single machine.\n\n====\
      \ Windows 9x ====\n\nOn Windows 9x, the UT client will consume 100% of the CPU\
      \ by default. This is so that extraneous programs like ICQ, mirc, or whatever\
      \ else you might have open do not steal CPU resources from your UT client, which\
      \ should get full priority. This means that if you run a client and server on\
      \ the same machine, the server will be starved of CPU cycles, and your UT client\
      \ will experience extreme lag and packet loss. While you may want to simulate\
      \ these at some point, this is not the way to go about doing it. Luckily, someone\
      \ wrote a simple program that helps solve this dilemma of testing a UT server\
      \ and client together. It was originally intended to solve this same problem\
      \ for QuakeWorld servers, but it is perfectly applicable to our situation.\n\
      \nLet's disucss how to use it. First, download priority and extract it somewhere\
      \ safe. I have mine in my UnrealTournament\\System directory. Next start your\
      \ server. Your best bet is to do this with the 'ucc server' commandlet. The\
      \ general format for testing your mods should be:\n\nucc server mapname.unr?game=packagename.classname?packagename1.classname1,packagename2.classname2\n\
      \nSome example commandlines follow:\n\n*ucc server DM-Morbias][\n*ucc server\
      \ DM-Morpheus?game=RocketArena.RocketArenaGame\n*ucc server CTF-Face?mutators=Botpack.InstaGibDM,Botpack.LowGrav\
      \ \n\nNext, you have to tell priority to give more priority to our UT server.\
      \ You can read the readme associated with priority if you're interested in exactly\
      \ what commandline parameters do what. But for our UT client/server testing\
      \ purposes, just type the following in another window or command prompt:\n\n\
      ucc -title ucc\n\nNow, our UT server will have the necessary CPU time it needs\
      \ to run, even if a UT client is running. Now run the UT client, connecting\
      \ to your local machine, with:\n\nunrealtournament 127.0.0.1\n\nTest your mod,\
      \ and make sure it all works as you have planned. Of course, some things will\
      \ require the use of more than one person to test, but at least you should be\
      \ able to test and fix a large portion of your problems yourself, without requiring\
      \ someone's valuable time, or requiring you to waste your own organizing a beta\
      \ team and stuff.\n\n==== Windows NT/2000 ====\n\nOn Windows NT/2000, this is\
      \ not a problem, since NT supports true multi-tasking, and so the use of priority.exe\
      \ is not an issue. ////////////////////////////\n\n=== Simulating Lag and PacketLoss\
      \ ===\n\nTesting multiplayer as described above only solves one problem. It\
      \ helps you see if your code will execute in multiplayer correctly. However,\
      \ the successful completion of that test does not mean that your mod will work\
      \ in netplay. When testing netplay on your machine, your computer connects directly\
      \ to itself, accross an incredibly fast and large connection. Testing on a LAN\
      \ has the same 'problem', in that you will not be simulating the effect of people\
      \ playing over modems on servers halfway around the world. Luckily, UT includes\
      \ commandline options to help you simulate this type of behavior. They are:\
      \ PktLoss, PktOrder, PktLag, and PktDup. These variables only affect data as\
      \ it is being sent, so you will need to place them on the server and client\
      \ to accomplish true lag. But first, if you check your UnrealTournament.ini,\
      \ you'll notice references to SimPacketLoss and SimLatency. These worked once,\
      \ in a land far, far away in a time long, long ago. They do absolutely nothing\
      \ now, so you might as well remove them from your ini.\n\nThe true way to simulate\
      \ lag is to use the commandline parameters when you start UT. We'll cover and\
      \ document all of these variables here. To use these variables, you need to\
      \ start UT like this: unrealtournament.exe server.ip.addr?PktLoss=4?PktLag=400.\
      \ This will cause your UT client to experience this amount of lag when sending\
      \ data to the server. Data sent from the server to the client till still travel\
      \ at full speed, however. By the same token, you can also pass these variables\
      \ to ucc with ucc server mapname.unr?PktLoss=10?PktLag=600. This will create\
      \ a very 'bad' server with terrible conditions...probably too extreme even for\
      \ real-life conditions. (If you play under 600 ping and 10% packetloss, then\
      \ I feel bad for you. :) Let's get into the documentation of the individual\
      \ variables. PktLoss will work all the time. The remaining three, PktOrder,\
      \ PktLag, and PktDup are mutually exclusive, and if multiple options are passed\
      \ on the commandline, the order just stated is the order they are checked. For\
      \ example, if you pass PktLoss, PktLag, and PktOrder, then only PktOrder and\
      \ PktLoss will be used. PktOrder has a higher priority than PktLag, and PktLoss\
      \ always works.\n\n==== PktLoss ====\n\nThe first, PktLoss. is set a percentage\
      \ of packets sent. It determines the percentage of packets lost over the connection.\
      \ Passing 10 will mean that 10% of the packets sent to the client will be lost\
      \ to the bandwidth graveyard. Any packetloss usually will hurt a connection\
      \ in real world connection, as many people complain about anything over 0% packetloss.\
      \ So when testing, this value doesn't need to be that high, and probably should\
      \ only range between 0 and 10. PktLoss set with: PktLoss=5\n\n==== PktOrder\
      \ ====\n\nThe next, PktOrder, determines whether packets will be sent out of\
      \ order. This is simply a boolean flag, meaning that the only option for it\
      \ is on/off, not a variable as in PktLoss. If this flag is set to on, it preclues\
      \ the use of PktLag and PktDup, described below. PktOrder works like this: Every\
      \ time a packet is going to be sent, it gets put at the end of a 'to-send' list.\
      \ Then UT goes through the 'to-send' list, and sends half of the variables over\
      \ the connection. While this is not truly random, it doesn't matter. It succeeds\
      \ in it's goal in sending packets out of order, since they can be kept on the\
      \ list for an indefinite length of time. PktOrder set with: PktOrder=1\n\n====\
      \ PktLag ====\n\nIf you want to delay packets and simulate lag, then PktLag\
      \ is the variable you want. Precluding the use of PktDup, and only working if\
      \ PktOrder is not set, PktLag is set as a value of milliseconds. All packets\
      \ being sent over the connection will be delayed by PktLag milliseconds. PktLag\
      \ set with: PktLag=450\n\n==== PktDup ====\n\nIf you want to simulate the effects\
      \ of sending packets twice over the network, PktDup fits the bill. Only working\
      \ if both PktOrder and PktLag are not set, PktDup is set as a percentage of\
      \ packets that are duplicated. Every packet that is sent has a PktDup chance\
      \ of being sent twice. All packets will be sent once. PktDup set with PktDup=20\n\
      \n==== Using the Variables ====\n\nNow that you know how the variables work,\
      \ here's a little lesson in how to use them. Remember that they only work for\
      \ packets being sent. So if you set PktLag to 500 on the server, the client\
      \ will experience 500 ms lag between what the server sent and what the client\
      \ sees. Client packets sent to the server will go at their regular speed, however,\
      \ which is usually around 40 ms each way on my machine. To truly test lag, you\
      \ will need to use PktLag on both the client and the server. Ping, if you remember,\
      \ is the time it takes for a packet to go round trip from client to server and\
      \ back to client. To simulate a 500 ping, the best way would be to give a 250\
      \ PktLag on both the server and the client. All clients to connect to the server\
      \ would then experience 250 ms additional lag, regardless of their local settings.\
      \ The client would then add 250 ms additional lag itself through PktLag, resulting\
      \ in a 500 ms effective ping.\n\nOf the variables above, you will find yourself\
      \ using PktLoss and PktLag most often. The others were more intended for Epic\
      \ to test the results of it's own network code, and test it under extreme conditions\
      \ that it could not duplicate. I doubt you will have need of PktDup or PktOrder\
      \ unless you are unable to reproduce the player-reported problems about your\
      \ mod being unresponsive or ineffective.\n\n== Conclusion ==\n\nThat's it, folks.\
      \ Hopefully you now understand replication a lot more than you did before. Granted,\
      \ it all may seem COMPLETELY overwhelming and confusing at first, and it is.\
      \ But through application and testing of these principles, you will become more\
      \ familiar with what is going on, and will better grasp network coding as time\
      \ passes. You may need to read this document through a few times, before it\
      \ all sinks in. If you find a section that is confusing even after you've read\
      \ it through, send me an email at mongo-replication@jall.org. Don't expect me\
      \ to help you out personally however, since I imagine I will probably get countless\
      \ emails from new people that don't meet the basic assumptions I made and stated\
      \ at the beginning of the document. It is always inevitable. Of course, those\
      \ people probably haven't even read this far, so they'll be emailing me anyway,\
      \ but I'm just letting you faithful readers know. :) I'm planning to read all\
      \ your emails, and if they have good or valid suggestions for things to cover,\
      \ or describe ambiguous or confusing aspects of my tutorial, then I'll make\
      \ corrections and updates to this document in the future.\n\nWhen something\
      \ doesn't work, don't assume it's UT's native code in regards to replication.\
      \ I believe I have successfully delineated all such hidden tricks in this document.\
      \ The error has to be in your code, however much you don't like hearing that.\
      \ Trust me, this is from experience. ;) Check your replication statements to\
      \ make sure their logic is correct, and run through your code as both the server\
      \ and the client, following the flow of logic to figure out what's going on.\
      \ Make sure what you're expecting to be replicated or simulated IS ACTUALLY\
      \ replicated or simulated, by following the checklists I've given in the document\
      \ above. And as I stated before, LOG LOG LOG LOG. Fill your code chock-full\
      \ of logs, to make sure that things are happening the way you want. After following\
      \ all the guidelines, the only true test to make sure things are happening the\
      \ way you expect is to put logs in, and see what is happening where. With all\
      \ this in mind, I'm sure you will be successful in your future networking endeavors.\n\
      \nGood luck!\n\nMongo\n\nStill to cover:\n\n== Special Networking Tricks (Case\
      \ Studies) ==\n\nLet's take a look at a few examples and problems that people\
      \ have had, and an approach to solving them. Hopefully, this will help you solve\
      \ your own problem, or at the very least, help you see how others have approached\
      \ their problems, and fixed them.\n\nthoroughly read through above sections\
      \ on special properties of special stuff, realworld conditions, things go awry\
      \ serverpackages packageflags native final functions are simulated automatically\
      \ (?) state changes only seen for playerpawns, unless changed in simulated functions\
      \ (then they cause problems for newly relevant actors) window stuff on client\
      \ functions usually replicated before variables, cannot be sure Case Studies:\n\
      \n*HUDMutators (everyone wants them :/ )\n*DrSiN's Window Replication Info\n\
      *How to get custom pris: RAUT's PRI extra stuff (avoid spawnnotifies)\n*Laser-Guided-Ripper\
      \ Tutorial get a better laserdot\n*UT's method for sending data to the server\
      \ for playerpawns\n*How they did the GuidedWarhead in netplay \n\nWeapon Replication/Networking\
      \ overview (where?)\n\nOther Neat Tricks\n\n*Faking replication of parent-variables\
      \ that wouldn't normally replicate\n*Faking multicast replication with specially-owned\
      \ objects by each player, that get functions called on them from a general function.\n\
      *Use physics to your advantage Use of PHYS_Trailer for Halo, Shieldbelt\n*Use\
      \ of Simulated ticks to accomplish clientside manual physics just a discussion,\
      \ as complex code: Taliesin's code for inverse IK (hey, it's cool, too!)\n*Other\
      \ ways of doing non-standard variable replication with functions, like Taliesin's\
      \ code for seekers"
  properties: []
  revId: 44258
name: "Legacy:Replication De-Obfuscation"
revision:
  revid: 44258
  parentid: 43744
  user: "WGH"
  timestamp: 1296919819.000000000
  comment: "unfortunately no longer"
timestamp: 1668786610.472354000
