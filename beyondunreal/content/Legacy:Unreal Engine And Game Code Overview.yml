---
parse:
  title: "Legacy:Unreal Engine And Game Code Overview"
  text:
    text: "<p>The original PDF is here: * <a rel=\"nofollow\" class=\"external free\"\
      \ href=\"http://udn.epicgames.com/pub/Technical/GameAndAIHandout/gameai.pdf\"\
      >http://udn.epicgames.com/pub/Technical/GameAndAIHandout/gameai.pdf</a></p>\n\
      <p>Note that this handout is a couple of years old, so some of the information\
      \ is outdated. Also, the weapon system in <a href=\"/Legacy:UT2003\" title=\"\
      Legacy:UT2003\" class=\"mw-redirect\">UT2003</a> is completely different from\
      \ the one described in the Game/AI handout (the UT2003 weapon system was developed\
      \ by DE).</p>\n<p></p>\n<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\"\
      >\n<h2>Contents</h2>\n</div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a\
      \ href=\"#Unreal_Engine_AI_and_Game_Code_Overview\"><span class=\"tocnumber\"\
      >1</span> <span class=\"toctext\">Unreal Engine AI and Game Code Overview</span></a>\n\
      <ul>\n<li class=\"toclevel-2 tocsection-2\"><a href=\"#PART_I_-_Engine_Classes_defined_in_UnrealScript\"\
      ><span class=\"tocnumber\">1.1</span> <span class=\"toctext\">PART I - Engine\
      \ Classes defined in UnrealScript</span></a>\n<ul>\n<li class=\"toclevel-3 tocsection-3\"\
      ><a href=\"#Actor\"><span class=\"tocnumber\">1.1.1</span> <span class=\"toctext\"\
      >Actor</span></a></li>\n<li class=\"toclevel-3 tocsection-4\"><a href=\"#Pawn_and_Controller\"\
      ><span class=\"tocnumber\">1.1.2</span> <span class=\"toctext\">Pawn and Controller</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-5\"><a href=\"#GameInfo_and_related_classes\"\
      ><span class=\"tocnumber\">1.1.3</span> <span class=\"toctext\">GameInfo and\
      \ related classes</span></a></li>\n<li class=\"toclevel-3 tocsection-6\"><a\
      \ href=\"#PlayerReplicationInfo.2C_GameReplicationInfo_and_TeamInfo\"><span\
      \ class=\"tocnumber\">1.1.4</span> <span class=\"toctext\">PlayerReplicationInfo,\
      \ GameReplicationInfo and TeamInfo</span></a></li>\n<li class=\"toclevel-3 tocsection-7\"\
      ><a href=\"#LevelInfo\"><span class=\"tocnumber\">1.1.5</span> <span class=\"\
      toctext\">LevelInfo</span></a></li>\n<li class=\"toclevel-3 tocsection-8\"><a\
      \ href=\"#Volume.2C_PhysicsVolume.2C_and_BlockingVolume\"><span class=\"tocnumber\"\
      >1.1.6</span> <span class=\"toctext\">Volume, PhysicsVolume, and BlockingVolume</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-9\"><a href=\"#NavigationPoints\"><span class=\"\
      tocnumber\">1.1.7</span> <span class=\"toctext\">NavigationPoints</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-10\"><a href=\"#Inventory.2C_Pickup.2C_and_AttachedInventory\"\
      ><span class=\"tocnumber\">1.1.8</span> <span class=\"toctext\">Inventory, Pickup,\
      \ and AttachedInventory</span></a></li>\n<li class=\"toclevel-3 tocsection-11\"\
      ><a href=\"#Weapon.2C_AttachedWeapon.2C_Projectile_and_Ammunition\"><span class=\"\
      tocnumber\">1.1.9</span> <span class=\"toctext\">Weapon, AttachedWeapon, Projectile\
      \ and Ammunition</span></a></li>\n<li class=\"toclevel-3 tocsection-12\"><a\
      \ href=\"#Mover\"><span class=\"tocnumber\">1.1.10</span> <span class=\"toctext\"\
      >Mover</span></a></li>\n<li class=\"toclevel-3 tocsection-13\"><a href=\"#Trigger\"\
      ><span class=\"tocnumber\">1.1.11</span> <span class=\"toctext\">Trigger</span></a></li>\n\
      <li class=\"toclevel-3 tocsection-14\"><a href=\"#Effects\"><span class=\"tocnumber\"\
      >1.1.12</span> <span class=\"toctext\">Effects</span></a></li>\n<li class=\"\
      toclevel-3 tocsection-15\"><a href=\"#Damagetype\"><span class=\"tocnumber\"\
      >1.1.13</span> <span class=\"toctext\">Damagetype</span></a></li>\n<li class=\"\
      toclevel-3 tocsection-16\"><a href=\"#LocalMessage\"><span class=\"tocnumber\"\
      >1.1.14</span> <span class=\"toctext\">LocalMessage</span></a></li>\n<li class=\"\
      toclevel-3 tocsection-17\"><a href=\"#HUD_and_Scoreboard\"><span class=\"tocnumber\"\
      >1.1.15</span> <span class=\"toctext\">HUD and Scoreboard</span></a></li>\n\
      </ul>\n</li>\n<li class=\"toclevel-2 tocsection-18\"><a href=\"#PART_II_-_Game_code_in_C.2B.2B\"\
      ><span class=\"tocnumber\">1.2</span> <span class=\"toctext\">PART II - Game\
      \ code in C++</span></a>\n<ul>\n<li class=\"toclevel-3 tocsection-19\"><a href=\"\
      #Navigation_AI\"><span class=\"tocnumber\">1.2.1</span> <span class=\"toctext\"\
      >Navigation AI</span></a></li>\n<li class=\"toclevel-3 tocsection-20\"><a href=\"\
      #Actor_creation_and_destruction\"><span class=\"tocnumber\">1.2.2</span> <span\
      \ class=\"toctext\">Actor creation and destruction</span></a></li>\n<li class=\"\
      toclevel-3 tocsection-21\"><a href=\"#Physics_and_world_interaction\"><span\
      \ class=\"tocnumber\">1.2.3</span> <span class=\"toctext\">Physics and world\
      \ interaction</span></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n\
      <h2><span class=\"mw-headline\" id=\"Unreal_Engine_AI_and_Game_Code_Overview\"\
      >Unreal Engine AI and Game Code Overview</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=1\"\
      \ title=\"Edit section: Unreal Engine AI and Game Code Overview\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Steven Polge Epic\
      \ Games October 16, 2001</p>\n<h3><span class=\"mw-headline\" id=\"PART_I_-_Engine_Classes_defined_in_UnrealScript\"\
      >PART I - Engine Classes defined in UnrealScript</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=2\"\
      \ title=\"Edit section: PART I - Engine Classes defined in UnrealScript\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<h4><span class=\"\
      mw-headline\" id=\"Actor\"><a href=\"/Legacy:Actor\" title=\"Legacy:Actor\"\
      >Actor</a></span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=3\"\
      \ title=\"Edit section: Actor\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Base class of all gameplay objects.</dd>\n\
      <dd>A large number of properties, behaviors and interfaces are implemented in\
      \ the</dd>\n<dd>base Actor class, including:\n<dl>\n<dd>Display</dd>\n<dd>Animation</dd>\n\
      <dd>Physics and world interaction (discussed later)</dd>\n<dd>Making sounds</dd>\n\
      <dd>Networking properties (discussed in networking session).</dd>\n<dd>Actor\
      \ creation and destruction (discussed later)</dd>\n<dd>Triggering and timers\n\
      <dl>\n<dd>When an actor with a defined event calls TriggerEvent() or UntriggerEvent(),\
      \ the Trigger() or Untrigger() function is called for all actors with the matching\
      \ tag.</dd>\n<dd>An actor’s event is triggered for the following events:\n<dl>\n\
      <dd>Decoration - when it’s destroyed.</dd>\n<dd>PlayerStart - when a pawn spawns\
      \ in it.</dd>\n<dd>GameInfo - when the game ends, it triggers an event named\
      \ ‘EndGame’.</dd>\n<dd>Mover - when it finisheds opening.</dd>\n<dd>Mover -\
      \ when it bumps an actor, it triggers its BumpEvent or PlayerBumpEvent.</dd>\n\
      <dd>Pawn - when it’s killed.</dd>\n<dd>Pickup - when it’s picked up.</dd>\n\
      <dd>Teleporter - when it’s used.</dd>\n<dd>Trigger - when touched by a relevant\
      \ actor, or damaged if it’s a damageable trigger.</dd>\n<dd>PhysicsVolume -\
      \ when a player enters the volume.</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n<dd>Actor\
      \ iterator functions\n<dl>\n<dd>AllActors is slooow.</dd>\n<dd>DynamicActors\
      \ faster, since it skips all actors with bStatic==true</dd>\n<dd>TouchingActors\
      \ very fast (goes through actors Touching array)</dd>\n<dd>CollidingActors fast\
      \ for relatively small radii (uses collision hash)\n<dl>\n<dd>Radius relative\
      \ to level size - as long as only a small percentage of actors will be considered</dd>\n\
      </dl>\n</dd>\n</dl>\n</dd>\n<dd>Message broadcasting</dd>\n<dd>Tick() and PlayerTick()\
      \ - called every frame\n<dl>\n<dd>PlayerControllers get PlayerTick()</dd>\n\
      <dd>Avoid implementing tick() - scripts should be event driven to be efficient</dd>\n\
      </dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<h4><span class=\"mw-headline\" id=\"Pawn_and_Controller\"\
      ><a href=\"/Legacy:Pawn\" title=\"Legacy:Pawn\">Pawn</a> and <a href=\"/Legacy:Controller\"\
      \ title=\"Legacy:Controller\">Controller</a></span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=4\"\
      \ title=\"Edit section: Pawn and Controller\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd><b>Pawn</b> is physical representation of players/\
      \ NPC AIs in a level.\n<dl>\n<dd>Pawn specific physics properties (movement\
      \ speed, etc.) AI related flags (hearing, seeing capabilities</dd>\n<dd>Weapon/Inventory\
      \ handling functions - adding, removing, finding, selecting</dd>\n<dd>TakeDamage(),\
      \ Dying state</dd>\n<dd>NEW animation interface for pawns\n<dl>\n<dd>Animations\
      \ are generated client-side, reducing network bandwidth</dd>\n<dd>Pawns handle\
      \ animend(), not their controller (except for ScriptedControllers)</dd>\n<dd>Per\
      \ tick blending changes for smooth movement transitions Still prototype - will\
      \ use animation object interface</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<dl>\n\
      <dd><b>Controllers</b> are non-physical actors which can be attached to a pawn\
      \ to control its actions.\n<dl>\n<dd><b>PlayerControllers</b> are used by human\
      \ players to control pawns</dd>\n<dd><b>AIControllers</b> are used to implement\
      \ the artificial intelligence for the pawns they control.\n<dl>\n<dd><b>AIScripts</b>\
      \ can be associated with pawns placed in levels to modify their AIControllers.</dd>\n\
      </dl>\n</dd>\n<dd><b>ScriptedControllers</b> can be used to make a pawn follow\
      \ a scripted sequence, defined by <b>ScriptedSequence</b> ( a subclass of AIScript)\
      \ actors.</dd>\n<dd>Controllers use Possess() and UnPossess() to take or relinquish\
      \ control of a pawn.</dd>\n<dd>Controllers receive notifications for many of\
      \ the events occurring for the pawn they are controlling, giving them the opportunity\
      \ to intercept the event and supercede the Pawn’s default behavior.</dd>\n</dl>\n\
      </dd>\n<dd><b>PlayerController</b>\n<dl>\n<dd>\n<dl>\n<dd>Player control pre-processed\
      \ by PlayerInput object</dd>\n<dd>PlayerTick() called every frame to allow PlayerController\
      \ to control pawn based on player inputs.</dd>\n<dd>Player Movement states (PlayerWalking,\
      \ PlayerSwimming, etc) for each mode that has different control.</dd>\n</dl>\n\
      </dd>\n</dl>\n</dd>\n</dl>\n<h4><span class=\"mw-headline\" id=\"GameInfo_and_related_classes\"\
      >GameInfo and related classes</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=5\"\
      \ title=\"Edit section: GameInfo and related classes\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h4>\n<dl>\n<dd>Defines the game being\
      \ played: the game rules, scoring, what actors are allowed to exist in this\
      \ game type, and who may enter the game.</dd>\n<dd>GameInfo actor class is determined\
      \ by (in order) either the DefaultGameType if specified in the LevelInfo, or\
      \ the DefaultGame entry in the game’s .ini file (in the Engine.Engine section),\
      \ unless it’s a network game in which case the DefaultServerGame entry is used</dd>\n\
      <dd>The GameInfo’s InitGame() function is called before any other scripts (including\
      \ PreBeginPlay() ), and is used by the GameInfo to initialize parameters and\
      \ spawn its helper classes.</dd>\n<dd>The login process\n<dl>\n<dd>Used even\
      \ in single player game</dd>\n<dd>In a network game, the <b>AccessControl</b>\
      \ class determines whether or not player is allowed to login in PreLogin() function.\
      \ It also controls whether a player can enter as a participant, a spectator,\
      \ or a game administrator.</dd>\n<dd>Ulevel::SpawnPlayActor() calls the GameInfo\
      \ Login() function to spawn a player controller, then attaches a Player to the\
      \ returned PlayerController, then handles traveling inventory and properties.</dd>\n\
      <dd>The GameInfo Login() function\n<dl>\n<dd>Sets the player team, if relevant\
      \ (by calling PickTeam() and ChangeTeam())</dd>\n<dd>Finds an appropriate player\
      \ start (by calling FindPlayerStart() )</dd>\n<dd>Initializes the PlayerReplicationInfo</dd>\n\
      <dd>Validates the desired pawn class.</dd>\n<dd>If not a delayed start, start\
      \ match or spawn player pawn immediately, else wait for match to start.</dd>\n\
      </dl>\n</dd>\n</dl>\n</dd>\n<dd><b>Mutators</b> allow modifications to gameplay\
      \ while keeping game rules intact.</dd>\n<dd>Multiple mutators can be used together.\
      \ (intended for mod authors)\n<dl>\n<dd>ModifyLogin() used to modify player\
      \ login parameters.</dd>\n<dd>ModifyPlayer() used to modify player pawn properties.</dd>\n\
      <dd>GetDefaultWeapon() used to modify the default weapon for players.</dd>\n\
      <dd>CheckRelevance() used to modify, replace, or remove all actors. Called from\
      \ the PreBeginPlay() function of all actors except those (Decals, Effects and\
      \ Projectiles for performance reasons) which have bGameRelevant==true.</dd>\n\
      </dl>\n</dd>\n<dd><b>GameRules</b> specify optional modifications to game rules,\
      \ such as scoring, finding player starts, and damage modification. (intended\
      \ for mod authors)</dd>\n<dd><b>BroadcastHandler</b> handles both text messages\
      \ (typed by a player) and localized messages (which are identified by a LocalMessage\
      \ class and id).\n<dl>\n<dd>GameInfos produce localized messages using their\
      \ DeathMessageClass and GameMessageClass classes.</dd>\n</dl>\n</dd>\n</dl>\n\
      <h4><span class=\"mw-headline\" id=\"PlayerReplicationInfo.2C_GameReplicationInfo_and_TeamInfo\"\
      >PlayerReplicationInfo, GameReplicationInfo and TeamInfo</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=6\"\
      \ title=\"Edit section: PlayerReplicationInfo, GameReplicationInfo and TeamInfo\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h4>\n<dl>\n\
      <dd>Are always relevant, and contain replicated attributes which are important\
      \ to keep updated for all clients.</dd>\n<dd>Each player has an associated PlayerReplicationInfo,\
      \ and the GameInfo has an associated GameReplicationInfo.</dd>\n</dl>\n<h4><span\
      \ class=\"mw-headline\" id=\"LevelInfo\">LevelInfo</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=7\"\
      \ title=\"Edit section: LevelInfo\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Each level has one LevelInfo, automatically\
      \ generated by the level editor when the level is created.</dd>\n<dd>Always\
      \ the first actor in the actor list.</dd>\n<dd>Holds properties of global importance\
      \ in the level, such as the time (TimeSeconds), and the networking mode (NetMode\
      \ - server or client).</dd>\n<dd>All actors in the level have access to the\
      \ LevelInfo through their Level attribute.</dd>\n<dd>Has a reference to the\
      \ level’s GameInfo actor through its Game attribute. While there is a valid\
      \ LevelInfo actor for all servers and clients, only servers and standalone games\
      \ have GameInfos.</dd>\n<dd>The LevelInfo also contains two specialized actor\
      \ lists that are used for fast access to certain actor types. The ControllerList\
      \ is a linked list of all controllers in the level, and the NavigationPointList\
      \ is a linked list of all NavigationPoints in the level. These lists will probably\
      \ become obsolete when we change the Actor list to a TMap.</dd>\n</dl>\n<h4><span\
      \ class=\"mw-headline\" id=\"Volume.2C_PhysicsVolume.2C_and_BlockingVolume\"\
      >Volume, PhysicsVolume, and BlockingVolume</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=8\"\
      \ title=\"Edit section: Volume, PhysicsVolume, and BlockingVolume\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h4>\n<dl>\n<dd>Used for\
      \ defining areas with gameplay implications.</dd>\n<dd>Touch() and Untouch()\
      \ notifications to the volume as actors enter or leave it</dd>\n<dd>ActorEnteredVolume()\
      \ and ActorLeftVolume() notifications when center of actor enters the volume</dd>\n\
      <dd>Pawns with bIsPlayer==true cause PlayerEnteredVolume() and PlayerLeftVolume()\
      \ notifications instead.</dd>\n<dd>AssociatedActor also gets touch() and untouch()\
      \ notifications (for example, to create non-cylindrical triggers).</dd>\n<dd><b>BlockingVolumes</b>\
      \ used to provide fast, simple collision (around static meshes for example).\
      \ By default, they collide with non-zero extent traces only.</dd>\n<dd><b>PhysicsVolumes</b>\
      \ contain properties which affect physics of actors in them (gravity, etc.)\n\
      <dl>\n<dd>This functionality used to be in ZoneInfo.</dd>\n<dd>Priority attribute\
      \ determines which PhysicsVolume has precedence.</dd>\n<dd>PhysicsVolumes also\
      \ have built in support for entry and exit sounds/actors.</dd>\n<dd>PhysicsVolumes\
      \ can cause recurring damage to actors in them.</dd>\n</dl>\n</dd>\n</dl>\n\
      <h4><span class=\"mw-headline\" id=\"NavigationPoints\">NavigationPoints</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=9\" title=\"\
      Edit section: NavigationPoints\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Organized into network to provide AIControllers\
      \ the capability of determining paths to arbitrary destinations in a level.</dd>\n\
      <dd>Each NavigationPoint has a PathList of ReachSpecs which describe paths which\
      \ can be reached from that node.</dd>\n<dd>Each ReachSpec specifies a destination,\
      \ and the movement requirements (size, physics modes, etc.) required to take\
      \ that path.</dd>\n<dd>NEW UpstreamPaths[] and PrunedPaths[] were removed from\
      \ the latest code, and Reachspecs are now UnrealScript defined actors. PathList\
      \ is now a dynamic array.</dd>\n<dd>Special NavigationPoint types (door, ladder,\
      \ liftcenter and liftexit) used to specify navigation in conjunction with movers.\
      \ Interface for telling AI how to use these paths described later.</dd>\n</dl>\n\
      <h4><span class=\"mw-headline\" id=\"Inventory.2C_Pickup.2C_and_AttachedInventory\"\
      >Inventory, Pickup, and AttachedInventory</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=10\"\
      \ title=\"Edit section: Inventory, Pickup, and AttachedInventory\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h4>\n<dl>\n<dd><b>Pickup</b>\
      \ is the base class of actors that when touched by an appropriate pawn, will\
      \ create and place an Inventory actor in that pawn’s inventory chain.\n<dl>\n\
      <dd>Has an associated inventory class (its InventoryType).</dd>\n<dd>Placed\
      \ by level designers.</dd>\n<dd>Can only interact with pawns when in their default\
      \ Pickup state. Pickups verify that they can give inventory to a pawn by calling\
      \ the GameInfo’s PickupQuery() function. After a pickup spawns an inventory\
      \ item for a pawn, it then queries the GameInfo by calling the GameInfo’s ShouldRespawn()\
      \ function about whether it should remain active, enter its Sleep state and\
      \ later become active again, or destroy itself.</dd>\n<dd>Has an AI interface\
      \ to allow AIControllers, such as bots, to assess the desireability of acquiring\
      \ that pickup. The BotDesireability() method returns a float typically between\
      \ 0 and 1 describing how valuable the pickup is to the AIController. This method\
      \ is called when an AIController uses the FindPathToBestInventory() navigation\
      \ intrinsic.</dd>\n<dd>When navigation paths are built, each pickup has an InventorySpot\
      \ (a subclass of NavigationPoint) placed on it and associated with it (the Pickup’\
      s MyMarker== the InventorySpot, and the InventorySpot’s markedItem == the pickup).</dd>\n\
      </dl>\n</dd>\n</dl>\n<dl>\n<dd><b>Inventory</b> is the parent class of all actors\
      \ that can be carried by other actors.\n<dl>\n<dd>Placed in the holding actor’\
      s inventory chain, a linked list of inventory actors.</dd>\n<dd>Each inventory\
      \ class knows what pickup can spawn it (its PickupClass).</dd>\n<dd>When tossed\
      \ out (using the DropFrom() function), inventory items replace themselves with\
      \ an actor of their Pickup class.</dd>\n<dd>Most Inventory actors are never\
      \ rendered. The common exception is Weapon actors. Inventory actors may be rendered\
      \ in the first person view of the player holding them, with the Inventory function,\
      \ using the RenderOverlays() function. The CalcDrawOffset() function determines\
      \ where to render the item on the player’s screen.</dd>\n<dd>Inventory items\
      \ may also be rendered attached to the player’s mesh, by spawning an appropriate\
      \ <b>InventoryAttachment</b> actor.</dd>\n</dl>\n</dd>\n</dl>\n<h4><span class=\"\
      mw-headline\" id=\"Weapon.2C_AttachedWeapon.2C_Projectile_and_Ammunition\">Weapon,\
      \ AttachedWeapon, Projectile and Ammunition</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=11\"\
      \ title=\"Edit section: Weapon, AttachedWeapon, Projectile and Ammunition\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h4>\n<dl>\n\
      <dd>Pawns use weapons by calling the weapon’s fire() or altfire() function.\
      \ Each pawn has one currently active weapon (specified by its Weapon attribute).</dd>\n\
      <dd>NEW All weapons require ammunition. When a weapon is given to a pawn, it\
      \ will spawn the appropriate Ammunition actor (as determined by the weapon’\
      s AmmoName attribute) in the pawn’s inventory chain if it does not exist, or\
      \ adding the weapon’s PickupAmmoCount to the ammunition if it does. Whenever\
      \ a weapon fires, it will first call its Ammunition’s UseAmmo() function to\
      \ verify that ammunition is available, and if so reduce the remaining ammunition.</dd>\n\
      <dd>NEW Ammunition is now responsible for spawning the appropriate Projectile\
      \ or processing a trace hit. This allows weapons to have multiple ammunition\
      \ types each with different behavior (replaces old fire()/altfire() behavior).</dd>\n\
      <dd>NEW weapon firing code updated - described in detail in networking session.</dd>\n\
      <dd>Weapon AI interface used for picking the appropriate weapon (the RecommendWeapon()\
      \ function, which compares the value of the weapons available in the inventory\
      \ chain), and determining the tactics to use with it.</dd>\n<dd>RateSelf() specifies\
      \ how valuable the weapon is in the controller’s current tactical situation.</dd>\n\
      <dd>SuggestAttackStyle() tells the controller whether it should be aggressive\
      \ or cautious when using this type of weapon, while SuggestDefenseStyle() tells\
      \ the controller whether it should be aggressive or cautious when being attacked\
      \ by an enemy wielding this weapon. Ammunition now also has an AI interface\
      \ ( RateSelf() ) because of its expanded role.</dd>\n</dl>\n<h4><span class=\"\
      mw-headline\" id=\"Mover\">Mover</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=12\"\
      \ title=\"Edit section: Mover\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Movers are Actors with a StaticMesh that moves\
      \ between its keyframes when triggered depending on its initial state.</dd>\n\
      <dd>Movers send notifications to AIs that have sent them as their PendingMover.</dd>\n\
      </dl>\n<h4><span class=\"mw-headline\" id=\"Trigger\">Trigger</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=13\"\
      \ title=\"Edit section: Trigger\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>When enabled generates events when triggered\
      \ by an appropriate actor (usually by touching, or by shooting.</dd>\n</dl>\n\
      <h4><span class=\"mw-headline\" id=\"Effects\">Effects</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=14\"\
      \ title=\"Edit section: Effects\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Base class of all gratuitous special effects.</dd>\n\
      <dd>Generally should not be replicated, but rather spawned on client side by\
      \ other replicated actors.</dd>\n</dl>\n<h4><span class=\"mw-headline\" id=\"\
      Damagetype\">Damagetype</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=15\"\
      \ title=\"Edit section: Damagetype\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Abstract classes which are responsible for\
      \ specifiying many damage related attributes, such as the effects (blood, screen\
      \ flash, etc.) associated with that damage, and the string to print to describe\
      \ deaths by that type of damage.</dd>\n<dd>Passed as a parameter of the actor\
      \ TakeDamage() function.</dd>\n</dl>\n<h4><span class=\"mw-headline\" id=\"\
      LocalMessage\">LocalMessage</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=16\"\
      \ title=\"Edit section: LocalMessage\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>Abstract classes which contain an array of\
      \ localized text .</dd>\n<dd>The PlayerController function ReceiveLocalizedMessage()\
      \ is used to send messages to a specific player by specifying the LocalMessage\
      \ class and index. This allows the message to be localized on the client side,\
      \ and saves network bandwidth since the text is not sent.</dd>\n</dl>\n<h4><span\
      \ class=\"mw-headline\" id=\"HUD_and_Scoreboard\">HUD and Scoreboard</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=17\" title=\"\
      Edit section: HUD and Scoreboard\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>The <b>HUD</b> is responsible for drawing any\
      \ information overlay.\n<dl>\n<dd>The local player always has a valid HUD.</dd>\n\
      <dd>The HUD type is defined by the GameInfo actor.</dd>\n<dd>Every frame, the\
      \ HUD’s postrender function is called after the world has been rendered.</dd>\n\
      <dd>ShowDebug exec will show debug parameters of currently viewed actor (use\
      \ ViewClass xxx to change viewed actor).</dd>\n</dl>\n</dd>\n</dl>\n<h3><span\
      \ class=\"mw-headline\" id=\"PART_II_-_Game_code_in_C.2B.2B\">PART II - Game\
      \ code in C++</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=18\"\
      \ title=\"Edit section: PART II - Game code in C++\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<h4><span class=\"mw-headline\"\
      \ id=\"Navigation_AI\">Navigation AI</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=19\"\
      \ title=\"Edit section: Navigation AI\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<dl>\n<dd>\n<dl>\n<dd>Reachspecs must be built before\
      \ navigation network can be used (in the UnrealEd build menu).</dd>\n<dd>Controllers\
      \ can check if a nearby point or actor (less than MAXPATHDIST away) is directly\
      \ reachable using PointReachable() and ActorReachable().</dd>\n<dd>MoveToward()\
      \ and MoveTo() are latent functions which cause the Controller’s pawn to move\
      \ toward the specified destination. State code execution continues when either\
      \ the destination is reached, or progress is no longer possible.\n<dl>\n<dd>If\
      \ the move is from one NavigationPoint to another, the destination NavigationPoint’\
      s SuggestMovePreparation() is called if it isimplemented, to allow it to direct\
      \ the pawn to perform some action first.</dd>\n<dd>The AIController functions\
      \ WaitForMover() and MoverFinished() provide an interface between a mover/its\
      \ navigationpoint and the controller.</dd>\n<dd>If the current pawn’s collision\
      \ or other properties are not supported by the path between the navigation points,\
      \ the AIController’s PrepareForMove() is called (to allow it to crouch, for\
      \ example).</dd>\n<dd>While the pawn’s bPreparingMove== true, the movement is\
      \ suspended.</dd>\n</dl>\n</dd>\n<dd>For destinations that aren’t directly reachable,\
      \ FindPathToward() and FindPathTo () will return the NavigationPoint to move\
      \ directly toward to reach that destination. When the NavigationPoint is reached,\
      \ call FindPathxxx() again to determine the next path (with any dynamic path\
      \ network changes considered).\n<dl>\n<dd>The Controller’s RouteCache[] array\
      \ contains the first 16</dd>\n<dd>NavigationPoints in the best path determined\
      \ toward the destination.</dd>\n</dl>\n</dd>\n<dd>NodeEvaluator functions can\
      \ be defined to specify node desireability for routing when a specific destination\
      \ is not specified. Path finding code drops out immediately if result is &gt;=\
      \ 1.0. FindPathTowardNearest(), FindRandomDest() are example native script functions\
      \ which take advantage of this capability.</dd>\n</dl>\n</dd>\n</dl>\n<h4><span\
      \ class=\"mw-headline\" id=\"Actor_creation_and_destruction\">Actor creation\
      \ and destruction</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=20\"\
      \ title=\"Edit section: Actor creation and destruction\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h4>\n<dl>\n<dd>\n<dl>\n<dd>Spawn()\
      \ in script calls SpawnActor() in C++\n<dl>\n<dd>For script spawned actors,\
      \ the spawned actor’s instigator is automatically set to be the instigator of\
      \ the actor which is calling Spawn().</dd>\n<dd>Actor must fit where it is placed\
      \ in the world, or it won’t be spawned.</dd>\n<dd>After initialization (with\
      \ exceptions noted below), the following actor events are called:\n<dl>\n<dd>Spawned()\
      \ - C++</dd>\n<dd>PreBeginPlay() - script (handles destruction if not game relevant)\
      \ BeginPlay() - script</dd>\n<dd>PostBeginPlay() - script</dd>\n<dd>PostNetBeginPlay()\
      \ - script (Called after replicated properties of actor have been updated -\
      \ note that replication at this point isn’t guaranteed)</dd>\n<dd>If actor has\
      \ an auto state, its BeginState() is called.</dd>\n</dl>\n</dd>\n<dd>Final initialization\
      \ of the actor is done just before calling PostBeginPlay() in the following\
      \ order:\n<dl>\n<dd>The actor’s ZoneInfo and PhysicsVolume are set.</dd>\n<dd>Collision\
      \ with blocking non-world geometry actors is resolved using actor events EncroachingOn()\
      \ and EncroachedBy().</dd>\n</dl>\n</dd>\n<dd>Touching notifies currently don’\
      t happen when actor is spawned.</dd>\n</dl>\n</dd>\n<dd>Actor creation at level\
      \ startup\n<dl>\n<dd>InitGame is called on the GameInfo</dd>\n<dd>Spawned()\
      \ is not called.</dd>\n<dd>PreBeginPlay() is called for all actors</dd>\n<dd>BeginPlay()\
      \ called for all actors</dd>\n<dd>ZoneInfos and Volumes set for all actors</dd>\n\
      <dd>PostBeginPlay() called for all actors</dd>\n<dd>PostNetBeginPlay() called\
      \ for all actors</dd>\n<dd>BeginState() is called for all actors with initial\
      \ state</dd>\n</dl>\n</dd>\n<dd>Actor destruction\n<dl>\n<dd>Initially bDeleteMe\
      \ is set</dd>\n<dd>When 255 actors marked for deletion, they are cleaned up,\
      \ with all actor references to other actors removed.</dd>\n<dd>Currently, deleted\
      \ actors may still be visible to script before cleanup. Will be changed in next\
      \ version - note potential issues to avoid.</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n\
      </dl>\n<h4><span class=\"mw-headline\" id=\"Physics_and_world_interaction\"\
      >Physics and world interaction</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Unreal_Engine_And_Game_Code_Overview?section=21\"\
      \ title=\"Edit section: Physics and world interaction\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h4>\n<dl>\n<dd>\n<dl>\n<dd>Touch()\
      \ and Untouch() notifications used for collisions between actors for whom collision\
      \ is enabled, but which don’t block each other.\n<dl>\n<dd>Occurs during one\
      \ actor’s physics. Avoid infinite loops (singular keyword is simple fix).</dd>\n\
      <dd>Use PendingTouch actor list for actors which want to add an effect after\
      \ the move completes using the PostTouch() notification.</dd>\n</dl>\n</dd>\n\
      <dd>Bump() notification sent when actors which block each other collide.\n<dl>\n\
      <dd>Occurs during one actor’s physics. Avoid infinite loops (singular keyword\
      \ is simple fix).</dd>\n</dl>\n</dd>\n<dd>Base/Attached actors\n<dl>\n<dd>When\
      \ actor gets its base set, it is added to the base’s Attached array</dd>\n<dd>Base\
      \ gets Detach() and Attach()notifications</dd>\n<dd>Actor gets BaseChanged()\
      \ notification</dd>\n<dd>Base can change when:\n<dl>\n<dd>Change physics mode</dd>\n\
      <dd>Teleport (lose attached actors)</dd>\n<dd>Pawn walking</dd>\n<dd>SetBase()\
      \ from script</dd>\n</dl>\n</dd>\n<dd>Special case if AttachmentBone!=None</dd>\n\
      </dl>\n</dd>\n<dd>Actor Physics modes\n<dl>\n<dd>PHYS_Projectile</dd>\n<dd>PHYS_Falling:</dd>\n\
      <dd>PHYS_Rotating: Rotation, no translation</dd>\n<dd>PHYS_Trailer: soon obsolete</dd>\n\
      <dd>PHYS_RootMotion: under construction</dd>\n<dd>Rotation\n<dl>\n<dd>Not updated\
      \ if PHYS_None</dd>\n<dd>If bFixedRotationDir==true, will continue rotating\
      \ in same direction, even after reaching DesiredRotation.</dd>\n<dd>If bRotateToDesired==true,\
      \ will rotate to DesiredRotation and stop.</dd>\n</dl>\n</dd>\n<dd>Physics notifications:\n\
      <dl>\n<dd>HitWall()</dd>\n<dd>Landed() (HitNormal.Z &gt; MINFLOORZ)</dd>\n</dl>\n\
      </dd>\n</dl>\n</dd>\n<dd>Pawn physics modes\n<dl>\n<dd>PHYS_Walking\n<dl>\n\
      <dd>Optional Check for ledges - MayFall() notification\n<dl>\n<dd>For AI if&#160;!bCanWalkOffLedges,\
      \ with optional</dd>\n<dd>bAvoidLedges (keep away from them).</dd>\n</dl>\n\
      </dd>\n<dd>MinHitWall to limit HitWall() notifications</dd>\n</dl>\n</dd>\n\
      <dd>PHYS_Falling</dd>\n<dd>PHYS_Flying</dd>\n<dd>PHYS_Swimming</dd>\n<dd>PHYS_Spider</dd>\n\
      <dd>PHYS_Ladder</dd>\n<dd>PHYS_RootMotion: under construction</dd>\n<dd>Rotation\
      \ ( APawn&#160;:: PhysicsRotation() )\n<dl>\n<dd>bCrawler to orient in floor\
      \ direction</dd>\n<dd>No pitching when on ground.</dd>\n<dd>If not bCrawler,\
      \ roll when angular momentum</dd>\n</dl>\n</dd>\n<dd>Crouching:\n<dl>\n<dd>Can\
      \ only crouch if bCanCrouch==true</dd>\n<dd>To request crouch, set bWantsToCrouch</dd>\n\
      <dd>bIsCrouched==true while crouched</dd>\n<dd>bTryToUncrouch is true for AI\
      \ pawns which automatically crouched during movement - they continually try\
      \ to stand up.</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<p><b>OBWANDO:</b>\
      \ I've tried to keep all formatting correct and in place. If anyone wants to\
      \ help link up the major portions of the areas, it would be appreciated. Ill\
      \ do as much as I can. Also, if someone wants to start a UT2003 page like this\
      \ one, Ill donate to it as well to make it as complete as possible.</p>\n\n\
      <!-- \nNewPP limit report\nCPU time usage: 0.073 seconds\nReal time usage: 0.346\
      \ seconds\nPreprocessor visited node count: 83/1000000\nPreprocessor generated\
      \ node count: 88/1000000\nPost‐expand include size: 0/2097152 bytes\nTemplate\
      \ argument size: 0/2097152 bytes\nHighest expansion depth: 2/40\nExpensive parser\
      \ function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report (%,ms,calls,template)\n\
      100.00%    0.000      1 - -total\n-->\n\n<!-- Saved in parser cache with key\
      \ wiki:pcache:idhash:3460-0!*!0!!en!*!* and timestamp 20221117211138 and revision\
      \ id 8892\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:Pawn"
  - ns: 100
    exists: true
    name: "Legacy:Controller"
  - ns: 100
    exists: true
    name: "Legacy:UT2003"
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  templates: []
  images: []
  externallinks:
  - "http://udn.epicgames.com/pub/Technical/GameAndAIHandout/gameai.pdf"
  sections:
  - toclevel: 1
    level: "2"
    line: "Unreal Engine AI and Game Code Overview"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 358
    anchor: "Unreal_Engine_AI_and_Game_Code_Overview"
  - toclevel: 2
    level: "3"
    line: "PART I - Engine Classes defined in UnrealScript"
    number: "1.1"
    index: "2"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 445
    anchor: "PART_I_-_Engine_Classes_defined_in_UnrealScript"
  - toclevel: 3
    level: "4"
    line: "Actor"
    number: "1.1.1"
    index: "3"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 500
    anchor: "Actor"
  - toclevel: 3
    level: "4"
    line: "Pawn and Controller"
    number: "1.1.2"
    index: "4"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 2189
    anchor: "Pawn_and_Controller"
  - toclevel: 3
    level: "4"
    line: "GameInfo and related classes"
    number: "1.1.3"
    index: "5"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 3922
    anchor: "GameInfo_and_related_classes"
  - toclevel: 3
    level: "4"
    line: "PlayerReplicationInfo, GameReplicationInfo and TeamInfo"
    number: "1.1.4"
    index: "6"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 6350
    anchor: "PlayerReplicationInfo.2C_GameReplicationInfo_and_TeamInfo"
  - toclevel: 3
    level: "4"
    line: "LevelInfo"
    number: "1.1.5"
    index: "7"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 6634
    anchor: "LevelInfo"
  - toclevel: 3
    level: "4"
    line: "Volume, PhysicsVolume, and BlockingVolume"
    number: "1.1.6"
    index: "8"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 7561
    anchor: "Volume.2C_PhysicsVolume.2C_and_BlockingVolume"
  - toclevel: 3
    level: "4"
    line: "NavigationPoints"
    number: "1.1.7"
    index: "9"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 8566
    anchor: "NavigationPoints"
  - toclevel: 3
    level: "4"
    line: "Inventory, Pickup, and AttachedInventory"
    number: "1.1.8"
    index: "10"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 9302
    anchor: "Inventory.2C_Pickup.2C_and_AttachedInventory"
  - toclevel: 3
    level: "4"
    line: "Weapon, AttachedWeapon, Projectile and Ammunition"
    number: "1.1.9"
    index: "11"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 11415
    anchor: "Weapon.2C_AttachedWeapon.2C_Projectile_and_Ammunition"
  - toclevel: 3
    level: "4"
    line: "Mover"
    number: "1.1.10"
    index: "12"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 13048
    anchor: "Mover"
  - toclevel: 3
    level: "4"
    line: "Trigger"
    number: "1.1.11"
    index: "13"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 13258
    anchor: "Trigger"
  - toclevel: 3
    level: "4"
    line: "Effects"
    number: "1.1.12"
    index: "14"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 13383
    anchor: "Effects"
  - toclevel: 3
    level: "4"
    line: "Damagetype"
    number: "1.1.13"
    index: "15"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 13546
    anchor: "Damagetype"
  - toclevel: 3
    level: "4"
    line: "LocalMessage"
    number: "1.1.14"
    index: "16"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 13858
    anchor: "LocalMessage"
  - toclevel: 3
    level: "4"
    line: "HUD and Scoreboard"
    number: "1.1.15"
    index: "17"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 14208
    anchor: "HUD_and_Scoreboard"
  - toclevel: 2
    level: "3"
    line: "PART II - Game code in C++"
    number: "1.2"
    index: "18"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 14599
    anchor: "PART_II_-_Game_code_in_C.2B.2B"
  - toclevel: 3
    level: "4"
    line: "Navigation AI"
    number: "1.2.1"
    index: "19"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 14633
    anchor: "Navigation_AI"
  - toclevel: 3
    level: "4"
    line: "Actor creation and destruction"
    number: "1.2.2"
    index: "20"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 16502
    anchor: "Actor_creation_and_destruction"
  - toclevel: 3
    level: "4"
    line: "Physics and world interaction"
    number: "1.2.3"
    index: "21"
    fromtitle: "Legacy:Unreal_Engine_And_Game_Code_Overview"
    byteoffset: 18277
    anchor: "Physics_and_world_interaction"
  displaytitle: "Legacy:Unreal Engine And Game Code Overview"
  iwlinks: []
  wikitext:
    text: "The original PDF is here: * http://udn.epicgames.com/pub/Technical/GameAndAIHandout/gameai.pdf\n\
      \nNote that this handout is a couple of years old, so some of the information\
      \  is outdated.  Also, the weapon system in [[Legacy:UT2003|UT2003]] is completely\
      \ different from the one described in the Game/AI handout (the UT2003 weapon\
      \ system was developed by DE).\n\n==Unreal Engine AI and Game Code Overview==\n\
      \nSteven Polge Epic Games October 16, 2001\n\n===PART I - Engine Classes defined\
      \ in UnrealScript===\n\n====[[Legacy:Actor|Actor]]====\n:Base class of all gameplay\
      \ objects.\n:A large number of properties, behaviors and interfaces are implemented\
      \ in the\n:base Actor class, including:\n::Display\n::Animation\n::Physics and\
      \ world interaction (discussed later) \n::Making sounds\n::Networking properties\
      \ (discussed in networking session).\n::Actor creation and destruction (discussed\
      \ later)\n::Triggering and timers\n:::When an actor with a defined event calls\
      \ TriggerEvent() or UntriggerEvent(), the Trigger() or Untrigger() function\
      \ is called for all actors with the matching tag.\n:::An actor’s event is triggered\
      \ for the following events:\n::::Decoration - when it’s destroyed.\n::::PlayerStart\
      \ - when a pawn spawns in it.\n::::GameInfo - when the game ends, it triggers\
      \ an event named ‘EndGame’.\n::::Mover - when it finisheds opening.\n::::Mover\
      \ - when it bumps an actor, it triggers its BumpEvent or PlayerBumpEvent.\n\
      ::::Pawn - when it’s killed.\n::::Pickup - when it’s picked up. \n::::Teleporter\
      \ - when it’s used.\n::::Trigger - when touched by a relevant actor, or damaged\
      \ if it’s a damageable trigger.\n::::PhysicsVolume - when a player enters the\
      \ volume.\n::Actor iterator functions\n:::AllActors is slooow.\n:::DynamicActors\
      \ faster, since it skips all actors with bStatic==true \n:::TouchingActors very\
      \ fast (goes through actors Touching array)\n:::CollidingActors fast for relatively\
      \ small radii (uses collision hash)\n::::Radius relative to level size - as\
      \ long as only a small percentage of actors will be considered\n::Message broadcasting\
      \ \n::Tick() and PlayerTick() - called every frame\n:::PlayerControllers get\
      \ PlayerTick()\n:::Avoid implementing tick() - scripts should be event driven\
      \ to be efficient \n\n====[[Legacy:Pawn|Pawn]] and [[Legacy:Controller|Controller]]====\n\
      :'''Pawn''' is physical representation of players/ NPC AIs in a level.\n::Pawn\
      \ specific physics properties (movement speed, etc.) AI related flags (hearing,\
      \ seeing capabilities\n::Weapon/Inventory handling functions - adding, removing,\
      \ finding, selecting\n::TakeDamage(), Dying state\n::NEW animation interface\
      \ for pawns\n:::Animations are generated client-side, reducing network bandwidth\
      \ \n:::Pawns handle animend(), not their controller (except for ScriptedControllers)\n\
      :::Per tick blending changes for smooth movement transitions Still prototype\
      \ - will use animation object interface\n\n:'''Controllers''' are non-physical\
      \ actors which can be attached to a pawn to control its actions.\n::'''PlayerControllers'''\
      \ are used by human players to control pawns \n::'''AIControllers''' are used\
      \ to implement the artificial intelligence for the pawns they control.\n:::'''AIScripts'''\
      \ can be associated with pawns placed in levels to modify their AIControllers.\n\
      ::'''ScriptedControllers''' can be used to make a pawn follow a scripted sequence,\
      \ defined by '''ScriptedSequence''' ( a subclass of AIScript) actors.\n::Controllers\
      \ use Possess() and UnPossess() to take or relinquish control of a pawn.\n::Controllers\
      \ receive notifications for many of the events occurring for the pawn they are\
      \ controlling, giving them the opportunity to intercept the event and supercede\
      \ the Pawn’s default behavior.\n:'''PlayerController'''\n:::Player control pre-processed\
      \ by PlayerInput object\n:::PlayerTick() called every frame to allow PlayerController\
      \ to control pawn based on player inputs.\n:::Player Movement states (PlayerWalking,\
      \ PlayerSwimming, etc) for each mode that has different control.\n\n====GameInfo\
      \ and related classes ====\n:Defines the game being played: the game rules,\
      \ scoring, what actors are allowed to exist in this game type, and who may enter\
      \ the game.\n:GameInfo actor class is determined by (in order) either the DefaultGameType\
      \ if specified in the LevelInfo, or the DefaultGame entry in the game’s .ini\
      \ file (in the Engine.Engine section), unless it’s a network game in which case\
      \ the DefaultServerGame entry is used\n:The GameInfo’s InitGame() function is\
      \ called before any other scripts (including PreBeginPlay() ), and is used by\
      \ the GameInfo to initialize parameters and spawn its helper classes.\n:The\
      \ login process\n::Used even in single player game\n::In a network game, the\
      \ '''AccessControl''' class determines whether or not player is allowed to login\
      \ in PreLogin() function. It also controls whether a player can enter as a participant,\
      \ a spectator, or a game administrator. \n::Ulevel::SpawnPlayActor() calls the\
      \ GameInfo Login() function to spawn a player controller, then attaches a Player\
      \ to the returned PlayerController, then handles traveling inventory and properties.\n\
      ::The GameInfo Login() function\n:::Sets the player team, if relevant (by calling\
      \ PickTeam() and ChangeTeam())\n:::Finds an appropriate player start (by calling\
      \ FindPlayerStart() ) \n:::Initializes the PlayerReplicationInfo\n:::Validates\
      \ the desired pawn class. \n:::If not a delayed start, start match or spawn\
      \ player pawn immediately, else wait for match to start.\n:'''Mutators''' allow\
      \ modifications to gameplay while keeping game rules intact.\n:Multiple mutators\
      \ can be used together. (intended for mod authors) \n::ModifyLogin() used to\
      \ modify player login parameters. \n::ModifyPlayer() used to modify player pawn\
      \ properties. \n::GetDefaultWeapon() used to modify the default weapon for players.\
      \ \n::CheckRelevance() used to modify, replace, or remove all actors. Called\
      \ from the PreBeginPlay() function of all actors except those (Decals, Effects\
      \ and Projectiles for performance reasons) which have bGameRelevant==true.\n\
      :'''GameRules''' specify optional modifications to game rules, such as scoring,\
      \ finding player starts, and damage modification. (intended for mod authors)\
      \ \n:'''BroadcastHandler''' handles both text messages (typed by a player) and\
      \ localized messages (which are identified by a LocalMessage class and id).\n\
      ::GameInfos produce localized messages using their DeathMessageClass and GameMessageClass\
      \ classes.\n\n====PlayerReplicationInfo, GameReplicationInfo and TeamInfo====\n\
      :Are always relevant, and contain replicated attributes which are important\
      \ to keep updated for all clients.\n:Each player has an associated PlayerReplicationInfo,\
      \ and the GameInfo has an associated GameReplicationInfo.\n\n====LevelInfo====\n\
      :Each level has one LevelInfo, automatically generated by the level editor when\
      \ the level is created.\n:Always the first actor in the actor list.\n:Holds\
      \ properties of global importance in the level, such as the time (TimeSeconds),\
      \ and the networking mode (NetMode - server or client).\n:All actors in the\
      \ level have access to the LevelInfo through their Level attribute.\n:Has a\
      \ reference to the level’s GameInfo actor through its Game attribute. While\
      \ there is a valid LevelInfo actor for all servers and clients, only servers\
      \ and standalone games have GameInfos.\n:The LevelInfo also contains two specialized\
      \ actor lists that are used for fast access to certain actor types. The ControllerList\
      \ is a linked list of all controllers in the level, and the NavigationPointList\
      \ is a linked list of all NavigationPoints in the level. These lists will probably\
      \ become obsolete when we change the Actor list to a TMap.\n\n====Volume, PhysicsVolume,\
      \ and BlockingVolume====\n:Used for defining areas with gameplay implications.\n\
      :Touch() and Untouch() notifications to the volume as actors enter or leave\
      \ it\n:ActorEnteredVolume() and ActorLeftVolume() notifications when center\
      \ of actor enters the volume\n:Pawns with bIsPlayer==true cause PlayerEnteredVolume()\
      \ and PlayerLeftVolume() notifications instead.\n:AssociatedActor also gets\
      \ touch() and untouch() notifications (for example, to create non-cylindrical\
      \ triggers).\n:'''BlockingVolumes''' used to provide fast, simple collision\
      \ (around static meshes for example). By default, they collide with non-zero\
      \ extent traces only. \n:'''PhysicsVolumes''' contain properties which affect\
      \ physics of actors in them (gravity, etc.)\n::This functionality used to be\
      \ in ZoneInfo.\n::Priority attribute determines which PhysicsVolume has precedence.\
      \ \n::PhysicsVolumes also have built in support for entry and exit sounds/actors.\n\
      ::PhysicsVolumes can cause recurring damage to actors in them.\n\n====NavigationPoints\
      \ ====\n:Organized into network to provide AIControllers the capability of determining\
      \ paths to arbitrary destinations in a level.\n:Each NavigationPoint has a PathList\
      \ of ReachSpecs which describe paths which can be reached from that node.\n\
      :Each ReachSpec specifies a destination, and the movement requirements (size,\
      \ physics modes, etc.) required to take that path.\n:NEW UpstreamPaths[] and\
      \ PrunedPaths[] were removed from the latest code, and Reachspecs are now UnrealScript\
      \ defined actors. PathList is now a dynamic array.\n:Special NavigationPoint\
      \ types (door, ladder, liftcenter and liftexit) used to specify navigation in\
      \ conjunction with movers. Interface for telling AI how to use these paths described\
      \ later.\n\n====Inventory, Pickup, and AttachedInventory====\n:'''Pickup'''\
      \ is the base class of actors that when touched by an appropriate pawn, will\
      \ create and place an Inventory actor in that pawn’s inventory chain.\n::Has\
      \ an associated inventory class (its InventoryType).\n::Placed by level designers.\n\
      ::Can only interact with pawns when in their default Pickup state. Pickups verify\
      \ that they can give inventory to a pawn by calling the GameInfo’s PickupQuery()\
      \ function. After a pickup spawns an inventory item for a pawn, it then queries\
      \ the GameInfo by calling the GameInfo’s ShouldRespawn() function about whether\
      \ it should remain active, enter its Sleep state and later become active again,\
      \ or destroy itself. \n::Has an AI interface to allow AIControllers, such as\
      \ bots, to assess the desireability of acquiring that pickup. The BotDesireability()\
      \ method returns a float typically between 0 and 1 describing how valuable the\
      \ pickup is to the AIController. This method is called when an AIController\
      \ uses the FindPathToBestInventory() navigation intrinsic. \n::When navigation\
      \ paths are built, each pickup has an InventorySpot (a subclass of NavigationPoint)\
      \ placed on it and associated with it (the Pickup’s MyMarker== the InventorySpot,\
      \ and the InventorySpot’s markedItem == the pickup).\n\n:'''Inventory''' is\
      \ the parent class of all actors that can be carried by other actors. \n::Placed\
      \ in the holding actor’s inventory chain, a linked list of inventory actors.\n\
      ::Each inventory class knows what pickup can spawn it (its PickupClass). \n\
      ::When tossed out (using the DropFrom() function), inventory items replace themselves\
      \ with an actor of their Pickup class. \n::Most Inventory actors are never rendered.\
      \ The common exception is Weapon actors. Inventory actors may be rendered in\
      \ the first person view of the player holding them, with the Inventory function,\
      \ using the RenderOverlays() function. The CalcDrawOffset() function determines\
      \ where to render the item on the player’s screen. \n::Inventory items may also\
      \ be rendered attached to the player’s mesh, by spawning an appropriate '''InventoryAttachment'''\
      \ actor.\n\n====Weapon, AttachedWeapon, Projectile and Ammunition====\n:Pawns\
      \ use weapons by calling the weapon’s fire() or altfire() function. Each pawn\
      \ has one currently active weapon (specified by its Weapon attribute).\n:NEW\
      \ All weapons require ammunition. When a weapon is given to a pawn, it will\
      \ spawn the appropriate Ammunition actor (as determined by the weapon’s AmmoName\
      \ attribute) in the pawn’s inventory chain if it does not exist, or adding the\
      \ weapon’s PickupAmmoCount to the ammunition if it does. Whenever a weapon fires,\
      \ it will first call its Ammunition’s UseAmmo() function to verify that ammunition\
      \ is available, and if so reduce the remaining ammunition.\n:NEW Ammunition\
      \ is now responsible for spawning the appropriate Projectile or processing a\
      \ trace hit. This allows weapons to have multiple ammunition types each with\
      \ different behavior (replaces old fire()/altfire() behavior). \n:NEW weapon\
      \ firing code updated - described in detail in networking session.\n:Weapon\
      \ AI interface used for picking the appropriate weapon (the RecommendWeapon()\
      \ function, which compares the value of the weapons available in the inventory\
      \ chain), and determining the tactics to use with it. \n:RateSelf() specifies\
      \ how valuable the weapon is in the controller’s current tactical situation.\
      \ \n:SuggestAttackStyle() tells the controller whether it should be aggressive\
      \ or cautious when using this type of weapon, while SuggestDefenseStyle() tells\
      \ the controller whether it should be aggressive or cautious when being attacked\
      \  by an enemy wielding this weapon. Ammunition now also has an AI interface\
      \ ( RateSelf() ) because of its expanded role.\n\n====Mover====\n:Movers are\
      \ Actors with a StaticMesh that moves between its keyframes when triggered depending\
      \ on its initial state. \n:Movers send notifications to AIs that have sent them\
      \ as their PendingMover.\n\n====Trigger====\n:When enabled generates events\
      \ when triggered by an appropriate actor (usually by touching, or by shooting.\n\
      \n====Effects====\n:Base class of all gratuitous special effects.\n:Generally\
      \ should not be replicated, but rather spawned on client side by other replicated\
      \ actors.\n\n====Damagetype====\n:Abstract classes which are responsible for\
      \ specifiying many damage related attributes, such as the effects (blood, screen\
      \ flash, etc.) associated with that damage, and the string to print to describe\
      \ deaths by that type of damage. \n:Passed as a parameter of the actor TakeDamage()\
      \ function.\n\n====LocalMessage====\n:Abstract classes which contain an array\
      \ of localized text .\n:The PlayerController function ReceiveLocalizedMessage()\
      \ is used to send messages to a specific player by specifying the LocalMessage\
      \ class and index. This allows the message to be localized on the client side,\
      \ and saves network bandwidth since the text is not sent.\n\n====HUD and Scoreboard====\n\
      :The '''HUD''' is responsible for drawing any information overlay.\n::The local\
      \ player always has a valid HUD.\n::The HUD type is defined by the GameInfo\
      \ actor.\n::Every frame, the HUD’s postrender function is called after the world\
      \ has been rendered.\n::ShowDebug exec will show debug parameters of currently\
      \ viewed actor (use ViewClass xxx to change viewed actor).\n\n===PART II - Game\
      \ code in C++===\n\n====Navigation AI====\n::Reachspecs must be built before\
      \ navigation network can be used (in the UnrealEd build menu).\n::Controllers\
      \ can check if a nearby point or actor (less than MAXPATHDIST away) is directly\
      \ reachable using PointReachable() and ActorReachable(). \n::MoveToward() and\
      \ MoveTo() are latent functions which cause the Controller’s pawn to move toward\
      \ the specified destination. State code execution continues when either the\
      \ destination is reached, or progress is no longer possible.\n:::If the move\
      \ is from one NavigationPoint to another, the destination NavigationPoint’s\
      \ SuggestMovePreparation() is called if it isimplemented, to allow it to direct\
      \ the pawn to perform some action first.\n:::The AIController functions WaitForMover()\
      \ and MoverFinished() provide an interface between a mover/its navigationpoint\
      \ and the controller. \n:::If the current pawn’s collision or other properties\
      \ are not supported by the path between the navigation points, the AIController’\
      s PrepareForMove() is called (to allow it to crouch, for example). \n:::While\
      \ the pawn’s bPreparingMove== true, the movement is suspended.\n::For destinations\
      \ that aren’t directly reachable, FindPathToward() and FindPathTo () will return\
      \ the NavigationPoint to move directly toward to reach that destination. When\
      \ the NavigationPoint is reached, call FindPathxxx() again to determine the\
      \ next path (with any dynamic path network changes considered).\n:::The Controller’\
      s RouteCache[] array contains the first 16\n:::NavigationPoints in the best\
      \ path determined toward the destination.\n::NodeEvaluator functions can be\
      \ defined to specify node desireability for routing when a specific destination\
      \ is not specified. Path finding code drops out immediately if result is >=\
      \ 1.0. FindPathTowardNearest(), FindRandomDest() are example native script functions\
      \ which take advantage of this capability.\n\n====Actor creation and destruction====\n\
      ::Spawn() in script calls SpawnActor() in C++\n:::For script spawned actors,\
      \ the spawned actor’s instigator is automatically set to be the instigator of\
      \ the actor which is calling Spawn(). \n:::Actor must fit where it is placed\
      \ in the world, or it won’t be spawned. \n:::After initialization (with exceptions\
      \ noted below), the following actor events are called:\n::::Spawned() - C++\n\
      ::::PreBeginPlay() - script (handles destruction if not game relevant) BeginPlay()\
      \ - script\n::::PostBeginPlay() - script\n::::PostNetBeginPlay() - script (Called\
      \ after replicated properties of actor have been updated - note that replication\
      \ at this point isn’t guaranteed)\n::::If actor has an auto state, its BeginState()\
      \ is called.\n:::Final initialization of the actor is done just before calling\
      \ PostBeginPlay() in the following order:\n::::The actor’s ZoneInfo and PhysicsVolume\
      \ are set.\n::::Collision with blocking non-world geometry actors is resolved\
      \ using actor events EncroachingOn() and EncroachedBy().\n:::Touching notifies\
      \ currently don’t happen when actor is spawned.\n::Actor creation at level startup\n\
      :::InitGame is called on the GameInfo \n:::Spawned() is not called. \n:::PreBeginPlay()\
      \ is called for all actors \n:::BeginPlay() called for all actors \n:::ZoneInfos\
      \ and Volumes set for all actors\n:::PostBeginPlay() called for all actors\n\
      :::PostNetBeginPlay() called for all actors \n:::BeginState() is called for\
      \ all actors with initial state \n::Actor destruction\n:::Initially bDeleteMe\
      \ is set\n:::When 255 actors marked for deletion, they are cleaned up, with\
      \ all actor references to other actors removed.\n:::Currently, deleted actors\
      \ may still be visible to script before cleanup. Will be changed in next version\
      \ - note potential issues to avoid.\n\n====Physics and world interaction====\n\
      ::Touch() and Untouch() notifications used for collisions between actors for\
      \ whom collision is enabled, but which don’t block each other.\n:::Occurs during\
      \ one actor’s physics. Avoid infinite loops (singular keyword is simple fix).\n\
      :::Use PendingTouch actor list for actors which want to add an effect after\
      \ the move completes using the PostTouch() notification.\n::Bump() notification\
      \ sent when actors which block each other collide.\n:::Occurs during one actor’\
      s physics. Avoid infinite loops (singular keyword is simple fix).\n::Base/Attached\
      \ actors\n:::When actor gets its base set, it is added to the base’s Attached\
      \ array\n:::Base gets Detach() and Attach()notifications \n:::Actor gets BaseChanged()\
      \ notification \n:::Base can change when:\n::::Change physics mode\n::::Teleport\
      \ (lose attached actors)\n::::Pawn walking\n::::SetBase() from script\n:::Special\
      \ case if AttachmentBone!=None\n::Actor Physics modes\n:::PHYS_Projectile \n\
      :::PHYS_Falling:\n:::PHYS_Rotating: Rotation, no translation \n:::PHYS_Trailer:\
      \ soon obsolete \n:::PHYS_RootMotion: under construction \n:::Rotation\n::::Not\
      \ updated if PHYS_None\n::::If bFixedRotationDir==true, will continue rotating\
      \ in same direction, even after reaching DesiredRotation.\n::::If bRotateToDesired==true,\
      \ will rotate to DesiredRotation and stop.\n:::Physics notifications: \n::::HitWall()\n\
      ::::Landed() (HitNormal.Z > MINFLOORZ)\n::Pawn physics modes\n:::PHYS_Walking\n\
      ::::Optional Check for ledges - MayFall() notification\n:::::For AI if !bCanWalkOffLedges,\
      \ with optional\n:::::bAvoidLedges (keep away from them). \n::::MinHitWall to\
      \ limit HitWall() notifications\n:::PHYS_Falling\n:::PHYS_Flying\n:::PHYS_Swimming\n\
      :::PHYS_Spider\n:::PHYS_Ladder\n:::PHYS_RootMotion: under construction\n:::Rotation\
      \ ( APawn :: PhysicsRotation() )\n::::bCrawler to orient in floor direction\
      \ \n::::No pitching when on ground.\n::::If not bCrawler, roll when angular\
      \ momentum\n:::Crouching:\n::::Can only crouch if bCanCrouch==true\n::::To request\
      \ crouch, set bWantsToCrouch\n::::bIsCrouched==true while crouched\n::::bTryToUncrouch\
      \ is true for AI pawns which automatically crouched during movement - they continually\
      \ try to stand up.\n\n'''OBWANDO:''' I've tried to keep all formatting correct\
      \ and in place. If anyone wants to help link up the major portions of the areas,\
      \ it would be appreciated. Ill do as much as I can. Also, if someone wants to\
      \ start a UT2003 page like this one, Ill donate to it as well to make it as\
      \ complete as possible."
  properties: []
  revId: 8892
name: "Legacy:Unreal Engine And Game Code Overview"
revision:
  revid: 8892
  parentid: 8893
  user: "EntropicLqd"
  timestamp: 1183760668.000000000
  comment: "Revert - I wonder if someone's created a bot with timer"
timestamp: 1668766809.375300000
