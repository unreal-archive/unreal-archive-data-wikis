---
parse:
  title: "Legacy:Rotator"
  text:
    text: "<dl>\n<dd><i>Copied and modified from a <a rel=\"nofollow\" class=\"external\
      \ text\" href=\"http://chimeric.beyondunreal.com/\">CHiMERiC</a> tutorial (<a\
      \ rel=\"nofollow\" class=\"external free\" href=\"http://chimeric.beyondunreal.com/tutorials/rotators.html\"\
      >http://chimeric.beyondunreal.com/tutorials/rotators.html</a> .)</i></dd>\n\
      <dd><i>Includes <a rel=\"nofollow\" class=\"external text\" href=\"http://www.sorcerydesign.com/jeremyt/quicksand/ut%20engine%20experience.htm\"\
      >Jeremy T's info</a> (link down) about loss of roll when converting to a vector.</i></dd>\n\
      </dl>\n<p><b>Rotator</b>s are one of the <a href=\"/Legacy:Built-In_Struct\"\
      \ title=\"Legacy:Built-In Struct\">Built-In Struct</a>. But what the hell are\
      \ they? Think angles. But instead of 360 degrees, a full circle is 65536 R<a\
      \ href=\"/Legacy:UU\" title=\"Legacy:UU\" class=\"mw-redirect\">UUs</a> (Rotational\
      \ Unreal Units). Every <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\">Actor</a>\
      \ has a Movement -&gt; Rotation variable that determines (gasp) what direction\
      \ the actor is pointing. Here's exactly what a rotator is:</p>\n<div dir=\"\
      ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"> <span class=\"kw1\">struct</span> <span class=\"kw5\"\
      >Rotator</span>\n <span class=\"br0\">{</span>\n    <span class=\"kw1\">var</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">config</span>\
      \ <span class=\"kw5\">int</span> Pitch, Yaw, Roll;\n <span class=\"br0\">}</span>;</pre></div>\n\
      </div>\n<p>Rotators have 3 parts:</p>\n<ul>\n<li>Pitch (think up/down... like\
      \ nodding your head \"yes\")</li>\n<li>Yaw (think left/right... like shaking\
      \ your head \"no\")</li>\n<li>Roll (tilt your head to one side, so you're still\
      \ looking the same direction, but one ear is pointing up and the other down).</li>\n\
      </ul>\n<p>You can modify the angles just by changing each of the values, but\
      \ you can not modify an actor's rotation directly, you must use the SetRotation(newRotation)\
      \ function, as shown below.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"> <span class=\"\
      kw1\">function</span> ChangeRotation<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n <span class=\"br0\">{</span>\n    <span class=\"kw1\">local</span>\
      \ <span class=\"kw5\">Rotator</span> newRot;    <span class=\"co1\">// This\
      \ will be our new Rotation</span>\n    newRot <span class=\"sy0\">=</span> <span\
      \ class=\"kw7\">Rotation</span>;       <span class=\"co1\">// Set newRot to\
      \ our current Rotation</span>\n    newRot.<span class=\"me0\">Pitch</span> <span\
      \ class=\"sy0\">+=</span> <span class=\"nu0\">32768</span>;   <span class=\"\
      co1\">// Since 65536 = 0 = 360, half of that equals 180, right?</span>\n   \
      \ newRot.<span class=\"me0\">Yaw</span> <span class=\"sy0\">-=</span> <span\
      \ class=\"nu0\">16384</span>;     <span class=\"co1\">// And half of that equals\
      \ 90 and so on...</span>\n    <span class=\"kw4\">SetRotation</span><span class=\"\
      br0\">(</span>newRot<span class=\"br0\">)</span>;     <span class=\"co1\">//\
      \ After we've done our tweaking go ahead and set the new rotation</span>\n <span\
      \ class=\"br0\">}</span></pre></div>\n</div>\n<p>So what did we just do? We\
      \ made something pitch 32768 RUU (180 degrees), and then turn 16384 RUU (90\
      \ degrees). Make sense? To get a vector of length one that points in the direction\
      \ of the rotator:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">   <span class=\"\
      kw1\">local</span> <span class=\"kw5\">rotator</span> myRot;\n   <span class=\"\
      kw1\">local</span> <span class=\"kw5\">vector</span> myVec;\n   ...\n   <span\
      \ class=\"me0\">myVec</span> <span class=\"sy0\">=</span> <span class=\"kw5\"\
      >vector</span><span class=\"br0\">(</span>myRot<span class=\"br0\">)</span>;\n\
      \   ...</pre></div>\n</div>\n<p>Always remember: the \"roll\" angle would rotate\
      \ a vector about its own axis. But a vector is a mathematical line, if you do\
      \ that it doesn't change at all. Therefore, myVec in the example above doesn't\
      \ have any roll information. There's no way to figure out the roll component\
      \ of myRot by looking at myVec. See also <a href=\"/Legacy:Typecasting\" title=\"\
      Legacy:Typecasting\">Typecasting</a>.</p>\n<p>To get a rotator that corresponds\
      \ to a vector, type:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">   ...\n   <span\
      \ class=\"me0\">myRot</span> <span class=\"sy0\">=</span> <span class=\"kw5\"\
      >rotator</span><span class=\"br0\">(</span>myVec<span class=\"br0\">)</span>;\n\
      \   ...</pre></div>\n</div>\n<p>Since vectors don't have roll information, the\
      \ \"roll\" of myRot will be zero, but the other parts will be correct.</p>\n\
      <p>Say you wanted myRot to point 90 degrees to the left...lets add another line:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\">   ...\n   <span class=\"me0\">myRot</span>.<span\
      \ class=\"me0\">Yaw</span> <span class=\"sy0\">+=</span> <span class=\"nu0\"\
      >16384</span>;      <span class=\"co1\">// Now myRot points 90 degrees to the\
      \ left of before</span>\n   ...</pre></div>\n</div>\n<p>Easy stuff no? Just\
      \ remember 65536 = 360 degrees, and to use SetRotation, and you'll do good.\
      \ Rotators are useful for using angle based math, in many cases can be used\
      \ in place of vector math to make some tasks much simpler. Thankfully Unreal\
      \ already handles converting back and forth...</p>\n<p><b>Musicalglass:</b>\
      \ OK, that will make it so when you open your map, it will be rotated in a new\
      \ static position. Now how do you introduce the element of time into the equation?\
      \ Like have your object start at zero and rotate to the new settings over a\
      \ period of say, 10 seconds?</p>\n<p>I know there are several different interpolation\
      \ functions available as well, like linear and smooth. Could somebody please\
      \ add a couple of simple equations to this page which show you how to do this?\
      \ Thanks</p>\n<p><b>Foxpaw:</b> I think this page is more about rotators themselves,\
      \ not about actor rotation but I suppose some iterpolation stuff could go here.\
      \ You should be able to accomplish what you want by setting bRotateToDesired\
      \ true, then setting a desiredrotation and a rotationrate, as well as a physics\
      \ type that supports this type of rotation. Then the object will start rotating\
      \ toward the angle in desiredrotation at the rate specified in rotationrate.</p>\n\
      <p></p>\n<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n\
      </div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Functions\"><span\
      \ class=\"tocnumber\">1</span> <span class=\"toctext\">Functions</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-2\"><a href=\"#Operators\"><span class=\"\
      tocnumber\">2</span> <span class=\"toctext\">Operators</span></a></li>\n<li\
      \ class=\"toclevel-1 tocsection-3\"><a href=\"#A_note_on_logging_rotators\"\
      ><span class=\"tocnumber\">3</span> <span class=\"toctext\">A note on logging\
      \ rotators</span></a></li>\n<li class=\"toclevel-1 tocsection-4\"><a href=\"\
      #Rotator_Replication\"><span class=\"tocnumber\">4</span> <span class=\"toctext\"\
      >Rotator Replication</span></a></li>\n<li class=\"toclevel-1 tocsection-5\"\
      ><a href=\"#Related_Topics\"><span class=\"tocnumber\">5</span> <span class=\"\
      toctext\">Related Topics</span></a></li>\n<li class=\"toclevel-1 tocsection-6\"\
      ><a href=\"#Discussion\"><span class=\"tocnumber\">6</span> <span class=\"toctext\"\
      >Discussion</span></a></li>\n</ul>\n</div>\n<p></p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Functions\">Functions</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Rotator?section=1\"\
      \ title=\"Edit section: Functions\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>The following <a href=\"/Legacy:Global_Function\"\
      \ title=\"Legacy:Global Function\">Global Function</a> apply to rotators.</p>\n\
      <dl>\n<dt>GetAxes (rotator A, out vector X, out vector Y, out vector Z) [static]&#160;</dt>\n\
      <dd>Assigns the axis vectors of <tt>A</tt> to <tt>X</tt>, <tt>Y</tt> and <tt>Z</tt>,\
      \ in terms of Absolute Rotation, where <tt>X</tt> points forward, <tt>Y</tt>\
      \ points right and <tt>Z</tt> points upwards. <b>The UnrealEngine2 implementation\
      \ of GetAxes gives invalid results when applied to the rotator 0,0,0. In this\
      \ case three zero vectors will be returned.</b></dd>\n<dt>GetUnAxes (rotator\
      \ A, out vector X, out vector Y, out vector Z) [static]&#160;</dt>\n<dd>Assigns\
      \ the axis vectors of Rot(0,0,0) to <tt>X</tt>, <tt>Y</tt> and <tt>Z</tt>, in\
      \ terms of <tt>A</tt>'s Local Rotation. The same result as <tt>GetAxes(A,X,Y,Z)</tt>\
      \ followed by <tt>Invert(X,Y,Z)</tt>. If you think of <tt>X</tt>, <tt>Y</tt>\
      \ and <tt>Z</tt> as 3x3 matrix, <tt>GetUnAxes</tt> returns the <a href=\"http://en.wikipedia.org/wiki/transposed\"\
      \ class=\"extiw\" title=\"wikipedia:transposed\">Wikipedia:transposed</a> matrix\
      \ relative to what <tt>GetAxes</tt> would return with the same rotator.</dd>\n\
      <dt>rotator RotRand (optional bool bRoll) [static]&#160;</dt>\n<dd>Returns a\
      \ random rotator. If bRoll is <tt>False</tt> the <tt>Roll</tt> component of\
      \ the rotator is 0.</dd>\n<dt>rotator OrthoRotation (vector X, vector Y, vector\
      \ Z) [static]&#160;</dt>\n<dd>Returns a rotator from three <a href=\"http://en.wikipedia.org/wiki/orthogonal\"\
      \ class=\"extiw\" title=\"wikipedia:orthogonal\">Wikipedia:orthogonal</a> vectors.</dd>\n\
      <dt>rotator Normalize (rotator Rot) [static]&#160;</dt>\n<dd>Returns the corresponding\
      \ rotator with components between -32768 and 32767. (See <i>A note on logging\
      \ rotators</i> below to find out why <code>log(Normalize(someRotator));</code>\
      \ seems to disagree with this description.)</dd>\n</dl>\n<h2><span class=\"\
      mw-headline\" id=\"Operators\">Operators</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Rotator?section=2\"\
      \ title=\"Edit section: Operators\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>See <a href=\"/Legacy:Operators\" title=\"Legacy:Operators\"\
      >Operators</a> for the operators than can be used with a Rotator.</p>\n<h2><span\
      \ class=\"mw-headline\" id=\"A_note_on_logging_rotators\">A note on logging\
      \ rotators</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Rotator?section=3\" title=\"Edit section: A\
      \ note on logging rotators\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>When rotators are typecasted to string, e.g. when\
      \ logging them, their Pitch/Yaw/Roll values are cramped into the range of 0\
      \ to 65535 by reducing them to 16bit unsigned integers. This does not mean the\
      \ rotator has changed, just that e.g. log() is not giving you their true value!\
      \ To get the true value write your own rotator to string function.</p>\n<p>Example:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">static</span> <span\
      \ class=\"kw1\">final</span> <span class=\"kw1\">function</span> <span class=\"\
      kw5\">string</span> RotatorToString<span class=\"br0\">(</span><span class=\"\
      kw5\">rotator</span> <span class=\"kw3\">rot</span><span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n  <span class=\"kw2\">return</span> <span class=\"\
      st0\">\"(\"</span> <span class=\"sy0\">$</span> <span class=\"kw3\">rot</span>.<span\
      \ class=\"me0\">Pitch</span> <span class=\"sy0\">$</span> <span class=\"st0\"\
      >\",\"</span> <span class=\"sy0\">$</span> <span class=\"kw3\">rot</span>.<span\
      \ class=\"me0\">Yaw</span> <span class=\"sy0\">$</span> <span class=\"st0\"\
      >\",\"</span> <span class=\"sy0\">$</span> <span class=\"kw3\">rot</span>.<span\
      \ class=\"me0\">Roll</span> <span class=\"sy0\">$</span> <span class=\"st0\"\
      >\")\"</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>This example\
      \ function will return a string representation of the rotator that is similar\
      \ to the built-in typecast, but uses the full 32bit integer precision of the\
      \ rotator's components.</p>\n<h2><span class=\"mw-headline\" id=\"Rotator_Replication\"\
      >Rotator Replication</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Rotator?section=4\" title=\"Edit section: Rotator\
      \ Replication\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Before a rotator is replicated, its component values are compressed into\
      \ the range of a byte through the function ((value &gt;&gt; 8) &amp; 0xFF).\
      \ This has the advantage that a rotator only takes up 3 bytes of bandwidth for\
      \ its value, but also limits the precision to 256 possible values per component.\
      \ That's why a player's view rotation is generally not replicated as a rotator.\
      \ The reduced Yaw and Pitch precision would hurt aiming accuracy.</p>\n<h2><span\
      \ class=\"mw-headline\" id=\"Related_Topics\">Related Topics</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Rotator?section=5\"\
      \ title=\"Edit section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:General_Scale_And_Dimensions\"\
      \ title=\"Legacy:General Scale And Dimensions\">General Scale and Dimensions</a></li>\n\
      <li><a href=\"/Legacy:Brush_Rotate\" title=\"Legacy:Brush Rotate\">Brush Rotate</a></li>\n\
      </ul>\n<p>(there's a table of URU to degrees on both those pages)</p>\n<ul>\n\
      <li><a href=\"/Legacy:Vector\" title=\"Legacy:Vector\">Vector</a></li>\n<li><a\
      \ href=\"/Legacy:Quaternion\" title=\"Legacy:Quaternion\">Quaternion</a></li>\n\
      <li><a href=\"/Legacy:Typecasting\" title=\"Legacy:Typecasting\">Typecasting</a></li>\n\
      </ul>\n<h2><span class=\"mw-headline\" id=\"Discussion\">Discussion</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Rotator?section=6\" title=\"Edit section: Discussion\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p><b>Parallax:</b>\
      \ I just wanted to take this oppurtunity to mention that in 16 bit maths, 65535\
      \ (as an unsigned 16 bit number) and -1 (as a signed 16 bit number) both have\
      \ the binary representation 0xFFFF. This means that if you add -1 to 1 (65535\
      \ to 1) you get zero (65535 + 1 = 65536 -&gt; 0). In hex this looks like (0xFFFF\
      \ + 0x0001 = 0x10000, then the leading 1 is truncated).</p>\n<p>Furthermore,\
      \ this means that as long as the numbers are constanly mapped to the values\
      \ 0 to 65535 (as they seem to be) then -1 and 65535 act like the same number.\
      \ If it helps you visualise it, if you turn around 359 degrees, you have effectively\
      \ turned 1 degree in the opposite direction.</p>\n<p>Of course, this whole argument\
      \ no longer holds if you aren't talking about numbers that map from 0..65535.\
      \ Fortunately in the case of rotators we are, whereas in the case of vectors\
      \ or other representations of movement rather than rotation there is no such\
      \ of logical wrap-around.</p>\n<p>I would be highly suprised if Rotators are\
      \ <b>not</b> normalised upon network replication, as transmitting three 16 bit\
      \ numbers when that is all the information that is needed is much more logical\
      \ than transmitting three 32 bit numbers. It is not really relevant wheither\
      \ these numbers are signed or unsigned in the case of rotators for the reasons\
      \ I just explained.</p>\n<p>Bear in mind that when you subtract 1 from 50 (say)\
      \ the computer (internally in the microprocessor) just calculates -1 (65535)\
      \ and then adds it to 50, getting a result of 49 (after the inevitable overflow).</p>\n\
      <p><b>Foxpaw:</b> One minor point of contention: UnrealScript rotators are a\
      \ struct composed of three variables of type \"int.\" An \"int\" appears to\
      \ be represented natively with a 32 bit signed integer, not a 16 bit unsigned\
      \ integer.</p>\n<p>However, the part about replication may be true, as it would\
      \ save some bandwidth.</p>\n<p><b>Xian:</b> EPIC tried to compress the rotation\
      \ in the case of players (Controller for UE2 and PlayerPawn for UE1) by putting\
      \ the yaw and pitch in an integer. The roll could easily be compressed in a\
      \ byte. Though I doubt replicating a struct made up of an int and a byte would\
      \ save too much; Still, depending on what you need it for (i.e. the ViewRotation\
      \ doesn't require a roll), a replicated int should be better than a whole 3-int\
      \ struct.</p>\n<p>in case you wanted the code:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">function</span> CompressExample <span\
      \ class=\"br0\">(</span><span class=\"kw5\">rotator</span> <span class=\"kw3\"\
      >Rot</span>, <span class=\"kw1\">out</span> <span class=\"kw5\">int</span> CompRot,\
      \ <span class=\"kw1\">out</span> <span class=\"kw5\">byte</span> CompRoll<span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\tCompRot <span class=\"\
      sy0\">=</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">32767</span> <span class=\"sy0\"\
      >&amp;</span> <span class=\"br0\">(</span><span class=\"kw3\">Rot</span>.<span\
      \ class=\"me0\">Pitch</span> <span class=\"sy0\">/</span> <span class=\"nu0\"\
      >2</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"\
      sy0\">*</span> <span class=\"nu0\">32768</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"nu0\"\
      >32767</span> <span class=\"sy0\">&amp;</span> <span class=\"br0\">(</span><span\
      \ class=\"kw3\">Rot</span>.<span class=\"me0\">Yaw</span> <span class=\"sy0\"\
      >/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"\
      br0\">)</span><span class=\"br0\">)</span>;\n\tCompRoll <span class=\"sy0\"\
      >=</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"\
      kw3\">Rot</span>.<span class=\"me0\">Roll</span> <span class=\"sy0\">&gt;&gt;</span>\
      \ <span class=\"nu0\">8</span><span class=\"br0\">)</span> <span class=\"sy0\"\
      >&amp;</span> <span class=\"nu0\">255</span><span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span>\n \n<span class=\"kw1\">function</span> DeCompressExample\
      \ <span class=\"br0\">(</span><span class=\"kw1\">out</span> <span class=\"\
      kw5\">rotator</span> <span class=\"kw3\">Rot</span>, <span class=\"kw5\">int</span>\
      \ CompRot, <span class=\"kw5\">byte</span> CompRoll<span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n\t<span class=\"kw3\">Rot</span>.<span class=\"\
      me0\">Pitch</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span>CompRot\
      \ <span class=\"sy0\">/</span> <span class=\"nu0\">32768</span><span class=\"\
      br0\">)</span>;\n\t<span class=\"kw3\">Rot</span>.<span class=\"me0\">Yaw</span>\
      \ <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\"\
      >2</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>CompRot <span\
      \ class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"nu0\">32768</span>\
      \ <span class=\"sy0\">*</span> <span class=\"kw3\">Rot</span>.<span class=\"\
      me0\">Pitch</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span\
      \ class=\"br0\">)</span>;\n\t<span class=\"kw3\">Rot</span>.<span class=\"me0\"\
      >Pitch</span> <span class=\"sy0\">*=</span> <span class=\"nu0\">2</span>;\n\t\
      <span class=\"kw3\">Rot</span>.<span class=\"me0\">Roll</span> <span class=\"\
      sy0\">=</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>CompRoll\
      \ <span class=\"sy0\">&lt;&lt;</span> <span class=\"nu0\">8</span><span class=\"\
      br0\">)</span> <span class=\"sy0\">|</span> CompRoll<span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p><b>Wormbo:</b> Rotators\
      \ are already compressed for replication. For each component only 1 or 9 bits\
      \ are replicated. The first bit signals, whether the component is zero and if\
      \ it isn't, a byte with the value follows. That byte is calculated as Roll in\
      \ the CompressExample function above. The (De)CompressExample functions are\
      \ very handy though, if full precision is required for a rotation direction.</p>\n\
      <hr />\n<p><b>Random150:</b> Rotators cause an interesting problem when you\
      \ want to position a one vector relative to another. When the first vector is\
      \ rotated, this means that the second requires rotation. Here is an example\
      \ on how to do this:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">local</span> <span class=\"kw5\">vector</span> Loc;\n<span class=\"kw1\"\
      >local</span> <span class=\"kw5\">rotator</span> <span class=\"kw3\">Rot</span>;\n\
      <span class=\"kw1\">local</span> <span class=\"kw5\">float</span> diff;\n \n\
      diff <span class=\"sy0\">=</span> <span class=\"nu0\">256</span>; <span class=\"\
      co1\">//The distance you need between the two</span>\n \nLoc <span class=\"\
      sy0\">=</span> <span class=\"kw7\">Location</span>; <span class=\"co1\">//Loction\
      \ of the Orginal Vector</span>\n<span class=\"kw3\">Rot</span> <span class=\"\
      sy0\">=</span> <span class=\"kw7\">Rotation</span>; <span class=\"co1\">//Rotation\
      \ of the Orginal Rotator</span>\n \n<span class=\"co1\">//This is the movement\
      \ of the X/Y plane. You will have to change </span>\n<span class=\"co1\">//\
      \  sin/cos/tan to your required axis of movement</span>\nLoc.<span class=\"\
      me0\">X</span> <span class=\"sy0\">+=</span> diff <span class=\"sy0\">*</span>\
      \ <span class=\"kw3\">cos</span><span class=\"br0\">(</span><span class=\"kw3\"\
      >Rot</span>.<span class=\"me0\">Yaw</span>   <span class=\"sy0\">*</span> <span\
      \ class=\"br0\">(</span><span class=\"kw6\">pi</span> <span class=\"sy0\">/</span>\
      \ <span class=\"nu0\">32768</span><span class=\"br0\">)</span><span class=\"\
      br0\">)</span>;\nLoc.<span class=\"me0\">Y</span> <span class=\"sy0\">+=</span>\
      \ diff <span class=\"sy0\">*</span> <span class=\"kw3\">sin</span><span class=\"\
      br0\">(</span><span class=\"kw3\">Rot</span>.<span class=\"me0\">Yaw</span>\
      \   <span class=\"sy0\">*</span> <span class=\"br0\">(</span><span class=\"\
      kw6\">pi</span> <span class=\"sy0\">/</span> <span class=\"nu0\">32768</span><span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>;\nLoc.<span class=\"me0\"\
      >Z</span> <span class=\"sy0\">+=</span> diff <span class=\"sy0\">*</span> <span\
      \ class=\"kw3\">sin</span><span class=\"br0\">(</span><span class=\"kw3\">Rot</span>.<span\
      \ class=\"me0\">Pitch</span> <span class=\"sy0\">*</span> <span class=\"br0\"\
      >(</span><span class=\"kw6\">pi</span> <span class=\"sy0\">/</span> <span class=\"\
      nu0\">32768</span><span class=\"br0\">)</span><span class=\"br0\">)</span>;</pre></div>\n\
      </div>\n<p><b>computergod666:</b> What exactly happens when you subtract two\
      \ rotators? Does it simply subtract their components from each other, or is\
      \ there something more complex involved?</p>\n<p><b>Wormbo:</b> The four arithmetic\
      \ operators +, -, * and / are all applied component-wise to rotators and vectors.\
      \ No special \"magic\" involved.</p>\n\n<!-- \nNewPP limit report\nCPU time\
      \ usage: 0.105 seconds\nReal time usage: 0.120 seconds\nPreprocessor visited\
      \ node count: 84/1000000\nPreprocessor generated node count: 196/1000000\nPost‐\
      expand include size: 7/2097152 bytes\nTemplate argument size: 0/2097152 bytes\n\
      Highest expansion depth: 2/40\nExpensive parser function count: 0/100\n-->\n\
      \n<!-- \nTransclusion expansion time report (%,ms,calls,template)\n100.00% \
      \   0.000      1 - -total\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:2605-0!*!0!!en!*!*\
      \ and timestamp 20221118021900 and revision id 45416\n -->\n"
  categories:
  - sortkey: "Rotator"
    name: "Legacy_Refactor_Me"
  links:
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  - ns: 100
    exists: true
    name: "Legacy:General Scale And Dimensions"
  - ns: 100
    exists: true
    name: "Legacy:Operators"
  - ns: 100
    exists: true
    name: "Legacy:Typecasting"
  - ns: 100
    exists: true
    name: "Legacy:Built-In Struct"
  - ns: 100
    exists: true
    name: "Legacy:Global Function"
  - ns: 100
    exists: true
    name: "Legacy:UU"
  - ns: 100
    exists: true
    name: "Legacy:Vector"
  - ns: 100
    exists: true
    name: "Legacy:Quaternion"
  - ns: 100
    exists: true
    name: "Legacy:Brush Rotate"
  templates: []
  images: []
  externallinks:
  - "http://chimeric.beyondunreal.com/"
  - "http://www.sorcerydesign.com/jeremyt/quicksand/ut%20engine%20experience.htm"
  - "http://chimeric.beyondunreal.com/tutorials/rotators.html"
  sections:
  - toclevel: 1
    level: "2"
    line: "Functions"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Rotator"
    byteoffset: 3988
    anchor: "Functions"
  - toclevel: 1
    level: "2"
    line: "Operators"
    number: "2"
    index: "2"
    fromtitle: "Legacy:Rotator"
    byteoffset: 5542
    anchor: "Operators"
  - toclevel: 1
    level: "2"
    line: "A note on logging rotators"
    number: "3"
    index: "3"
    fromtitle: "Legacy:Rotator"
    byteoffset: 5645
    anchor: "A_note_on_logging_rotators"
  - toclevel: 1
    level: "2"
    line: "Rotator Replication"
    number: "4"
    index: "4"
    fromtitle: "Legacy:Rotator"
    byteoffset: 6369
    anchor: "Rotator_Replication"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "5"
    index: "5"
    fromtitle: "Legacy:Rotator"
    byteoffset: 6831
    anchor: "Related_Topics"
  - toclevel: 1
    level: "2"
    line: "Discussion"
    number: "6"
    index: "6"
    fromtitle: "Legacy:Rotator"
    byteoffset: 7119
    anchor: "Discussion"
  displaytitle: "Legacy:Rotator"
  iwlinks:
  - prefix: "wikipedia"
    url: "http://en.wikipedia.org/wiki/orthogonal"
    name: "wikipedia:orthogonal"
  - prefix: "wikipedia"
    url: "http://en.wikipedia.org/wiki/transposed"
    name: "wikipedia:transposed"
  wikitext:
    text: ": ''Copied and modified from a [http://chimeric.beyondunreal.com/ CHiMERiC]\
      \ tutorial (http://chimeric.beyondunreal.com/tutorials/rotators.html .)''\n\
      : ''Includes [http://www.sorcerydesign.com/jeremyt/quicksand/ut%20engine%20experience.htm\
      \ Jeremy T's info] (link down) about loss of roll when converting to a vector.''\n\
      \n'''Rotator'''s are one of the [[Legacy:Built-In Struct|Built-In Struct]].\
      \ But what the hell are they? Think angles. But instead of 360 degrees, a full\
      \ circle is 65536 R[[Legacy:UU|UU]]s (Rotational Unreal Units). Every [[Legacy:Actor|Actor]]\
      \ has a Movement -> Rotation variable that determines (gasp) what direction\
      \ the actor is pointing. Here's exactly what a rotator is: \n\n<uscript>\n struct\
      \ Rotator\n {\n    var() config int Pitch, Yaw, Roll;\n };\n</uscript>\n\nRotators\
      \ have 3 parts:\n* Pitch (think up/down... like nodding your head \"yes\")\n\
      * Yaw (think left/right... like shaking your head \"no\")\n* Roll (tilt your\
      \ head to one side, so you're still looking the same direction, but one ear\
      \ is pointing up and the other down).\n\nYou can modify the angles just by changing\
      \ each of the values, but you can not modify an actor's rotation directly, you\
      \ must use the SetRotation(newRotation) function, as shown below. \n\n<uscript>\n\
      \ function ChangeRotation()\n {\n    local Rotator newRot;    // This will be\
      \ our new Rotation\n    newRot = Rotation;       // Set newRot to our current\
      \ Rotation\n    newRot.Pitch += 32768;   // Since 65536 = 0 = 360, half of that\
      \ equals 180, right?\n    newRot.Yaw -= 16384;     // And half of that equals\
      \ 90 and so on...\n    SetRotation(newRot);     // After we've done our tweaking\
      \ go ahead and set the new rotation\n }\n</uscript>\n\nSo what did we just do?\
      \ We made something pitch 32768 RUU (180 degrees), and then turn 16384 RUU (90\
      \ degrees). Make sense? To get a vector of length one that points in the direction\
      \ of the rotator: \n\n<uscript>\n   local rotator myRot;\n   local vector myVec;\n\
      \   ...\n   myVec = vector(myRot);\n   ...\n</uscript>\n\nAlways remember: the\
      \ \"roll\" angle would rotate a vector about its own axis. But a vector is a\
      \ mathematical line, if you do that it doesn't change at all. Therefore, myVec\
      \ in the example above doesn't have any roll information. There's no way to\
      \ figure out the roll component of myRot by looking at myVec. See also [[Legacy:Typecasting|Typecasting]].\n\
      \nTo get a rotator that corresponds to a vector, type: \n\n<uscript>\n   ...\n\
      \   myRot = rotator(myVec);\n   ...\n</uscript>\n\nSince vectors don't have\
      \ roll information, the \"roll\" of myRot will be zero, but the other parts\
      \ will be correct. \n\nSay you wanted myRot to point 90 degrees to the left...lets\
      \ add another line: \n\n<uscript>\n   ...\n   myRot.Yaw += 16384;      // Now\
      \ myRot points 90 degrees to the left of before\n   ...\n</uscript>\n\nEasy\
      \ stuff no? Just remember 65536 = 360 degrees, and to use SetRotation, and you'll\
      \ do good. Rotators are useful for using angle based math, in many cases can\
      \ be used in place of vector math to make some tasks much simpler. Thankfully\
      \ Unreal already handles converting back and forth... \n\n'''Musicalglass:'''\
      \ OK, that will make it so when you open your map, it will be rotated in a new\
      \ static position. Now how do you introduce the element of time into the equation?\
      \ Like have your object start at zero and rotate to the new settings over a\
      \ period of say, 10 seconds?\n\nI know there are several different interpolation\
      \ functions available as well, like linear and smooth. Could somebody please\
      \ add a couple of simple equations to this page which show you how to do this?\
      \ Thanks\n\n'''Foxpaw:''' I think this page is more about rotators themselves,\
      \ not about actor rotation but I suppose some iterpolation stuff could go here.\
      \ You should be able to accomplish what you want by setting bRotateToDesired\
      \ true, then setting a desiredrotation and a rotationrate, as well as a physics\
      \ type that supports this type of rotation. Then the object will start rotating\
      \ toward the angle in desiredrotation at the rate specified in rotationrate.\n\
      \n==Functions ==\n\nThe following [[Legacy:Global Function|Global Function]]\
      \ apply to rotators.\n\n; GetAxes (rotator A, out vector X, out vector Y, out\
      \ vector Z) [static] : Assigns the axis vectors of <tt>A</tt> to <tt>X</tt>,\
      \ <tt>Y</tt> and <tt>Z</tt>, in terms of Absolute Rotation, where <tt>X</tt>\
      \ points forward, <tt>Y</tt> points right and <tt>Z</tt> points upwards. '''The\
      \ UnrealEngine2 implementation of GetAxes gives invalid results when applied\
      \ to the rotator 0,0,0. In this case three zero vectors will be returned.'''\n\
      ; GetUnAxes (rotator A, out vector X, out vector Y, out vector Z) [static] :\
      \ Assigns the axis vectors of Rot(0,0,0) to <tt>X</tt>, <tt>Y</tt> and <tt>Z</tt>,\
      \ in terms of <tt>A</tt>'s Local Rotation. The same result as <tt>GetAxes(A,X,Y,Z)</tt>\
      \ followed by <tt>Invert(X,Y,Z)</tt>.  If you think of <tt>X</tt>, <tt>Y</tt>\
      \ and <tt>Z</tt> as 3x3 matrix, <tt>GetUnAxes</tt> returns the [[Wikipedia:transposed]]\
      \ matrix relative to what <tt>GetAxes</tt> would return with the same rotator.\n\
      ; rotator RotRand (optional bool bRoll) [static] : Returns a random rotator.\
      \ If bRoll is <tt>False</tt> the <tt>Roll</tt> component of the rotator is 0.\n\
      ; rotator OrthoRotation (vector X, vector Y, vector Z) [static] : Returns a\
      \ rotator from three [[Wikipedia:orthogonal]] vectors.\n; rotator Normalize\
      \ (rotator Rot) [static] : Returns the corresponding rotator with components\
      \ between -32768 and 32767. (See ''A note on logging rotators'' below to find\
      \ out why <code>log(Normalize(someRotator));</code> seems to disagree with this\
      \ description.)\n\n==Operators ==\n\nSee [[Legacy:Operators|Operators]] for\
      \ the operators than can be used with a Rotator.\n\n==A note on logging rotators\
      \ ==\n\nWhen rotators are typecasted to string, e.g. when logging them, their\
      \ Pitch/Yaw/Roll values are cramped into the range of 0 to 65535 by reducing\
      \ them to 16bit unsigned integers. This does not mean the rotator has changed,\
      \ just that e.g. log() is not giving you their true value! To get the true value\
      \ write your own rotator to string function.\n\nExample:\n\n<uscript>\nstatic\
      \ final function string RotatorToString(rotator rot)\n{\n  return \"(\" $ rot.Pitch\
      \ $ \",\" $ rot.Yaw $ \",\" $ rot.Roll $ \")\";\n}\n</uscript>\n\nThis example\
      \ function will return a string representation of the rotator that is similar\
      \ to the built-in typecast, but uses the full 32bit integer precision of the\
      \ rotator's components.\n\n==Rotator Replication ==\n\nBefore a rotator is replicated,\
      \ its component values are compressed into the range of a byte through the function\
      \ ((value >> 8) & 0xFF). This has the advantage that a rotator only takes up\
      \ 3 bytes of bandwidth for its value, but also limits the precision to 256 possible\
      \ values per component. That's why a player's view rotation is generally not\
      \ replicated as a rotator. The reduced Yaw and Pitch precision would hurt aiming\
      \ accuracy.\n\n==Related Topics ==\n* [[Legacy:General Scale And Dimensions|General\
      \ Scale and Dimensions]]\n* [[Legacy:Brush Rotate|Brush Rotate]]\n\n(there's\
      \ a table of URU to degrees on both those pages)\n\n* [[Legacy:Vector|Vector]]\n\
      * [[Legacy:Quaternion|Quaternion]]\n* [[Legacy:Typecasting|Typecasting]]\n\n\
      ==Discussion ==\n\n'''Parallax:''' I just wanted to take this oppurtunity to\
      \ mention that in 16 bit maths, 65535 (as an unsigned 16 bit number) and -1\
      \ (as a signed 16 bit number) both have the binary representation 0xFFFF. This\
      \ means that if you add -1 to 1 (65535 to 1) you get zero (65535 + 1 = 65536\
      \ -> 0). In hex this looks like (0xFFFF + 0x0001 = 0x10000, then the leading\
      \ 1 is truncated).\n\nFurthermore, this means that as long as the numbers are\
      \ constanly mapped to the values 0 to 65535 (as they seem to be) then -1 and\
      \ 65535 act like the same number. If it helps you visualise it, if you turn\
      \ around 359 degrees, you have effectively turned 1 degree in the opposite direction.\n\
      \nOf course, this whole argument no longer holds if you aren't talking about\
      \ numbers that map from 0..65535. Fortunately in the case of rotators we are,\
      \ whereas in the case of vectors or other representations of movement rather\
      \ than rotation there is no such of logical wrap-around. \n\nI would be highly\
      \ suprised if Rotators are '''not''' normalised upon network replication, as\
      \ transmitting three 16 bit numbers when that is all the information that is\
      \ needed is much more logical than transmitting three 32 bit numbers. It is\
      \ not really relevant wheither these numbers are signed or unsigned in the case\
      \ of rotators for the reasons I just explained.\n\nBear in mind that when you\
      \ subtract 1 from 50 (say) the computer (internally in the microprocessor) just\
      \ calculates -1 (65535) and then adds it to 50, getting a result of 49 (after\
      \ the inevitable overflow).\n\n'''Foxpaw:''' One minor point of contention:\
      \ UnrealScript rotators are a struct composed of three variables of type \"\
      int.\" An \"int\" appears to be represented natively with a 32 bit signed integer,\
      \ not a 16 bit unsigned integer.\n\nHowever, the part about replication may\
      \ be true, as it would save some bandwidth.\n\n'''Xian:''' EPIC tried to compress\
      \ the rotation in the case of players (Controller for UE2 and PlayerPawn for\
      \ UE1) by putting the yaw and pitch in an integer. The roll could easily be\
      \ compressed in a byte. Though I doubt replicating a struct made up of an int\
      \ and a byte would save too much; Still, depending on what you need it for (i.e.\
      \ the ViewRotation doesn't require a roll), a replicated int should be better\
      \ than a whole 3-int struct.\n\nin case you wanted the code:\n\n<uscript>\n\
      function CompressExample (rotator Rot, out int CompRot, out byte CompRoll)\n\
      {\n\tCompRot = (((32767 & (Rot.Pitch / 2)) * 32768) + (32767 & (Rot.Yaw / 2)));\n\
      \tCompRoll = ((Rot.Roll >> 8) & 255);\n}\n\nfunction DeCompressExample (out\
      \ rotator Rot, int CompRot, byte CompRoll)\n{\n\tRot.Pitch = (CompRot / 32768);\n\
      \tRot.Yaw = (2 * (CompRot - (32768 * Rot.Pitch)));\n\tRot.Pitch *= 2;\n\tRot.Roll\
      \ = ((CompRoll << 8) | CompRoll);\n}\n</uscript>\n\n'''Wormbo:''' Rotators are\
      \ already compressed for replication. For each component only 1 or 9 bits are\
      \ replicated. The first bit signals, whether the component is zero and if it\
      \ isn't, a byte with the value follows. That byte is calculated as Roll in the\
      \ CompressExample function above. The (De)CompressExample functions are very\
      \ handy though, if full precision is required for a rotation direction.\n\n\
      ----\n\n'''Random150:''' Rotators cause an interesting problem when you want\
      \ to position a one vector relative to another. When the first vector is rotated,\
      \ this means that the second requires rotation. Here is an example on how to\
      \ do this:\n\n<uscript>\nlocal vector Loc;\nlocal rotator Rot;\nlocal float\
      \ diff;\n\ndiff = 256; //The distance you need between the two\n\nLoc = Location;\
      \ //Loction of the Orginal Vector\nRot = Rotation; //Rotation of the Orginal\
      \ Rotator\n\n//This is the movement of the X/Y plane. You will have to change\
      \ \n//  sin/cos/tan to your required axis of movement\nLoc.X += diff * cos(Rot.Yaw\
      \   * (pi / 32768));\nLoc.Y += diff * sin(Rot.Yaw   * (pi / 32768));\nLoc.Z\
      \ += diff * sin(Rot.Pitch * (pi / 32768));\n\n</uscript>\n\n'''computergod666:'''\
      \ What exactly happens when you subtract two rotators? Does it simply subtract\
      \ their components from each other, or is there something more complex involved?\n\
      \n'''Wormbo:''' The four arithmetic operators +, -, * and / are all applied\
      \ component-wise to rotators and vectors. No special \"magic\" involved.\n\n\
      [[Category:Legacy Refactor Me|{{PAGENAME}}]]"
  properties: []
  revId: 45416
name: "Legacy:Rotator"
revision:
  revid: 45416
  parentid: 33938
  user: "59.167.117.10"
  timestamp: 1370491756.000000000
  comment: "/* A note on logging rotators */"
timestamp: 1668763437.751839000
