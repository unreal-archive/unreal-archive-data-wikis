---
parse:
  title: "Legacy:Code Optimization"
  text:
    text: "<p>If your code runs slow or causes hitches on some computers, here are\
      \ several <b>optimization techniques</b> you can apply to your code to make\
      \ it run better.</p>\n<p></p>\n<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\"\
      >\n<h2>Contents</h2>\n</div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a\
      \ href=\"#You_might_be_looking_for...\"><span class=\"tocnumber\">1</span> <span\
      \ class=\"toctext\">You might be looking for...</span></a></li>\n<li class=\"\
      toclevel-1 tocsection-2\"><a href=\"#Keep_the_log_clean\"><span class=\"tocnumber\"\
      >2</span> <span class=\"toctext\">Keep the log clean</span></a></li>\n<li class=\"\
      toclevel-1 tocsection-3\"><a href=\"#Avoid_iterators\"><span class=\"tocnumber\"\
      >3</span> <span class=\"toctext\">Avoid iterators</span></a></li>\n<li class=\"\
      toclevel-1 tocsection-4\"><a href=\"#Optimize_iterator_use\"><span class=\"\
      tocnumber\">4</span> <span class=\"toctext\">Optimize iterator use</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-5\"><a href=\"#Disable_engine_events_when_you_don.27t_need_them\"\
      ><span class=\"tocnumber\">5</span> <span class=\"toctext\">Disable engine events\
      \ when you don't need them</span></a></li>\n<li class=\"toclevel-1 tocsection-6\"\
      ><a href=\"#Re-use_objects\"><span class=\"tocnumber\">6</span> <span class=\"\
      toctext\">Re-use objects</span></a></li>\n<li class=\"toclevel-1 tocsection-7\"\
      ><a href=\"#Precache_materials_and_static_meshes\"><span class=\"tocnumber\"\
      >7</span> <span class=\"toctext\">Precache materials and static meshes</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-8\"><a href=\"#Optimize_expressions\"><span\
      \ class=\"tocnumber\">8</span> <span class=\"toctext\">Optimize expressions</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-9\"><a href=\"#Avoid_Nesting_functions\"><span\
      \ class=\"tocnumber\">9</span> <span class=\"toctext\">Avoid Nesting functions</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-10\"><a href=\"#Use_native_functionality_instead_of_UnrealScript_code\"\
      ><span class=\"tocnumber\">10</span> <span class=\"toctext\">Use native functionality\
      \ instead of UnrealScript code</span></a></li>\n<li class=\"toclevel-1 tocsection-11\"\
      ><a href=\"#Execute_code_only_as_often_as_needed\"><span class=\"tocnumber\"\
      >11</span> <span class=\"toctext\">Execute code only as often as needed</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-12\"><a href=\"#Find_bottlenecks_by_measuring_execution_time\"\
      ><span class=\"tocnumber\">12</span> <span class=\"toctext\">Find bottlenecks\
      \ by measuring execution time</span></a></li>\n<li class=\"toclevel-1 tocsection-13\"\
      ><a href=\"#Unroll_your_loops\"><span class=\"tocnumber\">13</span> <span class=\"\
      toctext\">Unroll your loops</span></a></li>\n<li class=\"toclevel-1 tocsection-14\"\
      ><a href=\"#Speed_comparison_of_loops\"><span class=\"tocnumber\">14</span>\
      \ <span class=\"toctext\">Speed comparison of loops</span></a></li>\n<li class=\"\
      toclevel-1 tocsection-15\"><a href=\"#Refine_your_algorithms\"><span class=\"\
      tocnumber\">15</span> <span class=\"toctext\">Refine your algorithms</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-16\"><a href=\"#The_member_selection_operator_has_its_price\"\
      ><span class=\"tocnumber\">16</span> <span class=\"toctext\">The member selection\
      \ operator has its price</span></a></li>\n<li class=\"toclevel-1 tocsection-17\"\
      ><a href=\"#Be_careful_with_temporary_variables\"><span class=\"tocnumber\"\
      >17</span> <span class=\"toctext\">Be careful with temporary variables</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-18\"><a href=\"#Related_Topics\"><span class=\"\
      tocnumber\">18</span> <span class=\"toctext\">Related Topics</span></a></li>\n\
      </ul>\n</div>\n<p></p>\n<h2><span class=\"mw-headline\" id=\"You_might_be_looking_for...\"\
      >You might be looking for...</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=1\"\
      \ title=\"Edit section: You might be looking for...\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:Map_Optimization\"\
      \ title=\"Legacy:Map Optimization\">Map Optimization</a></li>\n</ul>\n<h2><span\
      \ class=\"mw-headline\" id=\"Keep_the_log_clean\">Keep the log clean</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Code_Optimization?section=2\" title=\"Edit section: Keep\
      \ the log clean\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Every line that is written to the log file takes time. Writing lots of them\
      \ to the log may slow down your mod to a crawl and can inflate the game's log\
      \ to several megabytes after a short time already.</p>\n<dl>\n<dt>Fix <i>Accessed\
      \ None</i> and other log warnings&#160;</dt>\n<dd>Fix all <i>Accessed None</i>\
      \ and other <a href=\"/Legacy:Log_Warnings\" title=\"Legacy:Log Warnings\">log\
      \ warnings</a> you find in the log after executing your mod. (You can safely\
      \ assume that your code is responsible for any script warning you find in the\
      \ log after executing it, even those that point to somewhere in Epic's code.\
      \ Compare with the log when not playing your mod if in doubt.)</dd>\n</dl>\n\
      <dl>\n<dt>Remove debug logging&#160;</dt>\n<dd>Make sure to remove any debugging\
      \ log statements in release versions of your mods. If you think you may need\
      \ the log statements in future again, just comment them out.</dd>\n</dl>\n<h2><span\
      \ class=\"mw-headline\" id=\"Avoid_iterators\">Avoid iterators</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=3\"\
      \ title=\"Edit section: Avoid iterators\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Avoid using any <a href=\"/Legacy:Iterator\" title=\"\
      Legacy:Iterator\">iterators</a> in frequently executed functions like <code>Tick</code>\
      \ or <code>PostRender</code> because they are, for the most part, extremely\
      \ slow.</p>\n<p>Instead try using <a href=\"/Legacy:Linked_List\" title=\"Legacy:Linked\
      \ List\">linked lists</a> or <a href=\"/Legacy:Dynamic_Array\" title=\"Legacy:Dynamic\
      \ Array\">dynamic arrays</a> for the actors you work with. You could either\
      \ fill these at the start of the match, e.g. with a single iterator loop, or\
      \ maintain the list when spawning and destroying actors like the <a href=\"\
      /Legacy:SpawnNotify\" title=\"Legacy:SpawnNotify\">SpawnNotify</a> in UT or\
      \ the <a href=\"/Legacy:Interaction\" title=\"Legacy:Interaction\">Interaction</a>\
      \ lists maintained by the <a href=\"/Legacy:InteractionMaster\" title=\"Legacy:InteractionMaster\"\
      >InteractionMaster</a> in UT2003.</p>\n<h2><span class=\"mw-headline\" id=\"\
      Optimize_iterator_use\">Optimize iterator use</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=4\"\
      \ title=\"Edit section: Optimize iterator use\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>If you can't avoid using them, at least try to optimize\
      \ them.</p>\n<p>VisibleActors and VisibleCollidingActors are good examples of\
      \ this. Every actor that is within the radius has a FastTrace called on it.\
      \ Traces use a lot of CPU resources and if the radius is large you will be calling\
      \ a lot of traces. You can spare yourself some traces by checking anything else\
      \ than needs to be checked on top of the trace first.</p>\n<p>For example, if\
      \ you are looking for all visible pawns within 2000 units that have over 50\
      \ health, we can check the health before we check the trace – that way we don't\
      \ bother doing the expensive visibility check if it was going to fail the health\
      \ check anyway. For example:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"co1\">// this way is slow</span>\n<span class=\"kw2\">foreach</span>\
      \ <span class=\"kw2\">VisibleActors</span><span class=\"br0\">(</span><span\
      \ class=\"kw1\">class</span><span class=\"st0\">'Pawn'</span>, P, Radius, <span\
      \ class=\"kw7\">Location</span>, <span class=\"kw6\">True</span><span class=\"\
      br0\">)</span>\n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>P.<span\
      \ class=\"me0\">Health</span> <span class=\"sy0\">&gt;</span> <span class=\"\
      nu0\">50</span><span class=\"br0\">)</span>\n    <span class=\"co1\">// do something</span>\n\
      \ \n<span class=\"co1\">// this way is faster</span>\n<span class=\"kw2\">foreach</span>\
      \ <span class=\"kw2\">RadiusActors</span><span class=\"br0\">(</span><span class=\"\
      kw1\">class</span><span class=\"st0\">'Pawn'</span>, P, Radius, <span class=\"\
      kw7\">Location</span>, <span class=\"kw6\">True</span><span class=\"br0\">)</span>\n\
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>P.<span class=\"\
      me0\">Health</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">50</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"kw4\">FastTrace</span><span\
      \ class=\"br0\">(</span>P.<span class=\"kw7\">Location</span>, <span class=\"\
      kw7\">Location</span><span class=\"br0\">)</span><span class=\"br0\">)</span>\n\
      \    <span class=\"co1\">// do something</span></pre></div>\n</div>\n<p>Another\
      \ example of an even slower implementation that needs to check all actors, not\
      \ just Pawns:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw2\">foreach</span> <span class=\"kw2\">VisibleCollidingActors</span><span\
      \ class=\"br0\">(</span><span class=\"kw1\">class</span><span class=\"st0\"\
      >'Actor'</span>, thisActor, Radius, <span class=\"kw7\">Location</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n    <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span>thisActor.<span class=\"me0\">bStatic</span>\
      \ <span class=\"sy0\">||</span> thisActor.<span class=\"kw7\">Physics</span>\
      \ <span class=\"sy0\">==</span> <span class=\"kw7\">PHYS_None</span><span class=\"\
      br0\">)</span>\n        <span class=\"kw2\">continue</span>;  <span class=\"\
      co1\">// skip this actor</span>\n    <span class=\"co1\">// do the actual stuff</span>\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>Within a radius of e.g.\
      \ 1500 you could easily find over 300 actors. The loop will execute a FastTrace\
      \ (see <a href=\"/Legacy:Actor/Methods\" title=\"Legacy:Actor/Methods\">Actor/Methods</a>)\
      \ for every single actor in the collision hash within the specified area. However,\
      \ a lot of those actors are most probably static and/or have <code>Physics ==\
      \ None</code>. FastTrace requires much more time than the checks used within\
      \ the loop, but those checks would catch almost as many actors. A simple optimization\
      \ would be executing the FastTrace <i>after</i> the other two checks. This can\
      \ be done by using the CollidingActors (still faster than RadiusActors with\
      \ up to 2000 UU radius) iterator instead:</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\"><span class=\"kw2\">ForEach</span> <span class=\"kw2\">CollidingActors</span><span\
      \ class=\"br0\">(</span><span class=\"kw1\">class</span><span class=\"st0\"\
      >'Actor'</span>, thisActor, Radius, <span class=\"kw7\">Location</span><span\
      \ class=\"br0\">)</span> <span class=\"br0\">{</span>\n    <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> thisActor.<span class=\"me0\">bStatic</span>\
      \ <span class=\"sy0\">||</span> thisActor.<span class=\"kw7\">Physics</span>\
      \ <span class=\"sy0\">==</span> <span class=\"kw7\">PHYS_None</span> <span class=\"\
      sy0\">||</span> <span class=\"sy0\">!</span><span class=\"kw4\">FastTrace</span><span\
      \ class=\"br0\">(</span>Other.<span class=\"kw7\">Location</span>, <span class=\"\
      kw7\">Location</span><span class=\"br0\">)</span> <span class=\"br0\">)</span>\n\
      \        <span class=\"kw2\">continue</span>; <span class=\"co1\">// skip this\
      \ actor</span>\n \n    <span class=\"co1\">// do the actual stuff</span>\n<span\
      \ class=\"br0\">}</span></pre></div>\n</div>\n<p>This will execute much faster,\
      \ but why?</p>\n<p>Imagine those 300 actors, let's say 200-250 of them are StaticMeshes\
      \ placed in the map. Those are all static actors which will be caught by the\
      \ first part of the <tt>if</tt> statement. Some other actors might be e.g. gibs\
      \ lying on the floor. Those actors have <code>Physics == PHYS_None</code> and\
      \ will be caught by the second part of the <tt>if</tt> statement. Typically\
      \ over 90% of the actors will <i>fail</i> to pass those first two tests, leaving\
      \ only about 30 actors for the FastTrace check in this example. This means we\
      \ only have to do 30 FastTraces instead of 300. Now imagine you want to run\
      \ this loop every Tick. A high number of FastTraces can slow down the game by\
      \ 50% or even more, while about 10-30 of those Traces can only be noticed by\
      \ checking the frame rate.</p>\n<h2><span class=\"mw-headline\" id=\"Disable_engine_events_when_you_don.27t_need_them\"\
      >Disable engine events when you don't need them</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=5\"\
      \ title=\"Edit section: Disable engine events when you don't need them\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Use the Disable\
      \ function to deactivate certain engine events when you don't need them. (That\
      \ only applies for events you provide an UnrealScript implementation for; if\
      \ you haven't overwritten an engine event in your class, disabling it makes\
      \ no difference.)</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">event</span> <span class=\"kw4\">PostBeginPlay</span>\n<span class=\"\
      br0\">{</span>\n    <span class=\"co1\">// all events are enabled by default,\
      \ so disable Tick event to start with</span>\n    <span class=\"kw3\">Disable</span><span\
      \ class=\"br0\">(</span><span class=\"st0\">'Tick'</span><span class=\"br0\"\
      >)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">event</span>\
      \ <span class=\"kw4\">Trigger</span><span class=\"br0\">(</span><span class=\"\
      kw9\">Actor</span> Sender, <span class=\"kw9\">Pawn</span> <span class=\"kw7\"\
      >Instigator</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \    <span class=\"co1\">// tell engine to call Tick event from now on</span>\n\
      \    <span class=\"kw3\">Enable</span><span class=\"br0\">(</span><span class=\"\
      st0\">'Tick'</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"kw1\">event</span> <span class=\"kw4\">Tick</span><span class=\"\
      br0\">(</span><span class=\"kw5\">float</span> DeltaTime<span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n    <span class=\"co1\">// do something\
      \ -- executed only after the actor has been triggered</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>Using Disable and Enable is more efficient\
      \ than using a bool variable and doing an UnrealScript-level check in the Tick\
      \ function. (And it's more elegant as well.)</p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Re-use_objects\">Re-use objects</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=6\"\
      \ title=\"Edit section: Re-use objects\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p><a href=\"/Legacy:Creating_Actors_And_Objects\" title=\"\
      Legacy:Creating Actors And Objects\">Creating actors and objects</a> is a relatively\
      \ expensive operation. If you can, design your code so that you spawn an actor\
      \ or object you need only once, save a reference to it and use it later again.</p>\n\
      <p>The <a href=\"/Legacy:Object_Pool\" title=\"Legacy:Object Pool\">object pool</a>\
      \ makes re-using non-Actor objects convenient and straightforward: <i>Allocating</i>\
      \ an object of a given class either takes an existing one from the pool or automatically\
      \ creates a new one if none exists yet; <i>freeing</i> an object doesn't destroy\
      \ it but puts it into the pool.</p>\n<h2><span class=\"mw-headline\" id=\"Precache_materials_and_static_meshes\"\
      >Precache materials and static meshes</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=7\"\
      \ title=\"Edit section: Precache materials and static meshes\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Precache any new\
      \ materials or static meshes you use to avoid hitches when they're displayed\
      \ the first time. Overwrite the UpdatePrecacheMaterials and UpdatePrecacheStaticMeshes\
      \ functions (defined in <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\">Actor</a>)\
      \ to do that:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">simulated</span> <span class=\"kw1\">function</span> UpdatePrecacheMaterials<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \    <span class=\"kw6\">Super</span>.<span class=\"me0\">UpdatePrecacheMaterials</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n    <span class=\"kw7\"\
      >Level</span>.<span class=\"me0\">AddPrecacheMaterial</span><span class=\"br0\"\
      >(</span><span class=\"kw5\">Texture</span><span class=\"st0\">'MyUserInterfaceTexture'</span><span\
      \ class=\"br0\">)</span>;  <span class=\"co1\">// hard-coded texture reference</span>\n\
      \    <span class=\"kw7\">Level</span>.<span class=\"me0\">AddPrecacheMaterial</span><span\
      \ class=\"br0\">(</span>MapperSpecifiedMaterial<span class=\"br0\">)</span>;\
      \          <span class=\"co1\">// specified by mapper in UnrealEd</span>\n<span\
      \ class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"\
      kw1\">function</span> UpdatePrecacheStaticMeshes<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n    <span class=\"kw6\"\
      >Super</span>.<span class=\"me0\">UpdatePrecacheStaticMeshes</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span>;\n    <span class=\"kw7\">Level</span>.<span\
      \ class=\"me0\">AddPrecacheStaticMesh</span><span class=\"br0\">(</span><span\
      \ class=\"kw5\">StaticMesh</span><span class=\"st0\">'MyStaticMesh'</span><span\
      \ class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <h2><span class=\"mw-headline\" id=\"Optimize_expressions\">Optimize expressions</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Code_Optimization?section=8\" title=\"Edit section: Optimize\
      \ expressions\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Place operators in an optimized order – this seems trivial but can be important\
      \ for things that get called a lot, especially for replication statements.</p>\n\
      <p>Expressions in UnrealScript will terminate prematurely if applicable, so\
      \ you can take advantage of this. Similar to the optimizations for iterators,\
      \ if using \"or\" expressions, evaluate the most likely or least expensive things\
      \ first. That way, if it is true, it doesn't have to waste time on things that\
      \ usually will be false anyway. If it is an \"and\" expression, evaluate the\
      \ least likely thing first – that way you won't pass one check only to get stopped\
      \ by the second as often.</p>\n<p>The only real exception to this is if it is\
      \ necessary to avoid <i>Accessed None</i>s – obviously it's more likely that\
      \ a <a href=\"/Legacy:Controller\" title=\"Legacy:Controller\">Controller</a>'s\
      \ <a href=\"/Legacy:Pawn\" title=\"Legacy:Pawn\">Pawn</a> will have over 10\
      \ health than that a controller will not have a pawn at all, but for obvious\
      \ reasons you need to confirm that the controller has a pawn before attempting\
      \ to read a variable from it.</p>\n<h2><span class=\"mw-headline\" id=\"Avoid_Nesting_functions\"\
      >Avoid Nesting functions</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=9\"\
      \ title=\"Edit section: Avoid Nesting functions\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Although it seems like it would use less memory to\
      \ nest function calls, I've timed different variations on nested and non-nested\
      \ calls, and a non-nested call consistently ran at <i><b>twice</b></i> the speed\
      \ as a nested one:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      co1\">// Runs relatively slow.</span>\n<span class=\"kw1\">function</span> <span\
      \ class=\"kw5\">int</span> NestedFunction<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\">return</span>\
      \ DoSomething<span class=\"br0\">(</span> DoSomethingElse<span class=\"br0\"\
      >(</span> DoEvenMore<span class=\"br0\">(</span> <span class=\"nu0\">5</span>\
      \ <span class=\"br0\">)</span> <span class=\"br0\">)</span> <span class=\"br0\"\
      >)</span>;\n<span class=\"br0\">}</span>;\n \n<span class=\"co1\">// Runs WAY\
      \ faster.</span>\n<span class=\"kw1\">function</span> AFunction<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n \
      \ <span class=\"kw1\">local</span> <span class=\"kw5\">int</span> Value;\n \n\
      \  Value <span class=\"sy0\">=</span> DoEvenMore<span class=\"br0\">(</span>\
      \ <span class=\"nu0\">5</span> <span class=\"br0\">)</span>;\n  Value <span\
      \ class=\"sy0\">=</span> DoSomethingElse<span class=\"br0\">(</span> Value <span\
      \ class=\"br0\">)</span>;\n  <span class=\"kw2\">return</span> DoSomething<span\
      \ class=\"br0\">(</span> Value <span class=\"br0\">)</span>;\n<span class=\"\
      br0\">}</span>;</pre></div>\n</div>\n<p>I suspect this is an indication that\
      \ the interpreter's \"stack\" is not used very efficiently.</p>\n<p><b>Switch:</b>\
      \ With relatively simple functions I noticed something opposite - NestedFunction()\
      \ was faster by about 10%. With relatively large functions I couldn't measure\
      \ the difference. I was testing with stopwatch() in build 3355 commandlet.<br\
      \ />\nCan someone post an example where the nested function calls are noticeably\
      \ slower?</p>\n<h2><span class=\"mw-headline\" id=\"Use_native_functionality_instead_of_UnrealScript_code\"\
      >Use native functionality instead of UnrealScript code</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=10\"\
      \ title=\"Edit section: Use native functionality instead of UnrealScript code\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Use\
      \ native functions instead of scripted ones whenever possible.</p>\n<p>UnrealScript\
      \ runs a lot slower than the native functions do – it's usually better to use\
      \ a native function instead of writing your own, even if the native function\
      \ does a bunch of stuff you don't need. The wasted functionality is nothing\
      \ compared to the added speed of native functions.</p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Execute_code_only_as_often_as_needed\">Execute code only as often as\
      \ needed</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Code_Optimization?section=11\" title=\"Edit\
      \ section: Execute code only as often as needed\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Timeslicing less important calls in Tick or Timer\
      \ can increase speed.</p>\n<p>You could, for instance, use a boolean variable\
      \ and store the previous deltatime so that a less critical function can be called\
      \ only half the time, with the cumulative deltatime. You can also use an incrementing\
      \ integer and a cumulative Deltatime float to call functions even less often.\
      \ This makes the program look more complicated, unfortunately, but can decrease\
      \ the strain on the CPU.</p>\n<p><b>EntropicLqd:</b> Under those circumstances\
      \ couldn't you use the SetTimer(..) function to reduce the number of times the\
      \ Timer() function is called?</p>\n<p><b>Foxpaw:</b> Yes, but you only have\
      \ one Timer. If a superclass uses it you won't be able to use it unless your\
      \ timing needs are the exact same as those of the superclass. Furthermore, you\
      \ can only use it for one thing then. Say, for instance, you wanted to make\
      \ your own physics system. You wanted to update location every tick, velocity\
      \ every 3 ticks, and rotation every 5 ticks. Furthermore, you want to check\
      \ collision only every 13 ticks. This would be a bit difficult to do in Timer.</p>\n\
      <h2><span class=\"mw-headline\" id=\"Find_bottlenecks_by_measuring_execution_time\"\
      >Find bottlenecks by measuring execution time</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=12\"\
      \ title=\"Edit section: Find bottlenecks by measuring execution time\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>You can use the\
      \ Clock and UnClock functions (defined in <a href=\"/Legacy:Actor\" title=\"\
      Legacy:Actor\">Actor</a>, moved to <a href=\"/Legacy:Object\" title=\"Legacy:Object\"\
      >Object</a> for DeusEx) to measure the time a part of your code spends executing,\
      \ in milliseconds. Use this to find the sections of your code that require performance\
      \ optimzation most urgently, and to compare different ways of doing something\
      \ performance-wise.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">function</span> MyFunction<span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n    <span class=\"kw1\">local</span>\
      \ <span class=\"kw5\">float</span> ExecutionTime;\n \n    <span class=\"kw4\"\
      >Clock</span><span class=\"br0\">(</span>ExecutionTime<span class=\"br0\">)</span>;\n\
      \    <span class=\"co1\">// do something</span>\n    <span class=\"kw4\">UnClock</span><span\
      \ class=\"br0\">(</span>ExecutionTime<span class=\"br0\">)</span>;\n \n \n \
      \   <span class=\"kw3\">Log</span><span class=\"br0\">(</span><span class=\"\
      st0\">\"Time spent executing something:\"</span> <span class=\"sy0\">@</span>\
      \ ExecutionTime <span class=\"sy0\">@</span> <span class=\"st0\">\"ms\"</span><span\
      \ class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>Clock is a very useful function when you know exactly what you want to measure.\
      \ It is also handy because it returns the elapsed time to you, so you can use\
      \ it to take averages, etc. You could also even use it for some kind of gameplay\
      \ timer, though it sometimes \"rolls over\" which might not make it the best\
      \ for that.</p>\n<p>Clock uses CPU cycles rather than actual time. In most engines\
      \ the script equivalent of clock\\unclock automatically converts the value to\
      \ seconds rather than CPU cycles. However you should never use clock\\unclock\
      \ for actual timing perposes, only use it for local performance testing (e.g.\
      \ in case you change an algorithm and want to test if it's better or worse).\
      \ CPU cycles roll over very often, thus it's useless for longer periods (a second\
      \ is too much). Because of the over rolling the result after <code>UnClock</code>\
      \ might be incorrect, so when you use it perform the test multiple times to\
      \ get a proper value.</p>\n<p>If you want to test a lot of code, adding a lot\
      \ of clock, unclock, and log statements can be tedious. Enter Stopwatch. Stopwatch\
      \ is a much more powerful function than Clock, but works very differently. The\
      \ stopwatch is global, and it's either \"on\" or \"off.\"</p>\n<p>StopWatch(\
      \ false ); starts the stopwatch. StopWatch( true ); disables and resets the\
      \ timer. When you stop the timer, a line will be printed in the log stating\
      \ something like: Time=41.768ms. This is the time that the stopwatch was at\
      \ when it was stopped. This makes it appear to be very much like clock.. but\
      \ the log statement that shows the stop time is not what you can really do with\
      \ StopWatch.</p>\n<p>The magic of stopwatch is that when it is running it timestamps\
      \ log entries. Each is stamped with the time elapsed since the timer was started.\
      \ It is great for finding out the time taken throughout a function, without\
      \ writing a veritable pile of clock and unclock statements, as well as adding\
      \ temporary variables for them, and the works! But I digress. Here's an example:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">function</span>\
      \ SuperFantasticFunction<span class=\"br0\">(</span><span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"\
      kw5\">int</span> i;\n \n  <span class=\"kw3\">StopWatch</span><span class=\"\
      br0\">(</span> <span class=\"kw6\">false</span> <span class=\"br0\">)</span>;\n\
      \ \n  <span class=\"kw3\">log</span><span class=\"br0\">(</span> <span class=\"\
      st0\">\"Beginning Execution\"</span> <span class=\"br0\">)</span>;\n  <span\
      \ class=\"co1\">// ... some code goes here ...</span>\n  <span class=\"kw3\"\
      >log</span><span class=\"br0\">(</span> <span class=\"st0\">\"Initialization\
      \ Complete\"</span> <span class=\"br0\">)</span>;\n  <span class=\"co1\">//\
      \ ... more code ...</span>\n  <span class=\"kw3\">log</span><span class=\"br0\"\
      >(</span> <span class=\"st0\">\"Precomputation Complete\"</span> <span class=\"\
      br0\">)</span>;\n  <span class=\"co1\">// ... yet more code ...</span>\n  <span\
      \ class=\"kw3\">log</span><span class=\"br0\">(</span> <span class=\"st0\">\"\
      Entering Loop\"</span> <span class=\"br0\">)</span>;\n  <span class=\"kw2\"\
      >for</span> <span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"\
      nu0\">0</span>;i<span class=\"sy0\">&lt;</span><span class=\"nu0\">5</span>;i<span\
      \ class=\"sy0\">++</span><span class=\"br0\">)</span>\n  <span class=\"br0\"\
      >{</span>\n    <span class=\"co1\">// .. something done in a loop</span>\n \
      \   <span class=\"kw3\">log</span><span class=\"br0\">(</span> <span class=\"\
      st0\">\"Iteration \"</span><span class=\"sy0\">$</span><span class=\"br0\">(</span>i<span\
      \ class=\"sy0\">+</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>\
      \ <span class=\"br0\">)</span>;\n  <span class=\"br0\">}</span>\n \n  <span\
      \ class=\"kw3\">log</span><span class=\"br0\">(</span> <span class=\"st0\">\"\
      Loop Completed\"</span> <span class=\"br0\">)</span>;\n  <span class=\"co1\"\
      >// ... some finishing code ...</span>\n  <span class=\"kw3\">log</span><span\
      \ class=\"br0\">(</span> <span class=\"st0\">\"Function Completed\"</span> <span\
      \ class=\"br0\">)</span>;\n \n  <span class=\"kw3\">StopWatch</span><span class=\"\
      br0\">(</span> <span class=\"kw6\">true</span> <span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>Produces something like\
      \ the following in the log: (except stopwatch actually has a few more digits\
      \ of precision.)</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">  ScriptLog: <span\
      \ class=\"nu0\">0.00</span> ms: Beginning Execution \n  ScriptLog: <span class=\"\
      nu0\">0.12</span> ms: Initialization Complete\n  ScriptLog: <span class=\"nu0\"\
      >0.45</span> ms: Precomputation Complete\n  ScriptLog: <span class=\"nu0\">0.76</span>\
      \ ms: Entering <span class=\"kw2\">Loop</span>\n  ScriptLog: <span class=\"\
      nu0\">1.02</span> ms: Iteration <span class=\"nu0\">1</span> \n  ScriptLog:\
      \ <span class=\"nu0\">1.35</span> ms: Iteration <span class=\"nu0\">2</span>\n\
      \  ScriptLog: <span class=\"nu0\">1.68</span> ms: Iteration <span class=\"nu0\"\
      >3</span>\n  ScriptLog: <span class=\"nu0\">1.92</span> ms: Iteration <span\
      \ class=\"nu0\">4</span>\n  ScriptLog: <span class=\"nu0\">2.24</span> ms: Iteration\
      \ <span class=\"nu0\">5</span>\n  ScriptLog: <span class=\"nu0\">2.24</span>\
      \ ms: <span class=\"kw2\">Loop</span> Completed\n  ScriptLog: <span class=\"\
      nu0\">3.16</span> ms: <span class=\"kw1\">Function</span> Completed\n  <span\
      \ class=\"kw8\">Time</span><span class=\"sy0\">=</span><span class=\"nu0\">3.16</span>\
      \ ms</pre></div>\n</div>\n<h2><span class=\"mw-headline\" id=\"Unroll_your_loops\"\
      >Unroll your loops</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Code_Optimization?section=13\" title=\"Edit\
      \ section: Unroll your loops\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Setting up a loop can take extra time (especially\
      \ if Mychaeel is correct and loop iterations are counted). In some cases, the\
      \ number of iterations are known, and a loop doesn't need to be used at all:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw2\">for</span> <span\
      \ class=\"br0\">(</span><span class=\"kw5\">int</span> i <span class=\"sy0\"\
      >=</span> <span class=\"nu0\">0</span>; i <span class=\"sy0\">&lt;</span> <span\
      \ class=\"nu0\">5</span>; i<span class=\"sy0\">++</span><span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n    <span class=\"co1\">//Some Code.</span>\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>can be changed to</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"co1\">//Some Code.</span>\n\
      <span class=\"co1\">//Some Code.</span>\n<span class=\"co1\">//Some Code.</span>\n\
      <span class=\"co1\">//Some Code.</span>\n<span class=\"co1\">//Some Code.</span></pre></div>\n\
      </div>\n<p><b>Dante:</b> What if the engine doesn't count loop iterations but\
      \ counts every instruction&#160;? Then you might save 3 called instructions\
      \ with the unrolled loop. Sometimes it looks very ugly, leaving the for(i=0...5)\
      \ solution the better one.</p>\n<p><b>Sordith:</b> We could second guess how\
      \ the scripting engine works until we fill up the server's hard drive and not\
      \ really get anywhere. I <i>think</i> I tested this one (along with all of the\
      \ techniques I posted), but I can't remember the results. I'll test again later\
      \ and post some sample numbers. You are correct that sometimes (read most of\
      \ the time) it looks very ugly, and the time saved during execution may not\
      \ be worth the time lost when working with the ugly code. I didn't mention that\
      \ because the questions of what and when to optimize could easily take it's\
      \ own page.</p>\n<h2><span class=\"mw-headline\" id=\"Speed_comparison_of_loops\"\
      >Speed comparison of loops</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=14\"\
      \ title=\"Edit section: Speed comparison of loops\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Different loops have different overhead times. Lets\
      \ say we have following situation:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      >\t<span class=\"co1\">// data, length = 100</span>\n\t<span class=\"kw1\">var</span>\
      \ array<span class=\"sy0\">&lt;</span>vector<span class=\"sy0\">&gt;</span>\
      \ stuff;\t\t\t\t\t\t\t\t\n \n\t<span class=\"co1\">// code to loop\t\t\t\t\t\
      </span>\n\tstuff<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span\
      \ class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span class=\"br0\"\
      >(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span class=\"\
      nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;</pre></div>\n</div>\n<p>An obvious choice is for loop. Lets say that\
      \ it takes 1 time unit to execute such function. For comparison function with\
      \ unrolled loop takes 0.66 time units.</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\">\t<span class=\"kw1\">function</span> Test<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">int</span> n <span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw1\">local</span> <span class=\"kw5\">int</span>\
      \ i;\n\t\t<span class=\"kw2\">for</span><span class=\"br0\">(</span>i<span class=\"\
      sy0\">=</span><span class=\"nu0\">0</span>; i<span class=\"sy0\">!=</span>n;\
      \ <span class=\"sy0\">++</span>i<span class=\"br0\">)</span>\n\t\t<span class=\"\
      br0\">{</span>\n\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"br0\"\
      >]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t<span class=\"br0\">}</span>\n\t<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>While loop takes 0.93 time units. That's probably because the i variable\
      \ is accessed not three but two times in each loop iteration.</p>\n<div dir=\"\
      ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\">\t<span class=\"kw2\">while</span><span class=\"br0\"\
      >(</span> i<span class=\"sy0\">!=</span>n <span class=\"br0\">)</span>\n\t<span\
      \ class=\"br0\">{</span>\n\t\tstuff<span class=\"br0\">[</span>i<span class=\"\
      sy0\">++</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span\
      \ class=\"kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">1</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>Until loop takes 0.90 time units. Equality operator or internal implementation\
      \ may be faster.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">\t<span class=\"\
      kw2\">if</span><span class=\"br0\">(</span> n<span class=\"sy0\">!=</span><span\
      \ class=\"nu0\">0</span> <span class=\"br0\">)</span>\n\t<span class=\"br0\"\
      >{</span>\n\t\t<span class=\"kw2\">do</span>\n\t\t<span class=\"br0\">{</span>\n\
      \t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span class=\"\
      br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t<span class=\"br0\">}</span>until<span class=\"br0\">(</span>\
      \ i<span class=\"sy0\">==</span>n <span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>What about a goto loop? 0.93 time units,\
      \ same as while loop.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">\t<span class=\"\
      kw2\">loop</span>:\n\t\t<span class=\"kw2\">if</span><span class=\"br0\">(</span>\
      \ i<span class=\"sy0\">!=</span>n <span class=\"br0\">)</span>\n\t\t<span class=\"\
      br0\">{</span>\n\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\"\
      >++</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">1</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">*</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span>;\n\t\t\tgoto <span class=\"st0\">'loop'</span>;\n\
      \t\t<span class=\"br0\">}</span></pre></div>\n</div>\n<p>The fastest loop I\
      \ tested was partially unrolled one - 0.76 time units. Choose how many times\
      \ you want to duplicate the code (4-8 will do), loop couple times so the number\
      \ of iterations is a multiply of chosen number and run the duplicated code in\
      \ another loop.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\">\t<span class=\"\
      kw1\">local</span> <span class=\"kw5\">int</span> iterations, modulus;\n \n\t\
      <span class=\"kw2\">if</span><span class=\"br0\">(</span> n <span class=\"sy0\"\
      >!=</span> <span class=\"nu0\">0</span> <span class=\"br0\">)</span>\n\t<span\
      \ class=\"br0\">{</span>\n\t\tmodulus <span class=\"sy0\">=</span> n <span class=\"\
      sy0\">%</span> <span class=\"nu0\">8</span>;\n\t\t<span class=\"kw2\">if</span><span\
      \ class=\"br0\">(</span> modulus <span class=\"sy0\">!=</span> <span class=\"\
      nu0\">0</span> <span class=\"br0\">)</span> \n\t\t<span class=\"br0\">{</span>\n\
      \t\t\t<span class=\"kw2\">do</span>\n\t\t\t<span class=\"br0\">{</span>\n\t\t\
      \t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span class=\"\
      br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t<span class=\"br0\">}</span>\n\t\t\tuntil<span class=\"br0\"\
      >(</span> <span class=\"sy0\">--</span>modulus <span class=\"sy0\">==</span>\
      \ <span class=\"nu0\">0</span> <span class=\"br0\">)</span>\n\t\t<span class=\"\
      br0\">}</span>\n \n\t\titerations <span class=\"sy0\">=</span> n <span class=\"\
      sy0\">/</span> <span class=\"nu0\">8</span>;\n\t\t<span class=\"kw2\">if</span><span\
      \ class=\"br0\">(</span> iterations <span class=\"sy0\">!=</span> <span class=\"\
      nu0\">0</span> <span class=\"br0\">)</span>\n\t\t<span class=\"br0\">{</span>\n\
      \t\t\t<span class=\"kw2\">do</span>\n\t\t\t<span class=\"br0\">{</span>\n\t\t\
      \t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span class=\"\
      br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">+</span> <span class=\"kw3\">vect</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">*</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n\t\t\t<span class=\"br0\">}</span>\n\t\t\tuntil<span class=\"br0\"\
      >(</span> <span class=\"sy0\">--</span>iterations <span class=\"sy0\">==</span>\
      \ <span class=\"nu0\">0</span> <span class=\"br0\">)</span>\n\t\t<span class=\"\
      br0\">}</span>\n\t<span class=\"br0\">}</span></pre></div>\n</div>\n<h2><span\
      \ class=\"mw-headline\" id=\"Refine_your_algorithms\">Refine your algorithms</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Code_Optimization?section=15\" title=\"Edit section: Refine\
      \ your algorithms\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Different operations take different amounts of time. Generally speaking,\
      \ addition, subtraction, assignment, and shifting take small amounts time. Multiplication\
      \ takes a slightly longer time, while division takes the most time. Using floating\
      \ point numbers also increases execution time. Integer multiplication and division\
      \ by powers of 2 can be converted into shifts. Division by a floating point\
      \ number can be converted into multiplication by a floating point number (x/0.5\
      \ == x * (1/0.5)).</p>\n<p><b>Sordith:</b> Don't like the way this one reads,\
      \ but can't seem to spit it out more clearly.</p>\n<p><b>Mychaeel:</b> I don't\
      \ believe UnrealScript's compiler optimizes constant subexpressions, so \"1/0.5\"\
      \ does probably involve a division at run time. Also, while you're technically\
      \ right of course, I don't believe that this technique has <i>noticable</i>\
      \ impact on the execution speed of UnrealScript code – you have to assume that\
      \ UnrealScript byte code is executed at least one order of magnitude slower\
      \ than native code, and on top of that every operation in an expression translates\
      \ to a function call with all of its overhead anyway (instead of being resolved\
      \ to an inline operation).</p>\n<p><b>Sordith:</b> This is true. Optimising\
      \ outside of a loop will rarely have noticable results. These techniques should\
      \ be used where working with a large number of objects, or when doing calculations\
      \ every frame, and probably not even then unless you need the extra time.</p>\n\
      <p>I was thinking more along the lines of:</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\"><span class=\"kw1\">local</span> <span class=\"kw5\">float</span> mult\
      \ <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\"\
      >/</span><span class=\"nu0\">0.5</span>;\n<span class=\"kw2\">for</span> <span\
      \ class=\"br0\">(</span><span class=\"kw5\">int</span> i <span class=\"sy0\"\
      >=</span> <span class=\"nu0\">0</span>; i <span class=\"sy0\">&lt;</span> <span\
      \ class=\"nu0\">1000</span>; i<span class=\"sy0\">++</span><span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n    a <span class=\"sy0\">*=</span>\
      \ mult;\n    b <span class=\"sy0\">*=</span> mult;\n    c <span class=\"sy0\"\
      >*=</span> mult;\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>also,\
      \ if you want to divide by a constant number, you can change it to multiplication\
      \ by a constant number without the overhead of the first division or the temp\
      \ variable.</p>\n<h2><span class=\"mw-headline\" id=\"The_member_selection_operator_has_its_price\"\
      >The member selection operator has its price</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Code_Optimization?section=16\"\
      \ title=\"Edit section: The member selection operator has its price\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>By member selection\
      \ operator I mean the dot used to access objects in other objects. Don't forget\
      \ it's also a function and one that may slow down your calculations quite a\
      \ lot. If the objects are constant from the loop point of view, you may cache\
      \ them as mentioned above. You may also try to optimize by using additional\
      \ calculations instead of the member selection operator.</p>\n<p>In following\
      \ example the member selection operator is used 900 times. Let's say that execution\
      \ of this function took 1 time unit.</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\">\t<span class=\"kw1\">var</span> <span class=\"kw5\">vector</span> stuff<span\
      \ class=\"br0\">[</span><span class=\"nu0\">100</span><span class=\"br0\">]</span>;\n\
      \ \n\t<span class=\"kw1\">function</span> Test<span class=\"br0\">(</span> <span\
      \ class=\"kw5\">vector</span> v <span class=\"br0\">)</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw1\">local</span> <span class=\"kw5\">int</span>\
      \ i;\n\t\t<span class=\"kw2\">for</span><span class=\"br0\">(</span>i<span class=\"\
      sy0\">=</span><span class=\"nu0\">0</span>; i<span class=\"sy0\">&lt;</span><span\
      \ class=\"nu0\">100</span>; <span class=\"sy0\">++</span>i<span class=\"br0\"\
      >)</span>\n\t\t<span class=\"br0\">{</span>\t\n\t\t\tstuff<span class=\"br0\"\
      >[</span>i<span class=\"br0\">]</span>.<span class=\"me0\">x</span> <span class=\"\
      sy0\">=</span> v.<span class=\"me0\">x</span> <span class=\"sy0\">+</span> v.<span\
      \ class=\"me0\">x</span><span class=\"sy0\">*</span><span class=\"br0\">(</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span><span class=\"sy0\">-</span><span class=\"nu0\">0.5</span><span class=\"\
      br0\">)</span>;\n\t\t\tstuff<span class=\"br0\">[</span>i<span class=\"br0\"\
      >]</span>.<span class=\"me0\">y</span> <span class=\"sy0\">=</span> v.<span\
      \ class=\"me0\">y</span> <span class=\"sy0\">+</span> v.<span class=\"me0\"\
      >y</span><span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"\
      kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">-</span><span class=\"nu0\">0.6</span><span class=\"br0\">)</span>;\n\
      \t\t\tstuff<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"\
      me0\">z</span> <span class=\"sy0\">=</span> v.<span class=\"me0\">x</span> <span\
      \ class=\"sy0\">+</span> v.<span class=\"me0\">z</span><span class=\"sy0\">*</span><span\
      \ class=\"br0\">(</span><span class=\"kw3\">FRand</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span><span class=\"sy0\">-</span><span class=\"\
      nu0\">0.7</span><span class=\"br0\">)</span>;\n\t\t<span class=\"br0\">}</span>\t\
      \n\t<span class=\"br0\">}</span></pre></div>\n</div>\n<p>Let's eliminate 600\
      \ uses of member selection operator (v members) by adding 3 local variables,\
      \ 3 assignments, and 3 uses of member selection operator. At this point it takes\
      \ 0.6 time units to execute the function.<br />\nThe remaining 300 uses of member\
      \ selection operator (stuff[i] members) can be eliminated by adding 300 multiplications\
      \ by vector and 200 vector additions. After this optimization the execution\
      \ time is 0.39 time units. That's over 2.5 times faster than the original example.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\">\t<span class=\"kw1\">function</span>\
      \ Test<span class=\"br0\">(</span> <span class=\"kw5\">vector</span> v <span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw1\">local</span> <span class=\"kw5\">int</span> i;\n\t\t<span class=\"kw1\"\
      >local</span> <span class=\"kw5\">float</span> vx,vy,vz;\n \n\t\tvx<span class=\"\
      sy0\">=</span>v.<span class=\"me0\">x</span>;\n\t\tvy<span class=\"sy0\">=</span>v.<span\
      \ class=\"me0\">y</span>;\n\t\tvz<span class=\"sy0\">=</span>v.<span class=\"\
      me0\">z</span>;\n \n\t\t<span class=\"kw2\">for</span><span class=\"br0\">(</span>i<span\
      \ class=\"sy0\">=</span><span class=\"nu0\">0</span>; i<span class=\"sy0\">&lt;</span><span\
      \ class=\"nu0\">100</span>; <span class=\"sy0\">++</span>i<span class=\"br0\"\
      >)</span>\n\t\t<span class=\"br0\">{</span>\t\n\t\t\tstuff<span class=\"br0\"\
      >[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">1</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">*</span> <span class=\"br0\">(</span>vx <span class=\"\
      sy0\">+</span> vx<span class=\"sy0\">*</span><span class=\"br0\">(</span><span\
      \ class=\"kw3\">FRand</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span><span class=\"sy0\">-</span><span class=\"nu0\">0.5</span><span class=\"\
      br0\">)</span><span class=\"br0\">)</span>\n\t\t\t\t\t <span class=\"sy0\">+</span>\
      \ <span class=\"kw3\">vect</span><span class=\"br0\">(</span><span class=\"\
      nu0\">0</span>,<span class=\"nu0\">1</span>,<span class=\"nu0\">0</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>vy\
      \ <span class=\"sy0\">+</span> vy<span class=\"sy0\">*</span><span class=\"\
      br0\">(</span><span class=\"kw3\">FRand</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span><span class=\"sy0\">-</span><span class=\"nu0\">0.6</span><span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>\n\t\t\t\t\t <span class=\"\
      sy0\">+</span> <span class=\"kw3\">vect</span><span class=\"br0\">(</span><span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>vz\
      \ <span class=\"sy0\">+</span> vz<span class=\"sy0\">*</span><span class=\"\
      br0\">(</span><span class=\"kw3\">FRand</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span><span class=\"sy0\">-</span><span class=\"nu0\">0.7</span><span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>;\n\t\t<span class=\"br0\"\
      >}</span>\n\t<span class=\"br0\">}</span></pre></div>\n</div>\n<h2><span class=\"\
      mw-headline\" id=\"Be_careful_with_temporary_variables\">Be careful with temporary\
      \ variables</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Code_Optimization?section=17\" title=\"Edit\
      \ section: Be careful with temporary variables\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>First of all, you should remove all unused variables\
      \ from your functions. (The UT200x compiler will warn you about unused local\
      \ variables.) They slightly increase package size and whether they also affect\
      \ execution speed is yet to be proven. They definately make your code harder\
      \ to read if you have lots of them.</p>\n<p>Assignment is a pretty expensive\
      \ operation in UnrealScript compared to reading variable values, especially\
      \ with structs. If you are working with dynamic arrays and want to move an element\
      \ to a new position with a higher array index you might come up with a solution\
      \ similar to this if you are used to languages without dynamic arrays:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">function</span>\
      \ MoveElementUp<span class=\"br0\">(</span><span class=\"kw5\">int</span> Source,\
      \ <span class=\"kw5\">int</span> Destination<span class=\"br0\">)</span>\n<span\
      \ class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"\
      kw5\">int</span> i;\n  <span class=\"kw1\">local</span> <span class=\"kw5\"\
      >float</span> tmp;\n \n  tmp <span class=\"sy0\">=</span> MyArray<span class=\"\
      br0\">[</span>Source<span class=\"br0\">]</span>;\n  <span class=\"kw2\">for</span>\
      \ <span class=\"br0\">(</span>i <span class=\"sy0\">=</span> Source; i <span\
      \ class=\"sy0\">&lt;</span> Destination; i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">)</span>\n    MyArray<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span> <span class=\"sy0\">=</span> MyArray<span class=\"br0\">[</span>i\
      \ <span class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\"\
      >]</span>;\n  MyArray<span class=\"br0\">[</span>Destination<span class=\"br0\"\
      >]</span> <span class=\"sy0\">=</span> tmp;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>Of source, this is a really bad implementation since it completely\
      \ neglects the features of dynamic arrays. (You might have to use it for static\
      \ arrays, though.)</p>\n<p>A way better solution would be the following:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">function</span>\
      \ MoveElement<span class=\"br0\">(</span><span class=\"kw5\">int</span> Source,\
      \ <span class=\"kw5\">int</span> Destination<span class=\"br0\">)</span>\n<span\
      \ class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"\
      kw5\">float</span> tmp;\n \n  tmp <span class=\"sy0\">=</span> MyArray<span\
      \ class=\"br0\">[</span>Source<span class=\"br0\">]</span>;\n  MyArray.<span\
      \ class=\"me0\">Remove</span><span class=\"br0\">(</span>Source, <span class=\"\
      nu0\">1</span><span class=\"br0\">)</span>;\n  MyArray.<span class=\"me0\">Insert</span><span\
      \ class=\"br0\">(</span>Destination, <span class=\"nu0\">1</span><span class=\"\
      br0\">)</span>\n  MyArray<span class=\"br0\">[</span>Destination<span class=\"\
      br0\">]</span> <span class=\"sy0\">=</span> tmp;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>This implementation not only works for moving in both directions\
      \ (up or down), but also completely drops the loop.</p>\n<p>There's still a\
      \ temporary variable though, which requires an additional assignment operation.\
      \ Let's get rid of that as well:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">function</span> MoveElement<span class=\"br0\">(</span><span\
      \ class=\"kw5\">int</span> Source, <span class=\"kw5\">int</span> Destination<span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> Source <span class=\"sy0\">&lt;</span>\
      \ Destination <span class=\"br0\">)</span> <span class=\"br0\">{</span>  <span\
      \ class=\"co1\">// move up</span>\n    MyArray.<span class=\"me0\">Insert</span><span\
      \ class=\"br0\">(</span>Destination <span class=\"sy0\">+</span> <span class=\"\
      nu0\">1</span>, <span class=\"nu0\">1</span><span class=\"br0\">)</span>;\n\
      \    MyArray<span class=\"br0\">[</span>Destination <span class=\"sy0\">+</span>\
      \ <span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\"\
      >=</span> MyArray<span class=\"br0\">[</span>Source<span class=\"br0\">]</span>;\n\
      \    MyArray.<span class=\"me0\">Remove</span><span class=\"br0\">(</span>Source,\
      \ <span class=\"nu0\">1</span><span class=\"br0\">)</span>;\n  <span class=\"\
      br0\">}</span>\n  <span class=\"kw2\">else</span> <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> Source <span class=\"sy0\">&gt;</span> Destination\
      \ <span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"co1\"\
      >// move down</span>\n    MyArray.<span class=\"me0\">Insert</span><span class=\"\
      br0\">(</span>Destination, <span class=\"nu0\">1</span><span class=\"br0\">)</span>;\n\
      \    MyArray<span class=\"br0\">[</span>Destination<span class=\"br0\">]</span>\
      \ <span class=\"sy0\">=</span> MyArray<span class=\"br0\">[</span>Source <span\
      \ class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span>;\n\
      \    MyArray.<span class=\"me0\">Remove</span><span class=\"br0\">(</span>Source\
      \ <span class=\"sy0\">+</span> <span class=\"nu0\">1</span>, <span class=\"\
      nu0\">1</span><span class=\"br0\">)</span>;\n  <span class=\"br0\">}</span>\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>If the destination has\
      \ a higher index than the source, the new element needs to be inserted at an\
      \ index 1 higher than the desired index, because when removing the source element\
      \ afterwards, all following elements' indices are decreased by 1. In the case\
      \ of moving the element down, inserting the destination element increases the\
      \ source element's index by 1.</p>\n<p><b>Xian:</b> I'll also assume that resetting\
      \ temporary Object pointers to \"None\" will also help. Though I am not too\
      \ sure about how UE handles memory management at such points.</p>\n<p><b>Wormbo:</b>\
      \ Like the second paragraph in this section mentions: Assignment is a relatively\
      \ expensive operation. Local variables (and thus any object references) cease\
      \ to exist upon returning from the function they are declared in. The UnrealEngine\
      \ 1 and 2 don't collect garbage at all during gameplay, only when the \"Obj\
      \ Garbage\" console command is executed, which in regular gameplay only happens\
      \ at mapchange and in UT2004 between Onslaught/Assault rounds. I don't think\
      \ much was changed in UnrealEngine 3, but maybe the garbage collector can run\
      \ asynchronously now. Anyway, it's probably still not worth the additional execution\
      \ time to explicitly clear local object references. If you really have to create\
      \ a lot of objects dynamically, consider using an object pool instead of creating\
      \ temporary objects every time.</p>\n<h2><span class=\"mw-headline\" id=\"Related_Topics\"\
      >Related Topics</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Code_Optimization?section=18\" title=\"Edit\
      \ section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <ul>\n<li><a href=\"/Legacy:UnrealScript\" title=\"Legacy:UnrealScript\">UnrealScript</a></li>\n\
      </ul>\n\n<!-- \nNewPP limit report\nCPU time usage: 0.479 seconds\nReal time\
      \ usage: 0.623 seconds\nPreprocessor visited node count: 280/1000000\nPreprocessor\
      \ generated node count: 540/1000000\nPost‐expand include size: 0/2097152 bytes\n\
      Template argument size: 0/2097152 bytes\nHighest expansion depth: 2/40\nExpensive\
      \ parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report\
      \ (%,ms,calls,template)\n100.00%    0.000      1 - -total\n-->\n\n<!-- Saved\
      \ in parser cache with key wiki:pcache:idhash:883-0!*!0!!en!*!* and timestamp\
      \ 20221118022014 and revision id 34128\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:InteractionMaster"
  - ns: 100
    exists: true
    name: "Legacy:Pawn"
  - ns: 100
    exists: true
    name: "Legacy:Object Pool"
  - ns: 100
    exists: true
    name: "Legacy:Object"
  - ns: 100
    exists: true
    name: "Legacy:Dynamic Array"
  - ns: 100
    exists: true
    name: "Legacy:Creating Actors And Objects"
  - ns: 100
    exists: true
    name: "Legacy:SpawnNotify"
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript"
  - ns: 100
    exists: true
    name: "Legacy:Map Optimization"
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  - ns: 100
    exists: true
    name: "Legacy:Controller"
  - ns: 100
    exists: true
    name: "Legacy:Interaction"
  - ns: 100
    exists: true
    name: "Legacy:Iterator"
  - ns: 100
    exists: true
    name: "Legacy:Log Warnings"
  - ns: 100
    exists: true
    name: "Legacy:Actor/Methods"
  - ns: 100
    exists: true
    name: "Legacy:Linked List"
  templates: []
  images: []
  externallinks: []
  sections:
  - toclevel: 1
    level: "2"
    line: "You might be looking for..."
    number: "1"
    index: "1"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 158
    anchor: "You_might_be_looking_for..."
  - toclevel: 1
    level: "2"
    line: "Keep the log clean"
    number: "2"
    index: "2"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 238
    anchor: "Keep_the_log_clean"
  - toclevel: 1
    level: "2"
    line: "Avoid iterators"
    number: "3"
    index: "3"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 1062
    anchor: "Avoid_iterators"
  - toclevel: 1
    level: "2"
    line: "Optimize iterator use"
    number: "4"
    index: "4"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 1714
    anchor: "Optimize_iterator_use"
  - toclevel: 1
    level: "2"
    line: "Disable engine events when you don't need them"
    number: "5"
    index: "5"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 4791
    anchor: "Disable_engine_events_when_you_don.27t_need_them"
  - toclevel: 1
    level: "2"
    line: "Re-use objects"
    number: "6"
    index: "6"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 5638
    anchor: "Re-use_objects"
  - toclevel: 1
    level: "2"
    line: "Precache materials and static meshes"
    number: "7"
    index: "7"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 6211
    anchor: "Precache_materials_and_static_meshes"
  - toclevel: 1
    level: "2"
    line: "Optimize expressions"
    number: "8"
    index: "8"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 6947
    anchor: "Optimize_expressions"
  - toclevel: 1
    level: "2"
    line: "Avoid Nesting functions"
    number: "9"
    index: "9"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 8001
    anchor: "Avoid_Nesting_functions"
  - toclevel: 1
    level: "2"
    line: "Use native functionality instead of UnrealScript code"
    number: "10"
    index: "10"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 8983
    anchor: "Use_native_functionality_instead_of_UnrealScript_code"
  - toclevel: 1
    level: "2"
    line: "Execute code only as often as needed"
    number: "11"
    index: "11"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 9402
    anchor: "Execute_code_only_as_often_as_needed"
  - toclevel: 1
    level: "2"
    line: "Find bottlenecks by measuring execution time"
    number: "12"
    index: "12"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 10547
    anchor: "Find_bottlenecks_by_measuring_execution_time"
  - toclevel: 1
    level: "2"
    line: "Unroll your loops"
    number: "13"
    index: "13"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 14247
    anchor: "Unroll_your_loops"
  - toclevel: 1
    level: "2"
    line: "Speed comparison of loops"
    number: "14"
    index: "14"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 15475
    anchor: "Speed_comparison_of_loops"
  - toclevel: 1
    level: "2"
    line: "Refine your algorithms"
    number: "15"
    index: "15"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 18089
    anchor: "Refine_your_algorithms"
  - toclevel: 1
    level: "2"
    line: "The member selection operator has its price"
    number: "16"
    index: "16"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 19919
    anchor: "The_member_selection_operator_has_its_price"
  - toclevel: 1
    level: "2"
    line: "Be careful with temporary variables"
    number: "17"
    index: "17"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 21531
    anchor: "Be_careful_with_temporary_variables"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "18"
    index: "18"
    fromtitle: "Legacy:Code_Optimization"
    byteoffset: 24911
    anchor: "Related_Topics"
  displaytitle: "Legacy:Code Optimization"
  iwlinks: []
  wikitext:
    text: "If your code runs slow or causes hitches on some computers, here are several\
      \ '''optimization techniques''' you can apply to your code to make it run better.\n\
      \n==You might be looking for...==\n* [[Legacy:Map Optimization|Map Optimization]]\n\
      \n==Keep the log clean==\n\nEvery line that is written to the log file takes\
      \ time.  Writing lots of them to the log may slow down your mod to a crawl and\
      \ can inflate the game's log to several megabytes after a short time already.\n\
      \n; Fix <i>Accessed None</i> and other log warnings : Fix all ''Accessed None''\
      \ and other [[Legacy:Log Warnings|log warnings]] you find in the log after executing\
      \ your mod.  (You can safely assume that your code is responsible for any script\
      \ warning you find in the log after executing it, even those that point to somewhere\
      \ in Epic's code.  Compare with the log when not playing your mod if in doubt.)\n\
      \n; Remove debug logging : Make sure to remove any debugging log statements\
      \ in release versions of your mods.  If you think you may need the log statements\
      \ in future again, just comment them out.\n\n==Avoid iterators==\n\nAvoid using\
      \ any [[Legacy:Iterator|iterator]]s in frequently executed functions like <code>Tick</code>\
      \ or <code>PostRender</code> because they are, for the most part, extremely\
      \ slow.\n\nInstead try using [[Legacy:Linked List|linked list]]s or [[Legacy:Dynamic\
      \ Array|dynamic array]]s for the actors you work with. You could either fill\
      \ these at the start of the match, e.g. with a single iterator loop, or maintain\
      \ the list when spawning and destroying actors like the [[Legacy:SpawnNotify|SpawnNotify]]\
      \ in UT or the [[Legacy:Interaction|Interaction]] lists maintained by the [[Legacy:InteractionMaster|InteractionMaster]]\
      \ in UT2003.\n\n==Optimize iterator use==\n\nIf you can't avoid using them,\
      \ at least try to optimize them.\n\nVisibleActors and VisibleCollidingActors\
      \ are good examples of this. Every actor that is within the radius has a FastTrace\
      \ called on it. Traces use a lot of CPU resources and if the radius is large\
      \ you will be calling a lot of traces. You can spare yourself some traces by\
      \ checking anything else than needs to be checked on top of the trace first.\n\
      \nFor example, if you are looking for all visible pawns within 2000 units that\
      \ have over 50 health, we can check the health before we check the trace &ndash;\
      \ that way we don't bother doing the expensive visibility check if it was going\
      \ to fail the health check anyway. For example:\n\n<uscript>\n// this way is\
      \ slow\nforeach VisibleActors(class'Pawn', P, Radius, Location, True)\n  if\
      \ (P.Health > 50)\n    // do something\n\n// this way is faster\nforeach RadiusActors(class'Pawn',\
      \ P, Radius, Location, True)\n  if (P.Health > 50 && FastTrace(P.Location, Location))\n\
      \    // do something\n</uscript>\n\nAnother example of an even slower implementation\
      \ that needs to check all actors, not just Pawns:\n\n<uscript>\nforeach VisibleCollidingActors(class'Actor',\
      \ thisActor, Radius, Location)\n{\n    if (thisActor.bStatic || thisActor.Physics\
      \ == PHYS_None)\n        continue;  // skip this actor\n    // do the actual\
      \ stuff\n}\n</uscript>\n\nWithin a radius of e.g. 1500 you could easily find\
      \ over 300 actors. The loop will execute a FastTrace (see [[Legacy:Actor/Methods|Actor/Methods]])\
      \ for every single actor in the collision hash within the specified area. However,\
      \ a lot of those actors are most probably static and/or have <code>Physics ==\
      \ None</code>. FastTrace requires much more time than the checks used within\
      \ the loop, but those checks would catch almost as many actors. A simple optimization\
      \ would be executing the FastTrace ''after'' the other two checks. This can\
      \ be done by using the CollidingActors (still faster than RadiusActors with\
      \ up to 2000 UU radius) iterator instead:\n\n<uscript>\nForEach CollidingActors(class'Actor',\
      \ thisActor, Radius, Location) {\n    if ( thisActor.bStatic || thisActor.Physics\
      \ == PHYS_None || !FastTrace(Other.Location, Location) )\n        continue;\
      \ // skip this actor\n\n    // do the actual stuff\n}\n</uscript>\n\nThis will\
      \ execute much faster, but why?\n\nImagine those 300 actors, let's say 200-250\
      \ of them are StaticMeshes placed in the map. Those are all static actors which\
      \ will be caught by the first part of the <tt>if</tt> statement. Some other\
      \ actors might be e.g. gibs lying on the floor. Those actors have <code>Physics\
      \ == PHYS_None</code> and will be caught by the second part of the <tt>if</tt>\
      \ statement. Typically over 90% of the actors will ''fail'' to pass those first\
      \ two tests, leaving only about 30 actors for the FastTrace check in this example.\
      \ This means we only have to do 30 FastTraces instead of 300. Now imagine you\
      \ want to run this loop every Tick. A high number of FastTraces can slow down\
      \ the game by 50% or even more, while about 10-30 of those Traces can only be\
      \ noticed by checking the frame rate.\n\n==Disable engine events when you don't\
      \ need them==\n\nUse the Disable function to deactivate certain engine events\
      \ when you don't need them.  (That only applies for events you provide an UnrealScript\
      \ implementation for; if you haven't overwritten an engine event in your class,\
      \ disabling it makes no difference.)\n\n<uscript>\nevent PostBeginPlay\n{\n\
      \    // all events are enabled by default, so disable Tick event to start with\n\
      \    Disable('Tick');\n}\n\nevent Trigger(Actor Sender, Pawn Instigator)\n{\n\
      \    // tell engine to call Tick event from now on\n    Enable('Tick');\n}\n\
      \nevent Tick(float DeltaTime)\n{\n    // do something -- executed only after\
      \ the actor has been triggered\n}\n</uscript>\n\nUsing Disable and Enable is\
      \ more efficient than using a bool variable and doing an UnrealScript-level\
      \ check in the Tick function.  (And it's more elegant as well.)\n\n==Re-use\
      \ objects==\n\n[[Legacy:Creating Actors And Objects|Creating actors and objects]]\
      \ is a relatively expensive operation.  If you can, design your code so that\
      \ you spawn an actor or object you need only once, save a reference to it and\
      \ use it later again.\n\nThe [[Legacy:Object Pool|object pool]] makes re-using\
      \ non-Actor objects convenient and straightforward:  ''Allocating'' an object\
      \ of a given class either takes an existing one from the pool or automatically\
      \ creates a new one if none exists yet; ''freeing'' an object doesn't destroy\
      \ it but puts it into the pool.\n\n==Precache materials and static meshes==\n\
      \nPrecache any new materials or static meshes you use to avoid hitches when\
      \ they're displayed the first time.  Overwrite the UpdatePrecacheMaterials and\
      \ UpdatePrecacheStaticMeshes functions (defined in [[Legacy:Actor|Actor]]) to\
      \ do that:\n\n<uscript>\nsimulated function UpdatePrecacheMaterials()\n{\n \
      \   Super.UpdatePrecacheMaterials();\n    Level.AddPrecacheMaterial(Texture'MyUserInterfaceTexture');\
      \  // hard-coded texture reference\n    Level.AddPrecacheMaterial(MapperSpecifiedMaterial);\
      \          // specified by mapper in UnrealEd\n}\n\nsimulated function UpdatePrecacheStaticMeshes()\n\
      {\n    Super.UpdatePrecacheStaticMeshes();\n    Level.AddPrecacheStaticMesh(StaticMesh'MyStaticMesh');\n\
      }\n</uscript>\n\n==Optimize expressions==\n\nPlace operators in an optimized\
      \ order &ndash; this seems trivial but can be important for things that get\
      \ called a lot, especially for replication statements.\n\nExpressions in UnrealScript\
      \ will terminate prematurely if applicable, so you can take advantage of this.\
      \ Similar to the optimizations for iterators, if using \"or\" expressions, evaluate\
      \ the most likely or least expensive things first. That way, if it is true,\
      \ it doesn't have to waste time on things that usually will be false anyway.\
      \ If it is an \"and\" expression, evaluate the least likely thing first &ndash;\
      \ that way you won't pass one check only to get stopped by the second as often.\n\
      \nThe only real exception to this is if it is necessary to avoid ''Accessed\
      \ None''s &ndash; obviously it's more likely that a [[Legacy:Controller|Controller]]'s\
      \ [[Legacy:Pawn|Pawn]] will have over 10 health than that a controller will\
      \ not have a pawn at all, but for obvious reasons you need to confirm that the\
      \ controller has a pawn before attempting to read a variable from it.\n\n==Avoid\
      \ Nesting functions==\n\nAlthough it seems like it would use less memory to\
      \ nest function calls, I've timed different variations on nested and non-nested\
      \ calls, and a non-nested call consistently ran at '''''twice''''' the speed\
      \ as a nested one:\n\n<uscript>\n// Runs relatively slow.\nfunction int NestedFunction()\n\
      {\n  return DoSomething( DoSomethingElse( DoEvenMore( 5 ) ) );\n};\n\n// Runs\
      \ WAY faster.\nfunction AFunction()\n{\n  local int Value;\n\n  Value = DoEvenMore(\
      \ 5 );\n  Value = DoSomethingElse( Value );\n  return DoSomething( Value );\n\
      };\n</uscript>\n\nI suspect this is an indication that the interpreter's \"\
      stack\" is not used very efficiently.\n\n'''Switch:''' With relatively simple\
      \ functions I noticed something opposite - NestedFunction() was faster by about\
      \ 10%. With relatively large functions I couldn't measure the difference. I\
      \ was testing with stopwatch() in build 3355 commandlet.<br />Can someone post\
      \ an example where the nested function calls are noticeably slower? \n\n==Use\
      \ native functionality instead of UnrealScript code==\n\nUse native functions\
      \ instead of scripted ones whenever possible.\n\nUnrealScript runs a lot slower\
      \ than the native functions do &ndash; it's usually better to use a native function\
      \ instead of writing your own, even if the native function does a bunch of stuff\
      \ you don't need. The wasted functionality is nothing compared to the added\
      \ speed of native functions.\n\n==Execute code only as often as needed==\n\n\
      Timeslicing less important calls in Tick or Timer can increase speed.\n\nYou\
      \ could, for instance, use a boolean variable and store the previous deltatime\
      \ so that a less critical function can be called only half the time, with the\
      \ cumulative deltatime. You can also use an incrementing integer and a cumulative\
      \ Deltatime float to call functions even less often. This makes the program\
      \ look more complicated, unfortunately, but can decrease the strain on the CPU.\n\
      \n'''EntropicLqd:''' Under those circumstances couldn't you use the SetTimer(..)\
      \ function to reduce the number of times the Timer() function is called?\n\n\
      '''Foxpaw:''' Yes, but you only have one Timer. If a superclass uses it you\
      \ won't be able to use it unless your timing needs are the exact same as those\
      \ of the superclass. Furthermore, you can only use it for one thing then. Say,\
      \ for instance, you wanted to make your own physics system. You wanted to update\
      \ location every tick, velocity every 3 ticks, and rotation every 5 ticks. Furthermore,\
      \ you want to check collision only every 13 ticks. This would be a bit difficult\
      \ to do in Timer.\n\n==Find bottlenecks by measuring execution time==\n\nYou\
      \ can use the Clock and UnClock functions (defined in [[Legacy:Actor|Actor]],\
      \ moved to [[Legacy:Object|Object]] for DeusEx) to measure the time a part of\
      \ your code spends executing, in milliseconds.  Use this to find the sections\
      \ of your code that require performance optimzation most urgently, and to compare\
      \ different ways of doing something performance-wise.\n\n<uscript>\nfunction\
      \ MyFunction()\n{\n    local float ExecutionTime;\n\n    Clock(ExecutionTime);\n\
      \    // do something\n    UnClock(ExecutionTime);\n\n\n    Log(\"Time spent\
      \ executing something:\" @ ExecutionTime @ \"ms\");\n}\n</uscript>\n\nClock\
      \ is a very useful function when you know exactly what you want to measure.\
      \ It is also handy because it returns the elapsed time to you, so you can use\
      \ it to take averages, etc. You could also even use it for some kind of gameplay\
      \ timer, though it sometimes \"rolls over\" which might not make it the best\
      \ for that.\n\nClock uses CPU cycles rather than actual time. In most engines\
      \ the script equivalent of clock\\unclock automatically converts the value to\
      \ seconds rather than CPU cycles. However you should never use clock\\unclock\
      \ for actual timing perposes, only use it for local performance testing (e.g.\
      \ in case you change an algorithm and want to test if it's better or worse).\
      \ CPU cycles roll over very often, thus it's useless for longer periods (a second\
      \ is too much). Because of the over rolling the result after <code>UnClock</code>\
      \ might be incorrect, so when you use it perform the test multiple times to\
      \ get a proper value.\n\nIf you want to test a lot of code, adding a lot of\
      \ clock, unclock, and log statements can be tedious. Enter Stopwatch. Stopwatch\
      \ is a much more powerful function than Clock, but works very differently. The\
      \ stopwatch is global, and it's either \"on\" or \"off.\"\n\nStopWatch( false\
      \ ); starts the stopwatch. StopWatch( true ); disables and resets the timer.\
      \ When you stop the timer, a line will be printed in the log stating something\
      \ like: Time=41.768ms. This is the time that the stopwatch was at when it was\
      \ stopped. This makes it appear to be very much like clock.. but the log statement\
      \ that shows the stop time is not what you can really do with StopWatch.\n\n\
      The magic of stopwatch is that when it is running it timestamps log entries.\
      \ Each is stamped with the time elapsed since the timer was started. It is great\
      \ for finding out the time taken throughout a function, without writing a veritable\
      \ pile of clock and unclock statements, as well as adding temporary variables\
      \ for them, and the works! But I digress. Here's an example:\n\n<uscript>\n\n\
      function SuperFantasticFunction()\n{\n  local int i;\n\n  StopWatch( false );\n\
      \n  log( \"Beginning Execution\" );\n  // ... some code goes here ...\n  log(\
      \ \"Initialization Complete\" );\n  // ... more code ...\n  log( \"Precomputation\
      \ Complete\" );\n  // ... yet more code ...\n  log( \"Entering Loop\" );\n \
      \ for (i=0;i<5;i++)\n  {\n    // .. something done in a loop\n    log( \"Iteration\
      \ \"$(i+1) );\n  }\n\n  log( \"Loop Completed\" );\n  // ... some finishing\
      \ code ...\n  log( \"Function Completed\" );\n\n  StopWatch( true );\n}\n</uscript>\n\
      \nProduces something like the following in the log: (except stopwatch actually\
      \ has a few more digits of precision.)\n\n<uscript>\n  ScriptLog: 0.00 ms: Beginning\
      \ Execution \n  ScriptLog: 0.12 ms: Initialization Complete\n  ScriptLog: 0.45\
      \ ms: Precomputation Complete\n  ScriptLog: 0.76 ms: Entering Loop\n  ScriptLog:\
      \ 1.02 ms: Iteration 1 \n  ScriptLog: 1.35 ms: Iteration 2\n  ScriptLog: 1.68\
      \ ms: Iteration 3\n  ScriptLog: 1.92 ms: Iteration 4\n  ScriptLog: 2.24 ms:\
      \ Iteration 5\n  ScriptLog: 2.24 ms: Loop Completed\n  ScriptLog: 3.16 ms: Function\
      \ Completed\n  Time=3.16 ms\n</uscript>\n\n==Unroll your loops==\n\nSetting\
      \ up a loop can take extra time (especially if Mychaeel is correct and loop\
      \ iterations are counted).  In some cases, the number of iterations are known,\
      \ and a loop doesn't need to be used at all:\n\n<uscript>\nfor (int i = 0; i\
      \ < 5; i++)\n{\n    //Some Code.\n}\n</uscript>\n\ncan be changed to\n\n<uscript>\n\
      //Some Code.\n//Some Code.\n//Some Code.\n//Some Code.\n//Some Code.\n</uscript>\n\
      \n'''Dante:''' What if the engine doesn't count loop iterations but counts every\
      \ instruction ? Then you might save 3 called instructions with the unrolled\
      \ loop. Sometimes it looks very ugly, leaving the for(i=0...5) solution the\
      \ better one.\n\n'''Sordith:''' We could second guess how the scripting engine\
      \ works until we fill up the server's hard drive and not really get anywhere.\
      \  I ''think'' I tested this one (along with all of the techniques I posted),\
      \ but I can't remember the results.  I'll test again later and post some sample\
      \ numbers.  You are correct that sometimes (read most of the time) it looks\
      \ very ugly, and the time saved during execution may not be worth the time lost\
      \ when working with the ugly code.  I didn't mention that because the questions\
      \ of what and when to optimize could easily take it's own page.\n\n==Speed comparison\
      \ of loops==\n\nDifferent loops have different overhead times. Lets say we have\
      \ following situation:\n\n<uscript>\n\t// data, length = 100\n\tvar array<vector>\
      \ stuff;\t\t\t\t\t\t\t\t\n\t\n\t// code to loop\t\t\t\t\t\n\tstuff[i] = vect(1,0,0)*FRand()\
      \ + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\t\n</uscript>\n\nAn obvious choice\
      \ is for loop. Lets say that it takes 1 time unit to execute such function.\
      \ For comparison function with unrolled loop takes 0.66 time units.\n\n<uscript>\n\
      \tfunction Test( int n )\n\t{\n\t\tlocal int i;\n\t\tfor(i=0; i!=n; ++i)\n\t\
      \t{\n\t\t\tstuff[i] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t}\n\t}\n</uscript>\n\nWhile loop takes 0.93 time units. That's probably\
      \ because the i variable is accessed not three but two times in each loop iteration.\n\
      \n<uscript>\n\twhile( i!=n )\n\t{\n\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand()\
      \ + vect(0,0,1)*FRand();\n\t}\n</uscript>\n\nUntil loop takes 0.90 time units.\
      \ Equality operator or internal implementation may be faster.\n\n<uscript>\n\
      \tif( n!=0 )\n\t{\n\t\tdo\n\t\t{\n\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand()\
      \ + vect(0,0,1)*FRand();\n\t\t}until( i==n )\n\t}\n</uscript>\n\nWhat about\
      \ a goto loop? 0.93 time units, same as while loop.\n\n<uscript>\n\tloop:\n\t\
      \tif( i!=n )\n\t\t{\n\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand()\
      \ + vect(0,0,1)*FRand();\n\t\t\tgoto 'loop';\n\t\t}\n</uscript>\n\nThe fastest\
      \ loop I tested was partially unrolled one - 0.76 time units. Choose how many\
      \ times you want to duplicate the code (4-8 will do), loop couple times so the\
      \ number of iterations is a multiply of chosen number and run the duplicated\
      \ code in another loop. \n\n<uscript>\n\tlocal int iterations, modulus;\n\t\n\
      \tif( n != 0 )\n\t{\n\t\tmodulus = n % 8;\n\t\tif( modulus != 0 ) \n\t\t{\n\t\
      \t\tdo\n\t\t\t{\n\t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand()\
      \ + vect(0,0,1)*FRand();\n\t\t\t}\n\t\t\tuntil( --modulus == 0 )\n\t\t}\n\t\t\
      \n\t\titerations = n / 8;\n\t\tif( iterations != 0 )\n\t\t{\n\t\t\tdo\n\t\t\t\
      {\n\t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t\tstuff[i++] = vect(1,0,0)*FRand() + vect(0,1,0)*FRand() + vect(0,0,1)*FRand();\n\
      \t\t\t}\n\t\t\tuntil( --iterations == 0 )\n\t\t}\n\t}\n</uscript>\n\n==Refine\
      \ your algorithms==\n\nDifferent operations take different amounts of time.\
      \  Generally speaking, addition, subtraction, assignment, and shifting take\
      \ small amounts time.  Multiplication takes a slightly longer time, while division\
      \ takes the most time.  Using floating point numbers also increases execution\
      \ time.  Integer multiplication and division by powers of 2 can be converted\
      \ into shifts.  Division by a floating point number can be converted into multiplication\
      \ by a floating point number (x/0.5 == x * (1/0.5)).\n\n'''Sordith:''' Don't\
      \ like the way this one reads, but can't seem to spit it out more clearly.\n\
      \n'''Mychaeel:''' I don't believe UnrealScript's compiler optimizes constant\
      \ subexpressions, so \"1/0.5\" does probably involve a division at run time.\
      \  Also, while you're technically right of course, I don't believe that this\
      \ technique has ''noticable'' impact on the execution speed of UnrealScript\
      \ code &ndash; you have to assume that UnrealScript byte code is executed at\
      \ least one order of magnitude slower than native code, and on top of that every\
      \ operation in an expression translates to a function call with all of its overhead\
      \ anyway (instead of being resolved to an inline operation).\n\n'''Sordith:'''\
      \ This is true.  Optimising outside of a loop will rarely have noticable results.\
      \  These techniques should be used where working with a large number of objects,\
      \ or when doing calculations every frame, and probably not even then unless\
      \ you need the extra time.\n\nI was thinking more along the lines of:\n\n<uscript>\n\
      local float mult = 1/0.5;\nfor (int i = 0; i < 1000; i++)\n{\n    a *= mult;\n\
      \    b *= mult;\n    c *= mult;\n}\n</uscript>\n\nalso, if you want to divide\
      \ by a constant number, you can change it to multiplication by a constant number\
      \ without the overhead of the first division or the temp variable.\n\n==The\
      \ member selection operator has its price==\n\nBy member selection operator\
      \ I mean the dot used to access objects in other objects. Don't forget it's\
      \ also a function and one that may slow down your calculations quite a lot.\
      \ If the objects are constant from the loop point of view, you may cache them\
      \ as mentioned above. You may also try to optimize by using additional calculations\
      \ instead of the member selection operator.\n\nIn following example the member\
      \ selection operator is used 900 times. Let's say that execution of this function\
      \ took 1 time unit.\n\n<uscript>\n\tvar vector stuff[100];\n\t\n\tfunction Test(\
      \ vector v )\n\t{\n\t\tlocal int i;\n\t\tfor(i=0; i<100; ++i)\n\t\t{\t\n\t\t\
      \tstuff[i].x = v.x + v.x*(FRand()-0.5);\n\t\t\tstuff[i].y = v.y + v.y*(FRand()-0.6);\n\
      \t\t\tstuff[i].z = v.x + v.z*(FRand()-0.7);\n\t\t}\t\n\t}\n</uscript>\n\nLet's\
      \ eliminate 600 uses of member selection operator (v members) by adding 3 local\
      \ variables, 3 assignments, and 3 uses of member selection operator. At this\
      \ point it takes 0.6 time units to execute the function.<br />The remaining\
      \ 300 uses of member selection operator (stuff[i] members) can be eliminated\
      \ by adding 300 multiplications by vector and 200 vector additions. After this\
      \ optimization the execution time is 0.39 time units. That's over 2.5 times\
      \ faster than the original example.\n\n<uscript>\n\tfunction Test( vector v\
      \ )\n\t{\n\t\tlocal int i;\n\t\tlocal float vx,vy,vz;\n\t\t\t\n\t\tvx=v.x;\n\
      \t\tvy=v.y;\n\t\tvz=v.z;\n\t\t\n\t\tfor(i=0; i<100; ++i)\n\t\t{\t\n\t\t\tstuff[i]\
      \ = vect(1,0,0) * (vx + vx*(FRand()-0.5))\n\t\t\t\t\t + vect(0,1,0) * (vy +\
      \ vy*(FRand()-0.6))\n\t\t\t\t\t + vect(0,0,1) * (vz + vz*(FRand()-0.7));\n\t\
      \t}\n\t}\n</uscript>\n\n==Be careful with temporary variables==\n\nFirst of\
      \ all, you should remove all unused variables from your functions. (The UT200x\
      \ compiler will warn you about unused local variables.) They slightly increase\
      \ package size and whether they also affect execution speed is yet to be proven.\
      \ They definately make your code harder to read if you have lots of them.\n\n\
      Assignment is a pretty expensive operation in UnrealScript compared to reading\
      \ variable values, especially with structs. If you are working with dynamic\
      \ arrays and want to move an element to a new position with a higher array index\
      \ you might come up with a solution similar to this if you are used to languages\
      \ without dynamic arrays:\n\n<uscript>\nfunction MoveElementUp(int Source, int\
      \ Destination)\n{\n  local int i;\n  local float tmp;\n  \n  tmp = MyArray[Source];\n\
      \  for (i = Source; i < Destination; i++)\n    MyArray[i] = MyArray[i + 1];\n\
      \  MyArray[Destination] = tmp;\n}\n</uscript>\n\nOf source, this is a really\
      \ bad implementation since it completely neglects the features of dynamic arrays.\
      \ (You might have to use it for static arrays, though.)\n\nA way better solution\
      \ would be the following:\n\n<uscript>\nfunction MoveElement(int Source, int\
      \ Destination)\n{\n  local float tmp;\n  \n  tmp = MyArray[Source];\n  MyArray.Remove(Source,\
      \ 1);\n  MyArray.Insert(Destination, 1)\n  MyArray[Destination] = tmp;\n}\n\
      </uscript>\n\nThis implementation not only works for moving in both directions\
      \ (up or down), but also completely drops the loop.\n\nThere's still a temporary\
      \ variable though, which requires an additional assignment operation. Let's\
      \ get rid of that as well:\n\n<uscript>\nfunction MoveElement(int Source, int\
      \ Destination)\n{\n  if ( Source < Destination ) {  // move up\n    MyArray.Insert(Destination\
      \ + 1, 1);\n    MyArray[Destination + 1] = MyArray[Source];\n    MyArray.Remove(Source,\
      \ 1);\n  }\n  else if ( Source > Destination ) { // move down\n    MyArray.Insert(Destination,\
      \ 1);\n    MyArray[Destination] = MyArray[Source + 1];\n    MyArray.Remove(Source\
      \ + 1, 1);\n  }\n}\n</uscript>\n\nIf the destination has a higher index than\
      \ the source, the new element needs to be inserted at an index 1 higher than\
      \ the desired index, because when removing the source element afterwards, all\
      \ following elements' indices are decreased by 1. In the case of moving the\
      \ element down, inserting the destination element increases the source element's\
      \ index by 1.\n\n'''Xian:''' I'll also assume that resetting temporary Object\
      \ pointers to \"None\" will also help. Though I am not too sure about how UE\
      \ handles memory management at such points.\n\n'''Wormbo:''' Like the second\
      \ paragraph in this section mentions: Assignment is a relatively expensive operation.\
      \ Local variables (and thus any object references) cease to exist upon returning\
      \ from the function they are declared in. The UnrealEngine 1 and 2 don't collect\
      \ garbage at all during gameplay, only when the \"Obj Garbage\" console command\
      \ is executed, which in regular gameplay only happens at mapchange and in UT2004\
      \ between Onslaught/Assault rounds. I don't think much was changed in UnrealEngine\
      \ 3, but maybe the garbage collector can run asynchronously now. Anyway, it's\
      \ probably still not worth the additional execution time to explicitly clear\
      \ local object references. If you really have to create a lot of objects dynamically,\
      \ consider using an object pool instead of creating temporary objects every\
      \ time.\n\n==Related Topics==\n* [[Legacy:UnrealScript|UnrealScript]]"
  properties: []
  revId: 34128
name: "Legacy:Code Optimization"
revision:
  revid: 34128
  parentid: 2447
  user: "128.151.80.181"
  timestamp: 1237441317.000000000
  comment: "/* Optimize iterator use */"
timestamp: 1668763284.965515000
