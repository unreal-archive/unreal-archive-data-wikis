---
parse:
  title: "Legacy:Karma Ragdoll Injury System"
  text:
    text: "<p><b>Note to reader:</b> This page represents an incomplete <i>investigation</i>\
      \ into switching players' pawns into and out of ragdoll mode. Some considerable\
      \ mileage was made but the implementation does not work in network play.</p>\n\
      <hr />\n<p>(Note: this text cut from <a href=\"/Legacy:Karma_Ragdoll\" title=\"\
      Legacy:Karma Ragdoll\">Karma Ragdoll</a>. Karma Ragdoll should be definition\
      \ and description. All these ideas deserve their own page).</p>\n<p>This is\
      \ an idea first proposed on the Wiki by Soldat. Essentially, the idea is that\
      \ when a player is damaged by a weapon, they will go into Karma Ragdoll mode\
      \ for a brief period, depending on the severity of the hit, and then get back\
      \ up. So, for instance, a hit from an assault rifle may merely cause you to\
      \ stumble for a split second before regaining control while a direct hit from\
      \ a rocket would send you through the air to end up as a heap on the ground,\
      \ which (if still alive) would then attempt to crawl back up onto its feet.\
      \ Soldat came up with the following function which will activate the Ragdoll\
      \ Physics on a Pawn. It needs to be placed in a subclass of Pawn or called on\
      \ the Pawn externally (it would require some modification to do that, but could\
      \ be modified to work in a mutators' damage modification function):</p>\n<div\
      \ dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">exec</span> <span\
      \ class=\"kw1\">function</span> KarmaMe<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span>\
      \ <span class=\"kw8\">KarmaParamsSkel</span> SkelParams;\n  <span class=\"kw1\"\
      >local</span> <span class=\"kw5\">String</span> RagSkelName;\n \n  RagSkelName\
      \ <span class=\"sy0\">=</span> Species.<span class=\"kw1\">static</span>.<span\
      \ class=\"me0\">GetRagSkelName</span><span class=\"br0\">(</span><span class=\"\
      kw4\">GetMeshName</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span\
      \ class=\"br0\">)</span>;\n  KMakeRagdollAvailable<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;                                    <span class=\"\
      co1\">// allocate a space for the incoming ragdoll</span>\n \n  skelParams <span\
      \ class=\"sy0\">=</span> <span class=\"kw8\">KarmaParamsSkel</span><span class=\"\
      br0\">(</span>KParams<span class=\"br0\">)</span>;                      <span\
      \ class=\"co1\">// create a new skelParams object based off current KParams</span>\n\
      \  skelParams.<span class=\"me0\">KSkeleton</span> <span class=\"sy0\">=</span>\
      \ RagSkelName;                         <span class=\"co1\">// with our new ragdoll</span>\n\
      \  KParams <span class=\"sy0\">=</span> skelParams;                        \
      \               <span class=\"co1\">// and now, voila! KParams is the new skelParams</span>\n\
      \ \n  KSetBlockKarma<span class=\"br0\">(</span><span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span>;                                       <span class=\"\
      co1\">// without this line, I fall THROUGH the floor... gross</span>\n \n  <span\
      \ class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span class=\"\
      kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span>;                \
      \              <span class=\"co1\">// actually create the ragdoll</span>\n<span\
      \ class=\"br0\">}</span></pre></div>\n</div>\n<p>While a neat system, and easy\
      \ enough to get implemented mostly, it has run into a slight problem: neither\
      \ Soldat nor myself (I am also trying to implement this, though slightly differently,\
      \ for my mod) has been able to find a \"perfect\" way to get the player to get\
      \ back up after becoming a ragdoll. I have merged our attempts into a single\
      \ list and described why each did not work quite as planned:</p>\n<p></p>\n\
      <div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n</div>\n\
      <ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking\"\
      ><span class=\"tocnumber\">1</span> <span class=\"toctext\">Removing the Actors\
      \ Skeleton/Resetting the Karma Parameters, and changing Physics back to PHYS_Walking</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-2\"><a href=\"#Freezing_the_Ragdoll\"><span\
      \ class=\"tocnumber\">2</span> <span class=\"toctext\">Freezing the Ragdoll</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-3\"><a href=\"#Spawn_a_New_Pawn_above_the_Ragdoll\"\
      ><span class=\"tocnumber\">3</span> <span class=\"toctext\">Spawn a New Pawn\
      \ above the Ragdoll</span></a></li>\n<li class=\"toclevel-1 tocsection-4\"><a\
      \ href=\"#Animating_a_Ragdoll\"><span class=\"tocnumber\">4</span> <span class=\"\
      toctext\">Animating a Ragdoll</span></a></li>\n<li class=\"toclevel-1 tocsection-5\"\
      ><a href=\"#Discussion\"><span class=\"tocnumber\">5</span> <span class=\"toctext\"\
      >Discussion</span></a></li>\n</ul>\n</div>\n<p></p>\n<h4><span class=\"mw-headline\"\
      \ id=\"Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking\"\
      >Removing the Actors Skeleton/Resetting the Karma Parameters, and changing Physics\
      \ back to PHYS_Walking</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Karma_Ragdoll_Injury_System?section=1\" title=\"\
      Edit section: Removing the Actors Skeleton/Resetting the Karma Parameters, and\
      \ changing Physics back to PHYS Walking\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">exec</span> <span class=\"kw1\">function</span> UnKarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\t\
      <span class=\"kw8\">KarmaParamsSkel</span><span class=\"br0\">(</span>KParams<span\
      \ class=\"br0\">)</span>.<span class=\"me0\">KSkeleton</span> <span class=\"\
      sy0\">=</span> <span class=\"st0\">\"\"</span>;\n \n\t<span class=\"kw4\">SetPhysics</span><span\
      \ class=\"br0\">(</span><span class=\"kw7\">PHYS_Walking</span><span class=\"\
      br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">exec</span>\
      \ <span class=\"kw1\">function</span> UnKarmaMe2<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\tKParams <span class=\"\
      sy0\">=</span> <span class=\"kw1\">default</span>.<span class=\"me0\">KParams</span>;\n\
      \ \n\t<span class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span\
      \ class=\"kw7\">PHYS_Walking</span><span class=\"br0\">)</span>;\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>Though in effect the same thing (Removing\
      \ the Skeleton and Setting the Karma Parameters back to default) it was worth\
      \ trying both. Neither had any effect. When the physics was set back to PHYS_Walking,\
      \ the player fell through the floor and out of the world. This was later found\
      \ to be a result of Karma Ragdoll simulation disabling the regular physics'\
      \ collision in order to use its own. Setting bCollideWorld to true when you\
      \ set the physics back to PHYS_Walking will prevent the player from falling\
      \ through the floor, but it still won't get back up or do anything except look\
      \ around and shoot. (Because its \"state\" hasn't changed in the Pawn class,\
      \ it still thinks it's walking.) However, no animations will play and it will\
      \ not move anywhere.</p>\n<h4><span class=\"mw-headline\" id=\"Freezing_the_Ragdoll\"\
      >Freezing the Ragdoll</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Karma_Ragdoll_Injury_System?section=2\" title=\"\
      Edit section: Freezing the Ragdoll\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h4>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">exec</span> <span class=\"kw1\">function</span> UnKarmaMe3<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\t\
      KFreezeRagdoll<span class=\"br0\">(</span><span class=\"br0\">)</span>;\n \n\
      \t<span class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span class=\"\
      kw7\">PHYS_Walking</span><span class=\"br0\">)</span>;\n<span class=\"br0\"\
      >}</span></pre></div>\n</div>\n<p>This was tried by Soldat and caused the ragdoll\
      \ to freeze. Aside from not falling into the floor, this was no more successful\
      \ than removing the skeleton.</p>\n<h4><span class=\"mw-headline\" id=\"Spawn_a_New_Pawn_above_the_Ragdoll\"\
      >Spawn a New Pawn above the Ragdoll</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Karma_Ragdoll_Injury_System?section=3\"\
      \ title=\"Edit section: Spawn a New Pawn above the Ragdoll\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h4>\n<p>Soldat's initial idea was\
      \ to simply destroy the ragdoll and spawn a new pawn on top of where the ragdoll\
      \ used to be. The problem with this, was that it would telefrag anyone the ragdoll\
      \ fell under. Another problem was that it didn't have a cool animation to show\
      \ the person getting back up.&#160;:P The telefragging was solved with a suggestion\
      \ from Mysterial and expanded by CheshireCat to disable the collision on the\
      \ new pawn until it was no longer touching anyone else, then reenable it. The\
      \ only existing problem with this method is that there is no real smooth way\
      \ of showing the player get back up. As I understand, this is the current method\
      \ that Soldat is experimenting with.</p>\n<h3><span class=\"mw-headline\" id=\"\
      Animating_a_Ragdoll\">Animating a Ragdoll</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Karma_Ragdoll_Injury_System?section=4\"\
      \ title=\"Edit section: Animating a Ragdoll\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>A short study revealed that merely setting the Physics\
      \ to PHYS_KarmaRagdoll with cause serious problems with animation and will prevent\
      \ any animations from being played, even if physics is reset to PHYS_Walking\
      \ immediately after the call to change it to PHYS_KarmaRagdoll. In other words,\
      \ the pawn does not have to spend any time being a ragdoll to cause this effect.\
      \ I am still researching this find out a way to get animations to work after\
      \ returning the physics to normal. Soldat (I believe) is using the last method\
      \ detailed above (making a new pawn to replace the old one) and is trying to\
      \ find a way to make it look like the new pawn is actually the old pawn getting\
      \ up.</p>\n<h2><span class=\"mw-headline\" id=\"Discussion\">Discussion</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Karma_Ragdoll_Injury_System?section=5\" title=\"Edit section:\
      \ Discussion\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p><b>Foxpaw:</b> This page has been mainly refactored from <a href=\"/edit/Legacy:Words_About_Karma_Ragdoll_Deaths?redlink=1\"\
      \ class=\"new\" title=\"Legacy:Words About Karma Ragdoll Deaths (page does not\
      \ exist)\">Words About Karma Ragdoll Deaths</a> along with some stuff I wrote\
      \ myself. Credit for all of the ideas provided has been given to their respective\
      \ authors, I believe. I hope I didn't leave anyone out. By the way, Soldat,\
      \ I had an idea - you may be able to set the person to a crouching idle animation\
      \ and tween to a standing animation, then, you could make it so when the player\
      \ lands flat on the ground, it kicks up a dust cloud or something like that,\
      \ that would obscure the jump from lying down to the crouching position. Let\
      \ me know how that turns out if you try it, I'm going to continue working on\
      \ a way to get the original pawn to move again.</p>\n<p><b>Foxpaw:</b> Eureka!\
      \ I've gotten the thing to animate again after returning from ragdoll mode.\
      \ It wipes out the current position and replaces it with the default but at\
      \ least it doesn't require spawning a new pawn and moving over all of the health,\
      \ etc. from it. All you have to do is change the mesh. So basically, call something\
      \ like the following:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      co1\">// Reenables animations after returning from Karma Ragdoll simulation.\
      \ Requires a global</span>\n<span class=\"co1\">// variable SafeMesh, which\
      \ is a mesh object which we can be guaranteed that this object</span>\n<span\
      \ class=\"co1\">// is not. If we try to do this with the same mesh that we are\
      \ it will not work, therefore,</span>\n<span class=\"co1\">// it is imperative\
      \ that a player never be the mesh stored in safemesh. An alternative</span>\n\
      <span class=\"co1\">// is to have two \"safe meshes\" and check to see if the\
      \ players mesh == the first safemesh,</span>\n<span class=\"co1\">// if so use\
      \ the second safemesh. Otherwise just use the first. This function assumes a</span>\n\
      <span class=\"co1\">// safemesh that is guaranteed to never be what the player\
      \ is set to.</span>\n<span class=\"kw1\">function</span> ReinitializeMesh<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">Mesh</span> OldMesh;\n\
      \ \n  OldMesh <span class=\"sy0\">=</span> <span class=\"kw5\">Mesh</span>;\n\
      \  <span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span> SafeMesh\
      \ <span class=\"br0\">)</span>;\n  <span class=\"kw4\">LinkMesh</span><span\
      \ class=\"br0\">(</span> OldMesh <span class=\"br0\">)</span>;\n \n  <span class=\"\
      kw2\">return</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>I\
      \ also noticed that you must be careful to not engage the ragdoll simulation\
      \ for too short of a time. When ragdoll simulation first begins, your limbs\
      \ are all concentrated in one spot and they spread out until they are in the\
      \ correct position. This takes only a fraction of a second, though it may vary\
      \ on different computers. If you try to use the karma injury system for something\
      \ mild like a glancing blow that just moves you for a split second it will make\
      \ you turn into a ball of limbs instead!</p>\n<p><b>Foxpaw:</b> I noticed a\
      \ small problem, but it may be solveable by a bit of number fudging. The momentum\
      \ imparted by various weapons varies immensely. Assault Rifle and Lightning\
      \ gun are only 1, minigun is 1200, each flak shard is 10000, rockets are 50000,\
      \ shock gun primary 60000, flak grenades 75000, and the shock combo in excess\
      \ of 130000. The problem, here, of course, is if I set it up so that a rocket\
      \ puts him down for 3 seconds, he's out like a light if he gets hit by a shock\
      \ combo. If, however, it's set so that a shock combo merely keeps him out for\
      \ 5 seconds, the minigun/AR/lightning gun do diddly squat. Aside from the fact\
      \ that you have to wait a while for the target to recover, it's pretty fun.\
      \ I did notice a couple of things though: A) your ragdoll assumes you were standing.\
      \ Getting ragdolled while crouching does not produce the same effect. B) Ragdolls\
      \ have a tendancy to \"fall through\" very thin surfaces. (IE A 'grate' over\
      \ a pit of slime) Though cool, the pawn gets stuck when it recovers. This occurs\
      \ with my \"pawns\", regular pawns may act differently.</p>\n<p><b>Chema:</b>\
      \ Great! and... weird!! I had been trying the UnKarma stuff for a few days.\
      \ I also got stuck by the animation. Here is a full (I think) UnKarmaMe(), incluiding\
      \ the double mesh link:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">exec</span> <span class=\"kw1\">function</span> UnKarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\t\
      <span class=\"kw1\">local</span> <span class=\"kw5\">Mesh</span> OldMesh;\n\
      \ \n\t<span class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span\
      \ class=\"kw7\">PHYS_Walking</span><span class=\"br0\">)</span>;\t<span class=\"\
      co1\">// Reset physics</span>\n\tbCollideWorld <span class=\"sy0\">=</span>\
      \ <span class=\"kw6\">true</span>;\t\t<span class=\"co1\">// And world collision</span>\n\
      \t\t\t\t\t\t\t\t<span class=\"co1\">// (KActors use\tKSetBlockKarma for that)</span>\n\
      \t<span class=\"kw4\">SetCollision</span><span class=\"br0\">(</span><span class=\"\
      kw6\">true</span>, <span class=\"kw6\">true</span> , <span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span>; <span class=\"co1\">// Block actors and players again</span>\n\
      \ \n\tOldMesh <span class=\"sy0\">=</span> <span class=\"kw5\">Mesh</span>;\n\
      \t<span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span> SafeMesh <span\
      \ class=\"br0\">)</span>;\t\t<span class=\"co1\">// Global mesh, you will not\
      \ see it</span>\n\t<span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span>\
      \ OldMesh <span class=\"br0\">)</span>;\t\t<span class=\"co1\">// This puts\
      \ your mesh back</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>The doble mesh link is really weird, but works. And it is dificult to find\
      \ what to do whit all those native functions, wich we don't have an idea what\
      \ really do.</p>\n<p>Now, to fix the abrupt standing, we could try an immediate\
      \ crouch, or better, I saw somewhere a function to initialize the mesh anim\
      \ before spawn.</p>\n<p><b>Foxpaw:</b> My pawn comes up in the crouching position.\
      \ It was as simple as adding PlayAnim( 'Crouch' ); after you relink the oldmesh.\
      \ (I'm pretty sure that those parameters are optional. I use a wrapper for animation\
      \ with my \"pawns,\" so my syntax is slightly different.)The real problem is\
      \ not the starting animation, but how to get the starting animation to be something\
      \ very close to what the ragdoll was using, I think. I have had ragdolls get\
      \ their foot caught in tiles on the floor and not end up falling over, just\
      \ kind of going limp - in that instance the standing is better. I've been experimenting\
      \ the the dark magic of manual skeleton rotation - I have a hunch but I'm not\
      \ quite sure how I'll go about it. If you could read the rotation of all of\
      \ the bones, you could manually set them after relinking the mesh and then from\
      \ there tween to an animation. However, obtaining the bones rotation is not\
      \ as simple as calling the GetBoneRotation, as that only returns the rotation\
      \ relative to where the current animation says that it should be. Bones seem\
      \ to use a haphazard mix of absolute and relative locations and rotations, as\
      \ well as even having their own internal coordinate system for each bone! For\
      \ that reason it's a bit confusing. <a href=\"/Legacy:Skeletal_Mesh\" title=\"\
      Legacy:Skeletal Mesh\">Skeletal Mesh</a> has a listing of skeletal animation\
      \ functions and a short description of those that I have experimented with.\
      \ Unforunately, I haven't played with all of the parameters of the functions.\
      \ There's another interesting thing that should be considered, but maybe this\
      \ is only a problem with the juggernaut skeleton that I'm using: The juggernaut\
      \ skeleton has an overwhelming tendancy to fall to its knees, then fall flat\
      \ to its face. This may be because of the limits on the bones though. It generally\
      \ performs this if hit by a \"singular, direct\" type of attack, like a direct\
      \ hit from rocket, shock rifle, etc. Multiple-hit type weapons like flak work\
      \ fine, and if a rocket hits the ground nearby the results are believable. One\
      \ more thing. My pawns don't have this problem because of the way that they\
      \ are scripted, but the built in pawns suffer a set amount of impulse whenever\
      \ they get hit as a ragdoll. It does not use the actual momentum of the gun,\
      \ and I don't think it applies it to the actual bone hit either. The following\
      \ is a slighly modified excerpt from the code I use (the code I use is in an\
      \ else block and has an argument Bone instead of declaring it.)</p>\n<div dir=\"\
      ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\">  <span class=\"kw1\">local</span> <span class=\"kw5\"\
      >float</span> Dummy; <span class=\"co1\">// Just to satisfy an out argument.</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">name</span> Bone;\n\
      \ \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      kw7\">Physics</span> <span class=\"sy0\">==</span> <span class=\"kw7\">PHYS_KarmaRagdoll</span>\
      \ <span class=\"br0\">)</span>\n  <span class=\"br0\">{</span>\n    Bone <span\
      \ class=\"sy0\">=</span> GetClosestBone<span class=\"br0\">(</span> HitLocation,\
      \ <span class=\"kw3\">Normal</span><span class=\"br0\">(</span>Momentum<span\
      \ class=\"br0\">)</span>, Dummy <span class=\"br0\">)</span>;\n    <span class=\"\
      kw4\">KAddImpulse</span><span class=\"br0\">(</span>momentum, hitlocation, Bone<span\
      \ class=\"br0\">)</span>;\n  <span class=\"br0\">}</span>\n \n  <span class=\"\
      co1\">// If you wanted you could collapse this to take up less space you could\
      \ also just do:</span>\n  <span class=\"kw1\">local</span> <span class=\"kw5\"\
      >float</span> Dummy; <span class=\"co1\">// Just to satisfy an out argument.</span>\n\
      \ \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      kw7\">Physics</span> <span class=\"sy0\">==</span> <span class=\"kw7\">PHYS_KarmaRagdoll</span>\
      \ <span class=\"br0\">)</span>\n    <span class=\"kw4\">KAddImpulse</span><span\
      \ class=\"br0\">(</span>momentum, hitlocation, GetClosestBone<span class=\"\
      br0\">(</span> HitLocation, <span class=\"kw3\">Normal</span><span class=\"\
      br0\">(</span>Momentum<span class=\"br0\">)</span>, Dummy <span class=\"br0\"\
      >)</span><span class=\"br0\">)</span>;</pre></div>\n</div>\n<p>I have no idea\
      \ why Digital Extremes used that RagSkelVel and SkelParams.KShotStrength nonsense.\
      \ This looks way more ragdollish and much cooler as it allows for multiple sources\
      \ of force to be acting in rapid succession. IE when you get nailed at close\
      \ range with the flak cannon. (Of course you probrably wouldn't survive anyways\
      \ but maybe if you had lots of shields and health)</p>\n<p><b>Foxpaw:</b> I\
      \ got the getting up part a bit better. Your position on the ground is now recreated\
      \ once the mesh is reset, but only on key bones. So now I'm a running dilapitated\
      \ pile of crumpled up bones.&#160;:P I'll try to find an efficient way to tween\
      \ out the dilapitatedness into normal movement.</p>\n<p><b>Chema:</b> Houston,\
      \ I can get up... but can't crouch!</p>\n<p>Adding PlayAnim( 'Crouch' ); to\
      \ UnKarmaMe doesn't work. Actually, it works normally, but not when I'm Karmed:\
      \ I stand up, but don't crouch. If I call UnKarmaMe again, from console, then\
      \ it works. Simply put: I can't animate the mesh in the same call that UnKarmaMe,\
      \ no matter if I put in a different function.</p>\n<p>Any idea whats wrong with\
      \ me? And with my code? (hehe). Are you doing anything special apart of the\
      \ stuff in the previous UnKarmaMe()? I'm setting my TestxPawn trough the URL\
      \ (dm-gael?Game=Test.TestGame?Class=Test.TestxPawn), but there should be a scripted\
      \ way to do it for a game. An equivalent of the CheckReplacement of the Mutators?\
      \ (Thanks for all your help!)</p>\n<p><b>Foxpaw:</b> It may be that the animation\
      \ won't play on the same call. As you may have noticed, (maybe, it's kind of\
      \ hard to see.) For a short time after becoming a ragdoll you are just a ball\
      \ of concentrated body parts. It is possible that your ragdollness persists\
      \ until the next tick. Or something. The 'personnell' on my mod are completely\
      \ custom - I've written my own classes for everything below actor, because Pawns\
      \ have lots of built in junk.&#160;:P It has an attached \"Mesh Controller\"\
      \ which monitors animation, etc. and would play the idling animation the next\
      \ opportunity it got... so if it cannot indeed be called from the same function\
      \ it would try again the next tick. That may be why mine goes back to the idling\
      \ animation while yours requires a second call. I believe that you can use checkreplacement\
      \ in mutators to replace your xpawn with the one you have made.. I haven't tested\
      \ it but I believe that you can because I think that checkreplacement is called\
      \ from within spawn, before the controller would make its Possess call, which\
      \ I believe does not occur until after the spawn has returned. I haven't tested\
      \ that part out, the order that the controller stuff goes in because I just\
      \ wrap the controller class, so I don't really use it for anything.</p>\n<p><b>Foxpaw:</b>\
      \ I noticed another thing, but it might not be a big deal for your application.\
      \ If you really clobber a ragdoll sometimes it will suffer a simerror as a result\
      \ of its joints being spun so fast. This will, by default, result in it being\
      \ destroyed - definately a bad thing if the player was merely injured! You can\
      \ set bDestroyOnSimError in its KParams to prevent this, but it doesn't protect\
      \ against everything. bKImportantRagdoll (maybe doesn't have a K, I don't remember\
      \ for sure) might also be good because it prevents the ragdoll from being destroyed\
      \ if the system runs low on memory and wants to make a new ragdoll. The simerror\
      \ thing may not apply in your application, because generally that will only\
      \ result from things such as flak to the head at point blank or similar events,\
      \ which would kill the pawn anyway. It might also be worth investigating what\
      \ effects mutators that affect the ragdolls will have. I'm not sure about Floaty\
      \ Cadavers, but I know that Slow Motion Corpses works by slowing down the entire\
      \ Karma Ragdoll simulation system. This would slow down injured players as well.\
      \ I don't know if that's a problem or not, but it's worth checking out.</p>\n\
      <p><b>OBWANDO:</b> I took a few hours fighting with this, and it wouldnt work\
      \ at all in any way. Heres what I found... If you want to get the pawns to go\
      \ back to their original animated mesh, you need to link with another VALID\
      \ different mesh. If you try to link with a null or non-specified mesh, it will\
      \ simply not link at all which then you will wind up linking the original named\
      \ mesh and that does absolutely nothing. In the end heres what seemed to work\
      \ for me:</p>\n<p>In my pawn class (RBxPawn.uc):</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">var</span>\t<span class=\"br0\">(</span>Global<span\
      \ class=\"br0\">)</span> <span class=\"kw5\">mesh</span> SafeMesh;\n \n<span\
      \ class=\"kw1\">exec</span> <span class=\"kw1\">function</span> KarmaMe<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw8\">KarmaParamsSkel</span>\
      \ SkelParams;\n  <span class=\"kw1\">local</span> <span class=\"kw5\">String</span>\
      \ RagSkelName;\n \n  SafeMesh <span class=\"sy0\">=</span> <span class=\"kw5\"\
      >Mesh</span>;                                            <span class=\"co1\"\
      >// This is where I am getting the pawn's original mesh</span>\n  RagSkelName\
      \ <span class=\"sy0\">=</span> Species.<span class=\"kw1\">static</span>.<span\
      \ class=\"me0\">GetRagSkelName</span><span class=\"br0\">(</span><span class=\"\
      kw4\">GetMeshName</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span\
      \ class=\"br0\">)</span>;\n  KMakeRagdollAvailable<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;                                    <span class=\"\
      co1\">// allocate a space for the incoming ragdoll</span>\n \n  skelParams <span\
      \ class=\"sy0\">=</span> <span class=\"kw8\">KarmaParamsSkel</span><span class=\"\
      br0\">(</span>KParams<span class=\"br0\">)</span>;                      <span\
      \ class=\"co1\">// create a new skelParams object based off current KParams</span>\n\
      \  skelParams.<span class=\"me0\">KSkeleton</span> <span class=\"sy0\">=</span>\
      \ RagSkelName;                         <span class=\"co1\">// with our new ragdoll</span>\n\
      \  KParams <span class=\"sy0\">=</span> skelParams;                        \
      \               <span class=\"co1\">// and now, voila! KParams is the new skelParams</span>\n\
      \ \n  KSetBlockKarma<span class=\"br0\">(</span><span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span>;                                        <span class=\"\
      co1\">// without this line, I fall THROUGH the floor... gross</span>\n \n  <span\
      \ class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span class=\"\
      kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span>;                \
      \              <span class=\"co1\">// actually create the ragdoll</span>\n<span\
      \ class=\"br0\">}</span>\n \n<span class=\"kw1\">exec</span> <span class=\"\
      kw1\">function</span> UnKarmaMe<span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw8\">KarmaParamsSkel</span><span\
      \ class=\"br0\">(</span>KParams<span class=\"br0\">)</span>.<span class=\"me0\"\
      >KSkeleton</span> <span class=\"sy0\">=</span> <span class=\"st0\">\"\"</span>;\n\
      \ \n  <span class=\"kw4\">SetPhysics</span><span class=\"br0\">(</span><span\
      \ class=\"kw7\">PHYS_Walking</span><span class=\"br0\">)</span>;        <span\
      \ class=\"co1\">// Reset physics</span>\n  bCollideWorld <span class=\"sy0\"\
      >=</span> <span class=\"kw6\">true</span>;            <span class=\"co1\">//\
      \ And world collision</span>\n                                         <span\
      \ class=\"co1\">// (KActors use KSetBlockKarma for that)</span>\n  <span class=\"\
      kw4\">SetCollision</span><span class=\"br0\">(</span><span class=\"kw6\">true</span>,\
      \ <span class=\"kw6\">true</span> , <span class=\"kw6\">true</span><span class=\"\
      br0\">)</span>; <span class=\"co1\">// Block actors and players again</span>\n\
      \ \n  <span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span> <span\
      \ class=\"kw5\">SkeletalMesh</span><span class=\"st0\">'Weapons.AssaultRifle_1st'</span>\
      \ <span class=\"br0\">)</span>;  <span class=\"co1\">// I am using a valid mesh\
      \ which is not the same as the pawn's original mesh</span>\n               \
      \                    <span class=\"co1\">// You should probably use a precached\
      \ mesh for performance reasons, the gun seemed good here</span>\n  <span class=\"\
      kw4\">LinkMesh</span><span class=\"br0\">(</span> SafeMesh <span class=\"br0\"\
      >)</span>;\t         <span class=\"co1\">// Link the pawn's original mesh and\
      \ we're done!</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p><b>Foxpaw:</b>\
      \ I believe that is the same as what I wrote above. SafeMesh DOES need to be\
      \ defined as a mesh, I guess I should have explicitly stated that. The OldMesh\
      \ is the mesh that we want to return to and is read in the unkarmatize function\
      \ on my \"livingthing\" class. (This is the \"livingthing\" equivalent of the\
      \ unkarmame function.) I could have sworn we discussed the idea of using two\
      \ safemeshes in case, for whatever reason, the pawn was using one of those meshes,\
      \ I don't see that anywhere on this page though so maybe I just imagined it.&#160;:P\
      \ Should we remove the failed attempts listed above or leave them so others\
      \ can learn that those methods don't work and why the didn't work?</p>\n<p><b>OBWANDO:</b>\
      \ I would say leave it in place, it shows the evolution of the learning curve\
      \ to a final conclusion. You did mention (or i assumed) that there were 2 safemeshes,\
      \ but I did not know that 1 had to be explicitly defined, and that was what\
      \ threw me, and could others. I wouldn't have made it this far without everything\
      \ being available to read.</p>\n<p><b>Foxpaw:</b> Okay. Both safemeshes would\
      \ actually need to be defined, but you can usually get away with using just\
      \ one, depending on the application. In this instance it's highly unlikely that\
      \ a pawn would have a first person weapon mesh as their mesh so you could get\
      \ away with the way you did it.</p>\n<p><b>Foxpaw:</b> I've noticed one small\
      \ issue but it's not that big of a deal. If you rotate bones using Unrealscript,\
      \ the karma ragdoll is not rotated appropriately. The visual representation\
      \ of it is, but the actual collision/simulation information remains unchanged.\
      \ That's probrably not a big issue, I've been experimenting with rotating bones\
      \ to have the player \"get back up\" from whatever position they ended up in.\
      \ In this instance, the simulation can be slightly innaccurate if you are hit\
      \ again while getting up.</p>\n<p><b>Foxpaw:</b> I almost forgot - there's a\
      \ big problem with this code, but it might not be that hard to work around.\
      \ There's a limit on the number of ragdolls that you can have in play at any\
      \ time. I believe it may be per zone, however. The limit appears to be rather\
      \ low, unfortunately, approximately 3 ragdolls per zone. If you had two carcasses\
      \ and two injured players, one would be denied a ragdoll and would just stand\
      \ still. You could work around this by using the IsRagdollAvailible, and if\
      \ one is not the player could just play some other injury animation and be simulated\
      \ using regular physics.</p>\n<p><b>OBWANDO:</b> I agree, I listed a piece of\
      \ simple code to get the idea, but to prevent the problems from occuring here\
      \ is a small snip that you could use as well to combat the problems of unavailability.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">exec</span> <span\
      \ class=\"kw1\">function</span> KarmaMe<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span>\
      \ <span class=\"kw8\">KarmaParamsSkel</span> SkelParams;\n  <span class=\"kw1\"\
      >local</span> <span class=\"kw5\">String</span> RagSkelName;\n \n  SafeMesh\
      \ <span class=\"sy0\">=</span> <span class=\"kw5\">Mesh</span>;            \
      \                                <span class=\"co1\">// This is where I am getting\
      \ the pawn's original mesh</span>\n \n  <span class=\"kw2\">if</span><span class=\"\
      br0\">(</span> RagdollOverride <span class=\"sy0\">!=</span> <span class=\"\
      st0\">\"\"</span><span class=\"br0\">)</span>                              \
      \    <span class=\"co1\">// Try to get the rag-doll setup.</span>\n  \tRagSkelName\
      \ <span class=\"sy0\">=</span> RagdollOverride;                        <span\
      \ class=\"co1\">// If there is an override, use it first</span>\n  <span class=\"\
      kw2\">else</span> <span class=\"kw2\">if</span><span class=\"br0\">(</span>Species\
      \ <span class=\"sy0\">!=</span> <span class=\"kw5\">None</span><span class=\"\
      br0\">)</span>                                    <span class=\"co1\">// if\
      \ not, use species.</span>\n  \tRagSkelName <span class=\"sy0\">=</span> Species.<span\
      \ class=\"kw1\">static</span>.<span class=\"me0\">GetRagSkelName</span><span\
      \ class=\"br0\">(</span> <span class=\"kw4\">GetMeshName</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">)</span>;\n \n\
      \  <span class=\"kw2\">if</span><span class=\"br0\">(</span> RagSkelName <span\
      \ class=\"sy0\">!=</span> <span class=\"st0\">\"\"</span> <span class=\"br0\"\
      >)</span>                                         <span class=\"co1\">// If\
      \ we did find one, try to allocate the space.</span>\n  <span class=\"br0\"\
      >{</span>\n  \tKMakeRagdollAvailable<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>;                                  <span class=\"co1\">// allocate\
      \ a space for the incoming ragdoll</span>\n  <span class=\"br0\">}</span>\n\
      \ \n  <span class=\"kw2\">if</span><span class=\"br0\">(</span> KIsRagdollAvailable<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span>\
      \ RagSkelName <span class=\"sy0\">!=</span> <span class=\"st0\">\"\"</span>\
      \ <span class=\"br0\">)</span>\n  <span class=\"br0\">{</span>  \n    skelParams\
      \ <span class=\"sy0\">=</span> <span class=\"kw8\">KarmaParamsSkel</span><span\
      \ class=\"br0\">(</span>KParams<span class=\"br0\">)</span>;               \
      \     <span class=\"co1\">// create a new skelParams object based off current\
      \ KParams</span>\n    skelParams.<span class=\"me0\">KSkeleton</span> <span\
      \ class=\"sy0\">=</span> RagSkelName;                       <span class=\"co1\"\
      >// with our new ragdoll</span>\n    KParams <span class=\"sy0\">=</span> skelParams;\
      \                                     <span class=\"co1\">// and now, voila!\
      \ KParams is the new skelParams</span>\n \n    KSetBlockKarma<span class=\"\
      br0\">(</span><span class=\"kw6\">true</span><span class=\"br0\">)</span>; \
      \                                    <span class=\"co1\">// without this line,\
      \ I fall THROUGH the floor... gross</span>\n \n    <span class=\"kw4\">SetPhysics</span><span\
      \ class=\"br0\">(</span><span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"\
      br0\">)</span>;                            <span class=\"co1\">// actually create\
      \ the ragdoll</span>\n  <span class=\"br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p><b>OBWANDO:</b> One thing I have noticed that that you can crash\
      \ the client pretty easily if you try to do this in a dedicated network mode.\
      \ On a local client there are no problems, but from what I have seen, a dedicated\
      \ server will not allow the physics to change to ragdoll, so your client will\
      \ show a ragdoll, but your server will still show the last known physics mode\
      \ (like PHYS_Walking, or PHYS_Falling). Maybe we should look at starting a thread\
      \ or page on network implementation.</p>\n<p><b>Foxpaw:</b> I don't understand\
      \ what you mean by that.. how do you mean the server will \"show\" the last\
      \ known physics mode, if it is a dedicated server? The server/client problem\
      \ you are having is likely due to the KarmaMe function not being replicated..\
      \ or something like that. I haven't tested mine over network yet but it is set\
      \ to be triggered when hit, if the imparted momentum is over a certain threshold.\
      \ I am not sure how the autonomous proxy treats exec functions so the problem\
      \ could be with that. If you want to ensure that the ragdolling is consistant\
      \ on both client and server you could have a boolean variable that is replicated\
      \ reliably from server to client, and a check in tick - if the variable is true\
      \ and we are not in PHYS_KarmaRagdoll, then call the KarmaMe function, if the\
      \ variable is false and we are in PHYS_KarmaRagdoll, then call the UnKarmaMe\
      \ function. This, of course, would require those functions split into two pieces\
      \ because you wouldn't want to call an exec function and have the cause the\
      \ server to request that same function to be called on the client, which would\
      \ then cause the server to request that same function to be called on the client\
      \ again, etc. Enough talk!&#160;:P The implementation could be something like\
      \ this: (I didn't actually compile and test this, there could be typos. It would\
      \ also maybe need some tweaking to allow for running out of ragdolls. You could\
      \ use a timer or whatever you want for unkarmame. I use a manually implemented\
      \ timer in tick.)</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">var</span> <span class=\"kw5\">bool</span> bIsRagdolling;\n<span class=\"\
      kw1\">var</span> <span class=\"kw5\">float</span> RagdollThreshold;\n \n<span\
      \ class=\"kw1\">replication</span>\n<span class=\"br0\">{</span>\n  <span class=\"\
      kw1\">reliable</span> <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"kw7\">ROLE</span><span class=\"sy0\">==</span><span class=\"\
      kw7\">ROLE_Authority</span> <span class=\"br0\">)</span>\n    bIsRagdolling;\n\
      <span class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span\
      \ class=\"kw1\">function</span> <span class=\"kw4\">TakeDamage</span><span class=\"\
      br0\">(</span><span class=\"kw5\">int</span> Damage, <span class=\"kw9\">Pawn</span>\
      \ <span class=\"kw7\">Instigator</span>, <span class=\"kw5\">Vector</span> HitLocation,\
      \ <span class=\"kw5\">Vector</span> Momentum, class<span class=\"sy0\">&lt;</span>DamageType<span\
      \ class=\"sy0\">&gt;</span> <span class=\"kw9\">DamageType</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw6\">Super</span>.<span\
      \ class=\"kw4\">TakeDamage</span><span class=\"br0\">(</span>Damage, <span class=\"\
      kw7\">Instigator</span>, HitLocation, Momentum, <span class=\"kw9\">DamageType</span><span\
      \ class=\"br0\">)</span>;\n  <span class=\"kw2\">if</span> <span class=\"br0\"\
      >(</span><span class=\"kw7\">Role</span> <span class=\"sy0\">==</span> <span\
      \ class=\"kw7\">ROLE_Authority</span> <span class=\"sy0\">&amp;&amp;</span>\
      \ <span class=\"kw3\">VSize</span><span class=\"br0\">(</span>Momentum<span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&gt;</span> RagdollThreshold<span\
      \ class=\"br0\">)</span>\n    bIsRagdolling <span class=\"sy0\">=</span> <span\
      \ class=\"kw6\">true</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"\
      kw1\">simulated</span> <span class=\"kw1\">function</span> <span class=\"kw4\"\
      >Tick</span><span class=\"br0\">(</span><span class=\"kw5\">float</span> DeltaTime<span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw6\"\
      >Super</span>.<span class=\"kw4\">Tick</span><span class=\"br0\">(</span>DeltaTime<span\
      \ class=\"br0\">)</span>;\n \n  <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span><span class=\"kw7\">Role</span> <span class=\"sy0\">&lt;</span>\
      \ <span class=\"kw7\">ROLE_Authority</span><span class=\"br0\">)</span>\n  \
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>bIsRagdolling <span\
      \ class=\"sy0\">&amp;&amp;</span> <span class=\"kw7\">Physics</span> <span class=\"\
      sy0\">!=</span> <span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\"\
      >)</span>\n      KarmaMe<span class=\"br0\">(</span><span class=\"br0\">)</span>;\n\
      \    <span class=\"kw2\">else</span> <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span><span class=\"sy0\">!</span>bIsRagdolling <span class=\"sy0\"\
      >&amp;&amp;</span> <span class=\"kw7\">Physics</span> <span class=\"sy0\">==</span>\
      \ <span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span>\n\
      \      UnKarmaMe<span class=\"br0\">(</span><span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span>\n \n \n<span class=\"kw1\">simulated</span> <span\
      \ class=\"kw1\">function</span> KarmaMe<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"co1\">// Do your\
      \ karmame stuff here.</span>\n<span class=\"br0\">}</span>\n \n<span class=\"\
      kw1\">simulated</span> <span class=\"kw1\">function</span> UnKarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n \
      \ <span class=\"co1\">// Do your unkarmame stuff here.</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p><b>OBWANDO:</b> Heres what I've seen.\
      \ In most of the Epic code, you will see that they have the karma sequences\
      \ set up so that the server's pawn doesnt actually get its physics set into\
      \ KarmaRagdoll mode (Level.NetMode&#160;!= NM_DedicatedServer). Only the client\
      \ does. Now this may seem simple in theory, but the reality is that if you touch\
      \ a floor surface, or its a bot (or a player) that jumps then the physics on\
      \ the server will change and as a result the physics from the server will be\
      \ replicated as part of the normal parent class replication to that physics\
      \ mode. Thats where the problems begin since on the client you are in KarmaRagdoll,\
      \ and the server replicates a PHYS_Walking, or whatever, but its not Ragdoll,\
      \ so the client crashes since you cannot have a walking pawn that is in PHYS_KarmaRagdoll.\
      \ This means you have to address the problem to prevent the client from getting\
      \ the physics change unless you have restored the physics and mesh back and\
      \ are ready for that PHYS mode.</p>\n<p><b>Foxpaw:</b> Ah, yes. The ragdolls\
      \ aren't simulated on the server usually because that just wastes resources.\
      \ They are \"torn off\" when they are created, so they cease to replicate. I\
      \ think that the implementation I listed above should work.. I hope. I haven't\
      \ tested that or played around with it, I don't really know all of the nuances\
      \ of the pawn class since I don't use it for anything, but it seems logical.</p>\n\
      <p><b>Foxpaw:</b> Apparently, the limit placed on ragdolls is optional. If you\
      \ just remove the MakeRagdollAvailible part and the IsRagdollAvailible check,\
      \ you can apparently make as many ragdolls as you want. Finally, my battlefields\
      \ can have carcasses littered all around, instead of that stupid de-res thing.&#160;:P</p>\n\
      <p><b>PlaneGuy:</b> I tried the MP ragdoll code above, but it still crashes.\
      \ I was thinking if being ragdolled is a state, you can set the pawn to ignore\
      \ any non-ragdoll/karma related action in that state. Thoughts?</p>\n<p><b>OBWANDO:</b>\
      \ Here is the code I created that successfully works. I used a manual timer\
      \ since the SetTimer was too flaky for me. The server first of all is the only\
      \ one that will REALLY know what mode our client is supposed to be in. When\
      \ we are ragdolling, we should probably prevent the bots from moving the ragdoll,\
      \ or when we come back out, the client will show the pawn pretty far away from\
      \ where it should have been. and most importantly, we need to make sure the\
      \ client does not try to change the physics via update from the server.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">var</span> <span\
      \ class=\"kw5\">bool</span> bKarma; <span class=\"co1\">// server paramater\
      \ to client if you need to be set to karma mode</span>\n<span class=\"kw1\"\
      >var</span> <span class=\"kw5\">bool</span> bInKarma; <span class=\"co1\">//\
      \ server parameter letting the client know to override any physics changes to\
      \ karma.</span>\n<span class=\"kw1\">var</span> <span class=\"kw5\">bool</span>\
      \ bTickMe; <span class=\"co1\">// my tick timer boolean</span>\n<span class=\"\
      kw1\">var</span> <span class=\"kw5\">bool</span> bClKarma; <span class=\"co1\"\
      >// the client flag that lets us know that the client is indeed in karma mode.\
      \ (remember Physics will be changed from replication)</span>\n<span class=\"\
      kw1\">var</span> <span class=\"kw5\">int</span>\tiTickTime; <span class=\"co1\"\
      >// a timer counter since SetTimer was too flaky to use over network.</span>\n\
      \ \n<span class=\"kw1\">replication</span>\n<span class=\"br0\">{</span>\n\t\
      <span class=\"kw1\">reliable</span> <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span><span class=\"kw7\">Role</span> <span class=\"sy0\">==</span>\
      \ <span class=\"kw7\">ROLE_Authority</span> <span class=\"br0\">)</span>\n\t\
      \tbKarma, bInKarma;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span>\
      \ <span class=\"kw1\">event</span> <span class=\"kw4\">PostNetReceive</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \t<span class=\"kw2\">if</span> <span class=\"br0\">(</span> PlayerReplicationInfo\
      \ <span class=\"sy0\">!=</span> <span class=\"kw5\">None</span> <span class=\"\
      br0\">)</span>\n    <span class=\"br0\">{</span>\n\t\tSetup<span class=\"br0\"\
      >(</span><span class=\"kw1\">class</span><span class=\"st0\">'xUtil'</span>.<span\
      \ class=\"kw1\">static</span>.<span class=\"me0\">FindPlayerRecord</span><span\
      \ class=\"br0\">(</span>PlayerReplicationInfo.<span class=\"me0\">CharacterName</span><span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>;\n\t\t<span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> AmbientGlow <span class=\"sy0\">==</span>\
      \ <span class=\"nu0\">70</span> <span class=\"br0\">)</span>\n\t\t\tAmbientGlow\
      \ <span class=\"sy0\">=</span> <span class=\"kw1\">Default</span>.<span class=\"\
      me0\">AmbientGlow</span>;\n        <span class=\"co1\">//bNetNotify = false;</span>\n\
      \    <span class=\"br0\">}</span>\n \n\t<span class=\"kw2\">if</span> <span\
      \ class=\"br0\">(</span> <span class=\"br0\">(</span>bInKarma <span class=\"\
      sy0\">==</span> <span class=\"kw6\">false</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span>bKarma <span\
      \ class=\"sy0\">==</span> <span class=\"kw6\">false</span><span class=\"br0\"\
      >)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span><span\
      \ class=\"kw7\">Physics</span> <span class=\"sy0\">==</span> <span class=\"\
      kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span> <span class=\"br0\"\
      >)</span> UnKarmaMe<span class=\"br0\">(</span><span class=\"br0\">)</span>;\
      \ <span class=\"co1\">// ok release karma mode go back to a pawn</span>\n \n\
      <span class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span\
      \ class=\"kw1\">function</span> <span class=\"kw4\">Tick</span><span class=\"\
      br0\">(</span><span class=\"kw5\">float</span> DeltaTime<span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n    <span class=\"kw2\">if</span> <span\
      \ class=\"br0\">(</span><span class=\"kw7\">Role</span> <span class=\"sy0\"\
      >==</span> <span class=\"kw7\">ROLE_Authority</span> <span class=\"br0\">)</span>\
      \ <span class=\"br0\">{</span>\n\t<span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span>bTickMe<span class=\"br0\">)</span> <span class=\"br0\">{</span>\n\
      \t\tiTickTime<span class=\"sy0\">--</span>;\n\t\t<span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span>iTickTime <span class=\"sy0\">&lt;</span> <span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span>\n\
      \t\t\tbTickMe <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n\
      \t\t\tUnKarmaMe<span class=\"br0\">(</span><span class=\"br0\">)</span>;\n\t\
      \t<span class=\"br0\">}</span>\n\t<span class=\"br0\">}</span>\n    <span class=\"\
      br0\">}</span>\n \n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"br0\">(</span>bInKarma <span class=\"sy0\">&amp;&amp;</span>\
      \ <span class=\"sy0\">!</span>bTearOff<span class=\"br0\">)</span> <span class=\"\
      br0\">)</span> <span class=\"co1\">// if we're in karma, but not dead, prevent\
      \ player induced motion from occuring.</span>\n    <span class=\"br0\">{</span>\n\
      \t<span class=\"kw7\">Acceleration</span> <span class=\"sy0\">=</span> <span\
      \ class=\"kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span>;\n\
      \t<span class=\"kw7\">Velocity</span> <span class=\"sy0\">=</span> <span class=\"\
      kw3\">vect</span><span class=\"br0\">(</span><span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"br0\">)</span>;\n\
      \    <span class=\"br0\">}</span>\n    <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> <span class=\"br0\">(</span><span class=\"kw7\">Physics</span>\
      \ <span class=\"sy0\">!=</span> <span class=\"kw7\">PHYS_KarmaRagdoll</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span>bKarma <span class=\"sy0\">==</span> <span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span>bInKarma <span class=\"sy0\">==</span> <span class=\"kw6\">false</span><span\
      \ class=\"br0\">)</span> <span class=\"br0\">)</span> KarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>; <span class=\"co1\">//set the Ragdoll\
      \ Mode</span>\n \n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"kw7\">Level</span>.<span class=\"me0\">NetMode</span> <span\
      \ class=\"sy0\">==</span> NM_DedicatedServer <span class=\"br0\">)</span>\n\
      \  \t\t<span class=\"kw2\">return</span>;\n  <span class=\"co1\">//****** ONLY\
      \ LOCAL AND CLIENT STUFF BELOW HERE</span>\n \n    <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> <span class=\"br0\">(</span><span class=\"kw7\"\
      >Physics</span> <span class=\"sy0\">!=</span> <span class=\"kw7\">PHYS_KarmaRagdoll</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span>bClKarma <span class=\"sy0\">==</span> <span class=\"kw6\">false</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span>bInKarma <span class=\"sy0\">==</span> <span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span> <span class=\"br0\">)</span> KarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>; <span class=\"co1\">//Seems replication\
      \ isnt perfect, so lets make sure</span>\n \n    <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> <span class=\"kw9\">Controller</span> <span class=\"\
      sy0\">!=</span> <span class=\"kw5\">None</span> <span class=\"br0\">)</span>\
      \ OldController <span class=\"sy0\">=</span> <span class=\"kw9\">Controller</span>;\n\
      \ \n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      br0\">(</span>bInKarma <span class=\"sy0\">==</span> <span class=\"kw6\">true</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span>bKarma <span class=\"sy0\">==</span> <span class=\"kw6\">false</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      br0\">(</span><span class=\"kw7\">Physics</span> <span class=\"sy0\">!=</span>\
      \ <span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span> <span\
      \ class=\"br0\">)</span> <span class=\"kw4\">SetPhysics</span><span class=\"\
      br0\">(</span><span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\"\
      >)</span>; <span class=\"co1\">// Enforce Ragdoll on clients</span>\n \n   \
      \ TickFX<span class=\"br0\">(</span>DeltaTime<span class=\"br0\">)</span>;\n\
      \ \n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span> bDeRes <span\
      \ class=\"br0\">)</span>\n    <span class=\"br0\">{</span>\n        TickDeRes<span\
      \ class=\"br0\">(</span>DeltaTime<span class=\"br0\">)</span>;\n    <span class=\"\
      br0\">}</span>\n    <span class=\"co1\">// assume dead if bTearOff - for remote\
      \ clients unfff unfff</span>\n    <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> bTearOff <span class=\"br0\">)</span>\n    <span class=\"br0\"\
      >{</span>\n        <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"sy0\">!</span>bPlayedDeath <span class=\"br0\">)</span>\n  \
      \          PlayDying<span class=\"br0\">(</span>HitDamageType, TakeHitLocation<span\
      \ class=\"br0\">)</span>;\n        <span class=\"kw2\">return</span>;\n    <span\
      \ class=\"br0\">}</span>\n \n<span class=\"br0\">}</span>\n \n<span class=\"\
      kw1\">simulated</span> <span class=\"kw1\">function</span> UnKarmaMe<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\t\
      <span class=\"kw2\">if</span> <span class=\"br0\">(</span><span class=\"kw7\"\
      >ROLE</span> <span class=\"sy0\">!=</span> <span class=\"kw7\">Role_Authority</span><span\
      \ class=\"br0\">)</span> <span class=\"br0\">{</span>\n \n\t\t<span class=\"\
      kw8\">KarmaParamsSkel</span><span class=\"br0\">(</span>KParams<span class=\"\
      br0\">)</span>.<span class=\"me0\">KSkeleton</span> <span class=\"sy0\">=</span>\
      \ <span class=\"st0\">\"\"</span>;\n\t\t<span class=\"kw4\">SetPhysics</span><span\
      \ class=\"br0\">(</span><span class=\"kw7\">PHYS_Falling</span><span class=\"\
      br0\">)</span>;   <span class=\"co1\">// Reset physics</span>\n\t\tbCollideWorld\
      \ <span class=\"sy0\">=</span> <span class=\"kw6\">true</span>;       <span\
      \ class=\"co1\">// And world collision</span>\n\t\t\t\t\t\t\t\t\t<span class=\"\
      co1\">// (KActors use KSetBlockKarma for that)</span>\n\t\t<span class=\"kw4\"\
      >SetCollision</span><span class=\"br0\">(</span><span class=\"kw6\">true</span>,\
      \ <span class=\"kw6\">true</span> , <span class=\"kw6\">true</span><span class=\"\
      br0\">)</span>; <span class=\"co1\">// Block actors and players again</span>\n\
      \ \n\t\t<span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span> <span\
      \ class=\"kw5\">SkeletalMesh</span><span class=\"st0\">'Weapons.AssaultRifle_1st'</span>\
      \ <span class=\"br0\">)</span>;\n\t\t<span class=\"kw4\">LinkMesh</span><span\
      \ class=\"br0\">(</span> SafeMesh <span class=\"br0\">)</span>;\n\t\tbClKarma\
      \ <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n\t<span class=\"\
      br0\">}</span> \n \n\t<span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"kw7\">Role</span> <span class=\"sy0\">==</span> <span class=\"\
      kw7\">ROLE_Authority</span> <span class=\"br0\">)</span> <span class=\"br0\"\
      >{</span> <span class=\"co1\">//servers set the parameters</span>\n \n\t\tbKarma\
      \ <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n\t\tbInKarma\
      \ <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n\t<span class=\"\
      br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>In your\
      \ KarmaMe() routine, add this to your karma code:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\">\t<span class=\"kw2\">if</span> <span class=\"br0\">(</span><span\
      \ class=\"kw7\">ROLE</span> <span class=\"sy0\">==</span> <span class=\"kw7\"\
      >Role_Authority</span><span class=\"br0\">)</span> \n\t<span class=\"br0\">{</span>\n\
      \t\tbKarma <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n\t\
      \tbInKarma <span class=\"sy0\">=</span> <span class=\"kw6\">true</span>;\n\t\
      <span class=\"br0\">}</span>\n\t<span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> <span class=\"kw7\">Level</span>.<span class=\"me0\">NetMode</span>\
      \ <span class=\"sy0\">!=</span> NM_DedicatedServer <span class=\"br0\">)</span>\n\
      \t<span class=\"br0\">}</span>\n \n... <span class=\"me0\">karma</span> code\
      \ etc...\n \n\t     <span class=\"kw4\">SetPhysics</span><span class=\"br0\"\
      >(</span><span class=\"kw7\">PHYS_KarmaRagdoll</span><span class=\"br0\">)</span>;\n\
      \t     bClKarma <span class=\"sy0\">=</span> <span class=\"kw6\">true</span>;\
      \ <span class=\"co1\">// dont forget to let its own client know its mesh should\
      \ stay in karma mode.</span>\n\t<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>Remember, you need to set the bClKarma on the client only, the server has\
      \ no idea as to what that boolean parameter is.</p>\n<p>So why check for unkarma\
      \ in PostNetReceive? Simple, I need to check when it changes, and not every\
      \ tick. Since normally you are not in karma, and you're karma flag is false\
      \ when you are playing, no point tying up CPU cycles testing a scenario that\
      \ can be predicted from the server.</p>\n<p>When you are ready to invoke the\
      \ karma mode, use this piece of code:</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\">\t<span class=\"kw2\">if</span> <span class=\"br0\">(</span><span class=\"\
      kw7\">Role</span> <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span>\
      \ <span class=\"br0\">)</span> <span class=\"co1\">// we need to set the karma\
      \ ragdoll time and flag true if applicable on server only</span>\n\t<span class=\"\
      br0\">{</span>\n\t\t<span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ <span class=\"br0\">(</span>bKarma <span class=\"sy0\">==</span> <span class=\"\
      kw6\">false</span><span class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span>\
      \ <span class=\"br0\">(</span>bInKarma <span class=\"sy0\">==</span> <span class=\"\
      kw6\">false</span><span class=\"br0\">)</span> <span class=\"br0\">)</span>\
      \ <span class=\"br0\">{</span> <span class=\"co1\">// if you're already in karma\
      \ mode, no need to do it agin.</span>\n\t\t\tbKarma<span class=\"sy0\">=</span><span\
      \ class=\"kw6\">true</span>;\n\t\t<span class=\"br0\">}</span>\n\t\tiTickTime\
      \ <span class=\"sy0\">=</span> iTickTime <span class=\"sy0\">+</span> <span\
      \ class=\"kw3\">vSize</span><span class=\"br0\">(</span>momentum<span class=\"\
      br0\">)</span><span class=\"sy0\">/</span><span class=\"nu0\">30</span>; <span\
      \ class=\"co1\">// or whatever you want to use.</span>\n\t\tbTickMe <span class=\"\
      sy0\">=</span> <span class=\"kw6\">true</span>;\n\t<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>I use it in my TakeDamage function.</p>\n<p>One last thing, in you\
      \ class add these to your defaultproperties:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">defaultproperties</span>\n<span class=\"\
      br0\">{</span>\n\tbKarma <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>\n\
      \tbInKarma<span class=\"sy0\">=</span> <span class=\"kw6\">false</span>\n\t\
      bAlwaysRelevant<span class=\"sy0\">=</span><span class=\"kw6\">True</span> <span\
      \ class=\"co1\">// should already be set if its a pawn</span>\n\tbGameRelevant<span\
      \ class=\"sy0\">=</span><span class=\"kw6\">True</span> <span class=\"co1\"\
      >// i believe same here as above</span>\n\tbTickMe <span class=\"sy0\">=</span>\
      \ <span class=\"kw6\">false</span>\n\tiTickTime <span class=\"sy0\">=</span>\
      \ <span class=\"nu0\">0</span>\n\tbNetNotify<span class=\"sy0\">=</span><span\
      \ class=\"kw6\">true</span> <span class=\"co1\">// important </span>\n\tbClKarma\
      \ <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>Hopefully this will shed some light on\
      \ the karna networking topic and get more mods looking and feeling realistic.\
      \ I will add my code soon that will allow for you to successfully get your pawn\
      \ back up correctly using bone lifters, and timing (notice I set the timer from\
      \ the momentum parm in the takedamage function). I'm sure the code could be\
      \ optimized and done in many ways, but it works, and its something to start\
      \ from.</p>\n<p>Good luck, and if you have any questions post em, or look for\
      \ me on IRC... im usually around in #unrealwiki, #unrealed, or #unrealscript.</p>\n\
      <p><b>Foxpaw:</b> I would not recommend using bone lifters for the \"getting\
      \ back up\" portion.. bone lifters require collision to be disabled, effectively\
      \ making the player invulnerable while recovering. It would also be kind of\
      \ wierd looking. I think that tweening from the dead body position back to crouching\
      \ animation would be better and is probrably quite possible.</p>\n<p><b>Foxpaw:</b>\
      \ I got tweening back to animation to \"work.\" So far it doesn't look all that\
      \ natural though. I have an idea how to make it more natural but I'd like to\
      \ do so without any hacks.</p>\n<p><b>Foxpaw:</b> Improved the tweening.. making\
      \ it faster makes the wierd nuances unnoticeable and bringing them back to the\
      \ crouched position instead of standing helped as well. Now I only have one\
      \ problem: the relinking of the mesh starts the person off in a standing position.\
      \ This causes the person to tween from standing to crouching when they get up\
      \ which looks a bit wierd. I know how I could probrably fix that but it's a\
      \ hack, so I don't want to do it that way. Any ideas of how I could do this\
      \ cleanly?</p>\n<p><b>OBWANDO:</b> Drop some code in here, lets take a look.\
      \ I was playing with LinkSkelAnim( (anim), (mesh) ) instead of LinkMesh. Its\
      \ a native as well, but from what I see in the actor.uc, it will start the mesh\
      \ up in that animation.</p>\n<p><b>Foxpaw:</b> Unfortunately, since my class\
      \ heirarchy is completely different, the function calls, etcetera will be different.\
      \ I'll put the contents of the \"skeletoncontroller\" class here anyway, you\
      \ can probrably see the idea. An explanation would probrably serve you better:\
      \ When we return from ragdolling, before relinking the mesh we read the orientation\
      \ of all of the main bones, using GetBoneCoords. The X axis of that coordinate\
      \ system that it returns is a vector pointing along the length of the bone,\
      \ thus giving us its rotation. I store this information, relink the meshes,\
      \ then use SetBoneDirection to recreate the ragdoll's position after the relinking.\
      \ The SetBoneDirection has an alpha parameter that allows us to define how much\
      \ of that direction should be imposed and how much should be left to SetBoneRotation/the\
      \ animations. By tweening the alpha from 1 to 0 always with the same directions,\
      \ the body will go from its ragdolled position to the position dictated by its\
      \ animation over the course of the time that it takes to tween the alpha. This\
      \ can create wierd effects if you do it slowly, though, because of the bone\
      \ heirarchy and all. If done quickly enough, however, it appears fairly smooth.\
      \ The only problem with this setup is that it uses some fair network bandwidth,\
      \ because for some reason setbonedirection is not simulated, even though SetBoneRotation\
      \ is.</p>\n<p>There are some functions that are not related to the ragdolling\
      \ in here, and some interplay with a class \"UniversalThing\" and \"SkeletalMeshController,\"\
      \ but you should be able to get the idea from this:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"co1\">// The skeleton of a skeletal mesh.</span>\n\
      <span class=\"kw1\">class</span> SkeletonController <span class=\"kw1\">extends</span>\
      \ UniversalThing notplaceable;\n \n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n \n<span class=\"kw1\">struct</span> BoneData                 \
      \                <span class=\"co1\">// A stored bone structure, used for ragdoll\
      \ recovery.</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">var</span>\
      \ <span class=\"kw5\">name</span>      BoneName;                       <span\
      \ class=\"co1\">// The name of this bone.</span>\n  <span class=\"kw1\">var</span>\
      \ <span class=\"kw5\">coords</span>    BoneCoords;                     <span\
      \ class=\"co1\">// The 'coordinates' of this bone.</span>\n  <span class=\"\
      kw1\">var</span> <span class=\"kw5\">rotator</span>   <span class=\"kw7\">Rotation</span>;\
      \                       <span class=\"co1\">// The current added rotation of\
      \ this bone.</span>\n<span class=\"br0\">}</span>;\n \n<span class=\"kw1\">struct</span>\
      \ TweenBoneDirection\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">var</span>\
      \ <span class=\"kw5\">name</span>      BoneName;                       <span\
      \ class=\"co1\">// The name of the bone.</span>\n  <span class=\"kw1\">var</span>\
      \ <span class=\"kw5\">rotator</span>   Direction;                      <span\
      \ class=\"co1\">// The direction of the bone.</span>\n  <span class=\"kw1\"\
      >var</span> <span class=\"kw5\">float</span>     TweenTime;                \
      \      <span class=\"co1\">// Time remaining to tween.</span>\n  <span class=\"\
      kw1\">var</span> <span class=\"kw5\">float</span>     StartTweenTime;      \
      \           <span class=\"co1\">// How long to tween in total.</span>\n<span\
      \ class=\"br0\">}</span>;\n \n<span class=\"kw1\">var</span> <span class=\"\
      kw5\">Mesh</span>                SafeMesh1, SafeMesh2;   <span class=\"co1\"\
      >// TODO: This is duplicated in the meshcontroller.</span>\n \n<span class=\"\
      kw1\">var</span> array<span class=\"sy0\">&lt;</span>BoneData<span class=\"\
      sy0\">&gt;</span>     Bones;\n<span class=\"kw1\">var</span> array<span class=\"\
      sy0\">&lt;</span>TweenBoneDirection<span class=\"sy0\">&gt;</span> BoneTweenData;\
      \    <span class=\"co1\">// Data for tweening of bone directions.</span>\n \n\
      <span class=\"kw1\">var</span> array<span class=\"sy0\">&lt;</span>name<span\
      \ class=\"sy0\">&gt;</span>         BoneNames;              <span class=\"co1\"\
      >// Important bones that will be retained through ragdoll recovery.</span>\n\
      <span class=\"kw1\">var</span> array<span class=\"sy0\">&lt;</span>name<span\
      \ class=\"sy0\">&gt;</span>         AimBones;               <span class=\"co1\"\
      >// Bones that take part in aiming.</span>\n \n<span class=\"kw1\">var</span>\
      \ <span class=\"kw5\">name</span>                HeldBone;               <span\
      \ class=\"co1\">// Bone that we use for holding things.</span>\n<span class=\"\
      kw1\">var</span> <span class=\"kw5\">name</span>                ViewBone;  \
      \             <span class=\"co1\">// Bone that the camera should view from.</span>\n\
      \ \n<span class=\"kw1\">var</span> <span class=\"kw9\">actor</span>        \
      \       Flesh;                  <span class=\"co1\">// Our \"flesh.\"</span>\n\
      \ \n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ <span class=\"kw4\">postbeginplay</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw6\"\
      >Super</span>.<span class=\"kw4\">postbeginplay</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\"\
      >simulated</span> <span class=\"kw1\">function</span> Initialize<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n \
      \ <span class=\"kw1\">local</span> <span class=\"kw5\">int</span> i;\n \n  Flesh.<span\
      \ class=\"me0\">AnimBlendParams</span><span class=\"br0\">(</span><span class=\"\
      nu0\">1</span>, <span class=\"nu0\">1.0</span>, <span class=\"nu0\">0.0</span>,\
      \ <span class=\"nu0\">0.2</span>, AimBones<span class=\"br0\">[</span><span\
      \ class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"br0\">)</span>;\n\
      \ \n  <span class=\"kw2\">for</span> <span class=\"br0\">(</span>i<span class=\"\
      sy0\">=</span><span class=\"nu0\">0</span>;i<span class=\"sy0\">&lt;</span>BoneNames.<span\
      \ class=\"me0\">Length</span>;i<span class=\"sy0\">++</span><span class=\"br0\"\
      >)</span>\n    SetBoneRot<span class=\"br0\">(</span> BoneNames<span class=\"\
      br0\">[</span>i<span class=\"br0\">]</span>, <span class=\"kw3\">Rot</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span\
      \ class=\"kw1\">function</span> BoneData StoreBone<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">name</span> BoneName <span class=\"br0\">)</span>\n<span\
      \ class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> BoneData NewBone;\n\
      \ \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> Flesh <span\
      \ class=\"sy0\">==</span> <span class=\"kw5\">None</span> <span class=\"br0\"\
      >)</span> <span class=\"kw2\">return</span> NewBone;\n \n  NewBone.<span class=\"\
      me0\">BoneName</span> <span class=\"sy0\">=</span> BoneName;\n  NewBone.<span\
      \ class=\"me0\">BoneCoords</span> <span class=\"sy0\">=</span> Flesh.<span class=\"\
      kw4\">GetBoneCoords</span><span class=\"br0\">(</span> BoneName <span class=\"\
      br0\">)</span>;\n \n  <span class=\"kw2\">return</span> NewBone;\n<span class=\"\
      br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\"\
      >function</span> array<span class=\"sy0\">&lt;</span>BoneData<span class=\"\
      sy0\">&gt;</span> StoreBoneData<span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span>\
      \ <span class=\"kw5\">int</span> i;\n  <span class=\"kw1\">local</span> array<span\
      \ class=\"sy0\">&lt;</span>BoneData<span class=\"sy0\">&gt;</span> BoneData;\n\
      \ \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> Flesh <span\
      \ class=\"sy0\">==</span> <span class=\"kw5\">None</span> <span class=\"br0\"\
      >)</span> <span class=\"kw2\">return</span> BoneData;\n \n  <span class=\"kw2\"\
      >for</span> <span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"\
      nu0\">0</span>;i<span class=\"sy0\">&lt;</span><span class=\"kw1\">Default</span>.<span\
      \ class=\"me0\">BoneNames</span>.<span class=\"me0\">Length</span>;i<span class=\"\
      sy0\">++</span><span class=\"br0\">)</span>\n    BoneData<span class=\"br0\"\
      >[</span>BoneData.<span class=\"me0\">Length</span><span class=\"br0\">]</span>\
      \ <span class=\"sy0\">=</span> StoreBone<span class=\"br0\">(</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">BoneNames</span><span class=\"br0\"\
      >[</span>i<span class=\"br0\">]</span> <span class=\"br0\">)</span>;\n \n  <span\
      \ class=\"kw2\">return</span> BoneData;\n<span class=\"br0\">}</span>\n \n \n\
      <span class=\"co1\">// Set me back up for animation after I've ragdolled.</span>\n\
      <span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span> SolidifyRagdoll<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> array<span class=\"sy0\">&lt;</span>BoneData<span\
      \ class=\"sy0\">&gt;</span> BoneData;\n \n  <span class=\"kw2\">if</span> <span\
      \ class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span> <span class=\"\
      kw5\">None</span> <span class=\"br0\">)</span> <span class=\"kw2\">return</span>;\n\
      \ \n  BoneData <span class=\"sy0\">=</span> StoreBoneData<span class=\"br0\"\
      >(</span><span class=\"br0\">)</span>;\n \n  <span class=\"kw2\">if</span> <span\
      \ class=\"br0\">(</span> <span class=\"br0\">(</span> Flesh.<span class=\"kw5\"\
      >Mesh</span> <span class=\"sy0\">==</span> <span class=\"kw1\">Default</span>.<span\
      \ class=\"me0\">SafeMesh1</span> <span class=\"sy0\">||</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">SafeMesh1</span> <span class=\"sy0\"\
      >==</span> <span class=\"kw5\">None</span> <span class=\"br0\">)</span> <span\
      \ class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">SafeMesh2</span> <span class=\"sy0\"\
      >!=</span> <span class=\"kw5\">None</span> <span class=\"br0\">)</span> <span\
      \ class=\"br0\">)</span>\n    Flesh.<span class=\"kw4\">LinkMesh</span><span\
      \ class=\"br0\">(</span> <span class=\"kw1\">Default</span>.<span class=\"me0\"\
      >SafeMesh2</span> <span class=\"br0\">)</span>;\n  <span class=\"kw2\">else</span>\
      \ <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">SafeMesh1</span> <span class=\"sy0\"\
      >!=</span> <span class=\"kw5\">None</span> <span class=\"br0\">)</span>\n  \
      \  Flesh.<span class=\"kw4\">LinkMesh</span><span class=\"br0\">(</span> <span\
      \ class=\"kw1\">Default</span>.<span class=\"me0\">SafeMesh1</span> <span class=\"\
      br0\">)</span>;\n \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ UniversalThing<span class=\"br0\">(</span> Flesh <span class=\"br0\">)</span>\
      \ <span class=\"sy0\">!=</span> <span class=\"kw5\">None</span> <span class=\"\
      br0\">)</span>\n    UniversalThing<span class=\"br0\">(</span>Flesh<span class=\"\
      br0\">)</span>.<span class=\"me0\">InitializeMesh</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span>;\n \n  RecoverBoneData<span class=\"br0\"\
      >(</span> BoneData <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ RecoverBoneData<span class=\"br0\">(</span> array<span class=\"sy0\">&lt;</span>BoneData<span\
      \ class=\"sy0\">&gt;</span> BoneData <span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"kw5\">int</span>\
      \ i;\n \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> Flesh\
      \ <span class=\"sy0\">==</span> <span class=\"kw5\">None</span> <span class=\"\
      br0\">)</span> <span class=\"kw2\">return</span>;\n \n  <span class=\"kw2\"\
      >for</span> <span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"\
      nu0\">0</span>;i<span class=\"sy0\">&lt;</span>BoneData.<span class=\"me0\"\
      >Length</span>;i<span class=\"sy0\">++</span><span class=\"br0\">)</span>\n\
      \    RecoverBone<span class=\"br0\">(</span> BoneData<span class=\"br0\">[</span>i<span\
      \ class=\"br0\">]</span> <span class=\"br0\">)</span>;\n<span class=\"br0\"\
      >}</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ RecoverBone<span class=\"br0\">(</span> BoneData BoneData <span class=\"br0\"\
      >)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\">if</span> <span\
      \ class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span> <span class=\"\
      kw5\">None</span> <span class=\"br0\">)</span> <span class=\"kw2\">return</span>;\n\
      \ \n  Flesh.<span class=\"me0\">SetBoneLocation</span><span class=\"br0\">(</span>\
      \ BoneData.<span class=\"me0\">BoneName</span>, BoneData.<span class=\"me0\"\
      >BoneCoords</span>.<span class=\"me0\">Origin</span> <span class=\"br0\">)</span>;\n\
      \  SetBoneDir<span class=\"br0\">(</span> BoneData.<span class=\"me0\">BoneName</span>,\
      \ <span class=\"kw5\">Rotator</span><span class=\"br0\">(</span> BoneData.<span\
      \ class=\"me0\">BoneCoords</span>.<span class=\"me0\">XAxis</span> <span class=\"\
      br0\">)</span>,<span class=\"nu0\">0.25</span> <span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span>\n \n<span class=\"kw1\">simulated</span> <span\
      \ class=\"kw1\">function</span> TweakBoneRotation<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">name</span> BoneName, <span class=\"kw1\">out</span> <span\
      \ class=\"kw5\">rotator</span> <span class=\"kw3\">Rot</span> <span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> BoneName <span class=\"sy0\">==</span> HeldBone\
      \ <span class=\"br0\">)</span>\n    <span class=\"kw3\">Rot</span> <span class=\"\
      sy0\">+=</span> <span class=\"kw3\">Rot</span><span class=\"br0\">(</span><span\
      \ class=\"nu0\">16384</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\"\
      >0</span><span class=\"br0\">)</span>;\n \n  <span class=\"co1\">///// Note:\
      \ This function is best described as a \"hack.\" It allows a meshcontroller\
      \ to</span>\n  <span class=\"co1\">///// manually override bone directions by\
      \ assigning a fixed direction to them. It will</span>\n  <span class=\"co1\"\
      >///// not work properly on bones that take part in aiming, etc. It merely exists\
      \ as a</span>\n  <span class=\"co1\">///// method to retrofit existing models\
      \ with bones in wierd orientations.</span>\n<span class=\"br0\">}</span>\n \n\
      <span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ SetAim<span class=\"br0\">(</span> <span class=\"kw5\">rotator</span> Aim\
      \ <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"\
      kw1\">local</span> <span class=\"kw5\">int</span> i;\n \n  <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span>\
      \ <span class=\"kw5\">None</span> <span class=\"br0\">)</span> <span class=\"\
      kw2\">return</span>;\n \n  <span class=\"co1\">// TODO: Hackriffic. Make the\
      \ transormation matrix confusitroniness. Maybe make a \"skeleton\" class,</span>\n\
      \  <span class=\"co1\">// which would be owned by the Thing, that stores our\
      \ current animation positions. Technically that</span>\n  <span class=\"co1\"\
      >// should go here so maybe the meshcontroller could be instantiated.</span>\n\
      \  Flesh.<span class=\"kw4\">SetRotation</span><span class=\"br0\">(</span>\
      \ Aim <span class=\"br0\">)</span>;\n \n  Aim <span class=\"sy0\">-=</span>\
      \ Flesh.<span class=\"kw7\">Rotation</span>;\n \n  <span class=\"kw2\">for</span>\
      \ <span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"nu0\"\
      >0</span>;i<span class=\"sy0\">&lt;</span><span class=\"kw1\">Default</span>.<span\
      \ class=\"me0\">AimBones</span>.<span class=\"me0\">Length</span>;i<span class=\"\
      sy0\">++</span><span class=\"br0\">)</span>\n  <span class=\"br0\">{</span>\n\
      \    Aim.<span class=\"me0\">Roll</span> <span class=\"sy0\">=</span>  Aim.<span\
      \ class=\"me0\">Yaw</span>;\n    Aim.<span class=\"me0\">Yaw</span>  <span class=\"\
      sy0\">=</span> <span class=\"sy0\">-</span>Aim.<span class=\"me0\">Pitch</span>;\n\
      \    Aim.<span class=\"me0\">Pitch</span> <span class=\"sy0\">=</span> <span\
      \ class=\"nu0\">0</span>;\n    SetBoneRot<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">Default</span>.<span class=\"me0\">AimBones</span><span class=\"\
      br0\">[</span>i<span class=\"br0\">]</span>, Aim <span class=\"sy0\">/</span>\
      \ <span class=\"kw1\">Default</span>.<span class=\"me0\">AimBones</span>.<span\
      \ class=\"me0\">Length</span> <span class=\"br0\">)</span>;\n  <span class=\"\
      br0\">}</span>\n \n  <span class=\"kw2\">return</span>;\n<span class=\"br0\"\
      >}</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ <span class=\"kw5\">vector</span> FindBoneLocation<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">name</span> Bone, <span class=\"kw1\">optional</span>\
      \ <span class=\"kw1\">out</span> <span class=\"kw5\">vector</span> <span class=\"\
      kw3\">Rot</span> <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">Coords</span> <span\
      \ class=\"kw5\">Coords</span>;\n \n  <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> Flesh <span class=\"sy0\">==</span> <span class=\"kw5\">None</span>\
      \ <span class=\"sy0\">||</span> Bone <span class=\"sy0\">==</span> <span class=\"\
      st0\">''</span> <span class=\"br0\">)</span> <span class=\"kw2\">return</span>\
      \ <span class=\"kw3\">Vect</span><span class=\"br0\">(</span><span class=\"\
      nu0\">0</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span\
      \ class=\"br0\">)</span>;\n \n  <span class=\"kw5\">Coords</span> <span class=\"\
      sy0\">=</span> Flesh.<span class=\"kw4\">GetBoneCoords</span><span class=\"\
      br0\">(</span> Bone <span class=\"br0\">)</span>;\n  <span class=\"kw3\">Rot</span>\
      \ <span class=\"sy0\">=</span> <span class=\"kw5\">Coords</span>.<span class=\"\
      me0\">XAxis</span>;\n  <span class=\"kw2\">return</span> <span class=\"kw5\"\
      >Coords</span>.<span class=\"me0\">Origin</span>;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ <span class=\"kw5\">rotator</span> FindBoneRotation<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">name</span> Bone <span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ Flesh <span class=\"sy0\">==</span> <span class=\"kw5\">None</span> <span\
      \ class=\"sy0\">||</span> Bone <span class=\"sy0\">==</span> <span class=\"\
      st0\">''</span> <span class=\"br0\">)</span> <span class=\"kw2\">return</span>\
      \ <span class=\"kw3\">Rot</span><span class=\"br0\">(</span><span class=\"nu0\"\
      >0</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\">0</span><span class=\"\
      br0\">)</span>;\n \n  <span class=\"kw2\">return</span> Flesh.<span class=\"\
      kw4\">GetBoneRotation</span><span class=\"br0\">(</span> Bone <span class=\"\
      br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"co1\">// TODO:\
      \ This function name is misleading.</span>\n<span class=\"kw1\">simulated</span>\
      \ <span class=\"kw1\">function</span> <span class=\"kw5\">vector</span> FindHeldLocation<span\
      \ class=\"br0\">(</span> <span class=\"kw1\">optional</span> <span class=\"\
      kw1\">out</span> <span class=\"kw5\">vector</span> <span class=\"kw3\">Rot</span>\
      \ <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"\
      kw2\">if</span> <span class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span>\
      \ <span class=\"kw5\">None</span> <span class=\"sy0\">||</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">HeldBone</span> <span class=\"sy0\"\
      >==</span> <span class=\"st0\">''</span> <span class=\"br0\">)</span> <span\
      \ class=\"kw2\">return</span> <span class=\"kw3\">Vect</span><span class=\"\
      br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span>;\n \n  <span class=\"kw2\"\
      >return</span> FindBoneLocation<span class=\"br0\">(</span> <span class=\"kw1\"\
      >Default</span>.<span class=\"me0\">HeldBone</span>, <span class=\"kw3\">Rot</span>\
      \ <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"\
      co1\">// TODO: This function name is misleading.</span>\n<span class=\"kw1\"\
      >simulated</span> <span class=\"kw1\">function</span> <span class=\"kw5\">vector</span>\
      \ FindHeldRotation<span class=\"br0\">(</span> <span class=\"kw1\">optional</span>\
      \ <span class=\"kw1\">out</span> <span class=\"kw5\">vector</span> Loc <span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span>\
      \ <span class=\"kw5\">None</span> <span class=\"sy0\">||</span> <span class=\"\
      kw1\">Default</span>.<span class=\"me0\">HeldBone</span> <span class=\"sy0\"\
      >==</span> <span class=\"st0\">''</span> <span class=\"br0\">)</span> <span\
      \ class=\"kw2\">return</span> <span class=\"kw3\">Vect</span><span class=\"\
      br0\">(</span><span class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span>;\n \n  Loc <span class=\"\
      sy0\">=</span> FindBoneLocation<span class=\"br0\">(</span> <span class=\"kw1\"\
      >Default</span>.<span class=\"me0\">HeldBone</span> <span class=\"br0\">)</span>;\n\
      \  <span class=\"kw2\">return</span> <span class=\"kw5\">Vector</span><span\
      \ class=\"br0\">(</span> FindBoneRotation<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">Default</span>.<span class=\"me0\">HeldBone</span> <span class=\"\
      br0\">)</span> <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ SetBoneRot<span class=\"br0\">(</span> <span class=\"kw5\">name</span> BoneName,\
      \ <span class=\"kw5\">rotator</span> <span class=\"kw3\">Rot</span> <span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> Flesh <span class=\"sy0\">==</span> <span class=\"\
      kw5\">None</span> <span class=\"br0\">)</span> <span class=\"kw2\">return</span>;\n\
      \  TweakBoneRotation<span class=\"br0\">(</span> BoneName, <span class=\"kw3\"\
      >Rot</span> <span class=\"br0\">)</span>;\n  Flesh.<span class=\"me0\">SetBoneRotation</span><span\
      \ class=\"br0\">(</span> BoneName, <span class=\"kw3\">Rot</span> <span class=\"\
      br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">function</span>\
      \ SetBoneDir<span class=\"br0\">(</span> <span class=\"kw5\">name</span> BoneName,\
      \ <span class=\"kw5\">rotator</span> Dir, <span class=\"kw1\">optional</span>\
      \ <span class=\"kw5\">float</span> TweenTime <span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> TweenBoneDirection\
      \ NewTween;\n \n  <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ Flesh <span class=\"sy0\">==</span> <span class=\"kw5\">None</span> <span\
      \ class=\"br0\">)</span> <span class=\"kw2\">return</span>;\n \n  <span class=\"\
      kw2\">if</span> <span class=\"br0\">(</span> TweenTime <span class=\"sy0\">!=</span>\
      \ <span class=\"nu0\">0</span> <span class=\"br0\">)</span>\n  <span class=\"\
      br0\">{</span>\n    NewTween.<span class=\"me0\">BoneName</span> <span class=\"\
      sy0\">=</span> BoneName;\n    NewTween.<span class=\"me0\">Direction</span>\
      \ <span class=\"sy0\">=</span> Dir;\n    NewTween.<span class=\"me0\">TweenTime</span>\
      \ <span class=\"sy0\">=</span> TweenTime;\n    NewTween.<span class=\"me0\"\
      >StartTweenTime</span> <span class=\"sy0\">=</span> TweenTime;\n    BoneTweenData<span\
      \ class=\"br0\">[</span>BoneTweenData.<span class=\"me0\">Length</span><span\
      \ class=\"br0\">]</span> <span class=\"sy0\">=</span> NewTween;\n  <span class=\"\
      br0\">}</span>\n \n  Flesh.<span class=\"me0\">SetBoneDirection</span><span\
      \ class=\"br0\">(</span> BoneName, Dir,,<span class=\"nu0\">1</span> <span class=\"\
      br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">function</span>\
      \ <span class=\"kw5\">bool</span> TweenBone<span class=\"br0\">(</span> <span\
      \ class=\"kw1\">out</span> TweenBoneDirection BoneData, <span class=\"kw5\"\
      >float</span> Delta <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">bool</span> Result;\n\
      \  Result <span class=\"sy0\">=</span> <span class=\"kw6\">false</span>;\n \n\
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> Flesh <span class=\"\
      sy0\">==</span> <span class=\"kw5\">None</span> <span class=\"br0\">)</span>\
      \ <span class=\"kw2\">return</span> Result;\n \n  BoneData.<span class=\"me0\"\
      >TweenTime</span> <span class=\"sy0\">-=</span> Delta;\n  <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> BoneData.<span class=\"me0\">TweenTime</span>\
      \ <span class=\"sy0\">&lt;</span> <span class=\"nu0\">0</span> <span class=\"\
      br0\">)</span>\n  <span class=\"br0\">{</span>\n    BoneData.<span class=\"\
      me0\">TweenTime</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>;\n\
      \    Result <span class=\"sy0\">=</span> <span class=\"kw6\">true</span>;\n\
      \  <span class=\"br0\">}</span>\n \n  Flesh.<span class=\"me0\">SetBoneDirection</span><span\
      \ class=\"br0\">(</span> BoneData.<span class=\"me0\">BoneName</span>, BoneData.<span\
      \ class=\"me0\">Direction</span>,,BoneData.<span class=\"me0\">TweenTime</span><span\
      \ class=\"sy0\">/</span>BoneData.<span class=\"me0\">StartTweenTime</span> <span\
      \ class=\"br0\">)</span>;\n \n  <span class=\"kw2\">return</span> Result;\n\
      <span class=\"br0\">}</span>\n \n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n \n<span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span>\
      \ <span class=\"kw4\">Tick</span><span class=\"br0\">(</span> <span class=\"\
      kw5\">float</span> Delta <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">int</span> i;\n \n \
      \ <span class=\"kw2\">for</span> <span class=\"br0\">(</span>i<span class=\"\
      sy0\">=</span><span class=\"nu0\">0</span>;i<span class=\"sy0\">&lt;</span>BoneTweenData.<span\
      \ class=\"me0\">Length</span>;i<span class=\"sy0\">++</span><span class=\"br0\"\
      >)</span>\n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span> TweenBone<span\
      \ class=\"br0\">(</span> BoneTweenData<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span>, Delta <span class=\"br0\">)</span> <span class=\"br0\">)</span>\n\
      \      BoneTweenData.<span class=\"me0\">Remove</span><span class=\"br0\">(</span>i,<span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span>;\n \n  <span class=\"kw6\"\
      >Super</span>.<span class=\"kw4\">Tick</span><span class=\"br0\">(</span> Delta\
      \ <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"\
      co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n<span class=\"co1\">// ****************************************************************************************\
      \ //</span>\n \n<span class=\"kw1\">defaultproperties</span>\n<span class=\"\
      br0\">{</span>\n  Bonenames<span class=\"br0\">(</span><span class=\"nu0\">0</span><span\
      \ class=\"br0\">)</span><span class=\"sy0\">=</span>Spine\n  Bonenames<span\
      \ class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">=</span>Head\n  Bonenames<span class=\"br0\">(</span><span class=\"\
      nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">=</span>LShoulder\n\
      \  Bonenames<span class=\"br0\">(</span><span class=\"nu0\">3</span><span class=\"\
      br0\">)</span><span class=\"sy0\">=</span>RShoulder\n  Bonenames<span class=\"\
      br0\">(</span><span class=\"nu0\">4</span><span class=\"br0\">)</span><span\
      \ class=\"sy0\">=</span>LThigh\n  Bonenames<span class=\"br0\">(</span><span\
      \ class=\"nu0\">5</span><span class=\"br0\">)</span><span class=\"sy0\">=</span>RThigh\n\
      \  Bonenames<span class=\"br0\">(</span><span class=\"nu0\">6</span><span class=\"\
      br0\">)</span><span class=\"sy0\">=</span>LFARM\n  Bonenames<span class=\"br0\"\
      >(</span><span class=\"nu0\">7</span><span class=\"br0\">)</span><span class=\"\
      sy0\">=</span>RFARM\n  Bonenames<span class=\"br0\">(</span><span class=\"nu0\"\
      >8</span><span class=\"br0\">)</span><span class=\"sy0\">=</span>RightHand\n\
      \  Bonenames<span class=\"br0\">(</span><span class=\"nu0\">9</span><span class=\"\
      br0\">)</span><span class=\"sy0\">=</span>LFoot\n  Bonenames<span class=\"br0\"\
      >(</span><span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"\
      sy0\">=</span>RFoot\n  Bonenames<span class=\"br0\">(</span><span class=\"nu0\"\
      >11</span><span class=\"br0\">)</span><span class=\"sy0\">=</span>Bone_Weapon\n\
      \ \n  AimBones<span class=\"br0\">(</span><span class=\"nu0\">0</span><span\
      \ class=\"br0\">)</span><span class=\"sy0\">=</span>Spine\n \n  HeldBone<span\
      \ class=\"sy0\">=</span>Bone_Weapon\n  ViewBone<span class=\"sy0\">=</span>Head\n\
      \ \n  SafeMesh1<span class=\"sy0\">=</span><span class=\"kw5\">Mesh</span><span\
      \ class=\"st0\">'Jugg.JuggMaleA'</span>\n  SafeMesh2<span class=\"sy0\">=</span><span\
      \ class=\"kw5\">Mesh</span><span class=\"st0\">'Jugg.JuggFemaleA'</span>\n<span\
      \ class=\"br0\">}</span></pre></div>\n</div>\n<p><b>AlphaOne:</b> Could I ask\
      \ anyone to please taker their time to post a <b>complete</b> solution(s) here\
      \ because I'm having a hard time putting your code together. It would be REALLY\
      \ nice if it was downloadable...(I like being spoon fed)</p>\n<p><b>Foxpaw:</b>\
      \ Unfortunately, because all of the people working on this have different applications\
      \ it's kind of hard to package one solution.. however, I suspect that a mutator\
      \ could be made of this (I think theres a modifydamage function or something\
      \ that could cause the karmatizing and an array of pointers to pawns and their\
      \ respective karma-ing specific values could possibly be stored there. Unfortunately,\
      \ since my application is highly different, I can't really be the one to do\
      \ this. Most of the snippets I've provided here are fairly general, but the\
      \ last one is highly specific and wouldn't work without extensive modification.</p>\n\
      <p><b>Plane Guy:</b> RAGDOLL POSTULATION OUT OF NOWHERE. My mod involves grabbing\
      \ a player pawn and dragging him around. Thing is, with the ragdoll I have to\
      \ attach to a bone and karma yank the doll around BUT the server has no ragdoll\
      \ (else it crashes). Would it be plausible to karma impulse the \"standing\"\
      \ player pawn on the server and get karma-based dragging client-side? Does the\
      \ flippity-floppity nature of ragdolls require I act on it directly with Karma,\
      \ or will the client recognize the server has moved the doll and flail its limbs\
      \ accordingly?</p>\n<p><b>Foxpaw:</b> Hmm, I'm pretty sure that it's possible\
      \ to have an actor using PHYS_KarmaRagdoll on the server.. though I don't know\
      \ how well xPawns handle that. Anyways, Karma ragdolls don't replicate very\
      \ well, so it would probrably be best to do the bone attach to whatever they're\
      \ getting dragged behind and have the dragging completely client side. (And\
      \ have whatever is dragging them get replicated)</p>\n<p><b>Plane Guy:</b> Hmmmm.\
      \ Well I had it working on client-side only, but when the dragging stops, the\
      \ pawn reappears where it was first ragdolled. Would I have to replicate that\
      \ movement BACK to the server (server is NOT the man, oh noes)? Wouldn't I have\
      \ to, once replicated to the server, replicate it back to the other clients?\
      \ Gee, this is getting complicated.</p>\n<p><b>Foxpaw:</b> I recall someone\
      \ else having a similar issue. This seems to be a behaviour of the xPawn class,\
      \ though I can't say that with 100% certainty. xPawns store movements and then\
      \ go off of their saved movement - this reduces apparent lag in network games.\
      \ However, it also means that if you move a Pawn by a means other than the Pawn\
      \ was intended to move, the stored movements don't get updated. I'm not sure\
      \ if there's an easy way around that or not, since I haven't really looked at\
      \ the network stuff for Pawn.</p>\n<p><b>Dirk Fist:</b> I have'nt done much\
      \ with 2k3, But could'nt the <i>Actor&gt;NavigationPoint&gt;SmallNavigationPoint&gt;Teleporter</i>\
      \ accept() function, be modified for setting an actors location?</p>\n<p><b>Plane\
      \ Guy:</b> I don't know if it matters, but I'm in 2K4 now. Perhaps a \"ragdoll\
      \ location\" variable, and have the server actor.move() to it while ragdolled.\
      \ It'd be choppy though, though since the server is going to update the client\
      \ with its old location.</p>\n<p>The other idea I had was to karma impluse the\
      \ same on all clients - replicate the impulse vector - and actor.move() only\
      \ on the server. Everyone'd get a slightly different karma show, but I don't\
      \ think they'd notice.</p>\n<p><b>OlympusMons:</b> Ok guys just an idea. I was\
      \ thinking after reading this, I know it need a <a href=\"/Category:Legacy_Refactor_Me\"\
      \ title=\"Category:Legacy Refactor Me\">Category:Legacy Refactor Me</a> Please!\
      \ Anyways I was thinking maybe you could subclass svehicle or ONSvehicle or\
      \ one of those and since those are pawns, which use skeletal anims and karma,\
      \ maybe you could make the player use a pawn and hope in then when you get KO'd\
      \ you hope out of the vehicle, play KO stuff, then hop back in. Just an idea\
      \ anyways Im not really skilled at uscript, yet hehe, so i'm not going to attempt\
      \ this, yet hehe. Well feel free to give me what for if I dunno what Im talking\
      \ about.</p>\n\n<!-- \nNewPP limit report\nCPU time usage: 0.509 seconds\nReal\
      \ time usage: 1.296 seconds\nPreprocessor visited node count: 81/1000000\nPreprocessor\
      \ generated node count: 320/1000000\nPost‐expand include size: 54/2097152 bytes\n\
      Template argument size: 0/2097152 bytes\nHighest expansion depth: 2/40\nExpensive\
      \ parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report\
      \ (%,ms,calls,template)\n100.00%    0.000      1 - -total\n-->\n\n<!-- Saved\
      \ in parser cache with key wiki:pcache:idhash:1630-0!*!0!!en!*!* and timestamp\
      \ 20221118094450 and revision id 4045\n -->\n"
  categories:
  - sortkey: "Karma Ragdoll Injury System"
    name: "Legacy_Refactor_Me"
  links:
  - ns: 14
    exists: true
    name: "Category:Legacy Refactor Me"
  - ns: 100
    exists: true
    name: "Legacy:Skeletal Mesh"
  - ns: 100
    exists: false
    name: "Legacy:Words About Karma Ragdoll Deaths"
  - ns: 100
    exists: true
    name: "Legacy:Karma Ragdoll"
  templates: []
  images: []
  externallinks: []
  sections:
  - toclevel: 1
    level: "4"
    line: "Removing the Actors Skeleton/Resetting the Karma Parameters, and changing\
      \ Physics back to PHYS_Walking"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Karma_Ragdoll_Injury_System"
    byteoffset: 2441
    anchor: "Removing_the_Actors_Skeleton.2FResetting_the_Karma_Parameters.2C_and_changing_Physics_back_to_PHYS_Walking"
  - toclevel: 1
    level: "4"
    line: "Freezing the Ragdoll"
    number: "2"
    index: "2"
    fromtitle: "Legacy:Karma_Ragdoll_Injury_System"
    byteoffset: 3510
    anchor: "Freezing_the_Ragdoll"
  - toclevel: 1
    level: "4"
    line: "Spawn a New Pawn above the Ragdoll"
    number: "3"
    index: "3"
    fromtitle: "Legacy:Karma_Ragdoll_Injury_System"
    byteoffset: 3795
    anchor: "Spawn_a_New_Pawn_above_the_Ragdoll"
  - toclevel: 1
    level: "3"
    line: "Animating a Ragdoll"
    number: "4"
    index: "4"
    fromtitle: "Legacy:Karma_Ragdoll_Injury_System"
    byteoffset: 4521
    anchor: "Animating_a_Ragdoll"
  - toclevel: 1
    level: "2"
    line: "Discussion"
    number: "5"
    index: "5"
    fromtitle: "Legacy:Karma_Ragdoll_Injury_System"
    byteoffset: 5226
    anchor: "Discussion"
  displaytitle: "Legacy:Karma Ragdoll Injury System"
  iwlinks: []
  wikitext:
    text: "'''Note to reader:''' This page represents an incomplete ''investigation''\
      \ into switching players' pawns into and out of ragdoll mode.  Some considerable\
      \ mileage was made but the implementation does not work in network play.\n\n\
      ----\n\n(Note: this text cut from [[Legacy:Karma Ragdoll|Karma Ragdoll]].  Karma\
      \ Ragdoll should be definition and description.  All these ideas deserve their\
      \ own page).\n\nThis is an idea first proposed on the Wiki by Soldat. Essentially,\
      \ the idea is that when a player is damaged by a weapon, they will go into Karma\
      \ Ragdoll mode for a brief period, depending on the severity of the hit, and\
      \ then get back up. So, for instance, a hit from an assault rifle may merely\
      \ cause you to stumble for a split second before regaining control while a direct\
      \ hit from a rocket would send you through the air to end up as a heap on the\
      \ ground, which (if still alive) would then attempt to crawl back up onto its\
      \ feet. Soldat came up with the following function which will activate the Ragdoll\
      \ Physics on a Pawn. It needs to be placed in a subclass of Pawn or called on\
      \ the Pawn externally (it would require some modification to do that, but could\
      \ be modified to work in a mutators' damage modification function):\n\n<uscript>\n\
      exec function KarmaMe()\n{\n  local KarmaParamsSkel SkelParams;\n  local String\
      \ RagSkelName;\n\n  RagSkelName = Species.static.GetRagSkelName(GetMeshName());\n\
      \  KMakeRagdollAvailable();                                    // allocate a\
      \ space for the incoming ragdoll\n\n  skelParams = KarmaParamsSkel(KParams);\
      \                      // create a new skelParams object based off current KParams\n\
      \  skelParams.KSkeleton = RagSkelName;                         // with our new\
      \ ragdoll\n  KParams = skelParams;                                       //\
      \ and now, voila! KParams is the new skelParams\n\n  KSetBlockKarma(true); \
      \                                      // without this line, I fall THROUGH\
      \ the floor... gross\n\n  SetPhysics(PHYS_KarmaRagdoll);                   \
      \           // actually create the ragdoll\n}\n</uscript>\n\nWhile a neat system,\
      \ and easy enough to get implemented mostly, it has run into a slight problem:\
      \ neither Soldat nor myself (I am also trying to implement this, though slightly\
      \ differently, for my mod) has been able to find a \"perfect\" way to get the\
      \ player to get back up after becoming a ragdoll. I have merged our attempts\
      \ into a single list and described why each did not work quite as planned:\n\
      \n====Removing the Actors Skeleton/Resetting the Karma Parameters, and changing\
      \ Physics back to PHYS_Walking ====\n\n<uscript>\nexec function UnKarmaMe()\n\
      {\n\tKarmaParamsSkel(KParams).KSkeleton = \"\";\n\n\tSetPhysics(PHYS_Walking);\n\
      }\n\nexec function UnKarmaMe2()\n{\n\tKParams = default.KParams;\n\n\tSetPhysics(PHYS_Walking);\n\
      }</uscript>\n\nThough in effect the same thing (Removing the Skeleton and Setting\
      \ the Karma Parameters back to default) it was worth trying both. Neither had\
      \ any effect. When the physics was set back to PHYS_Walking, the player fell\
      \ through the floor and out of the world. This was later found to be a result\
      \ of Karma Ragdoll simulation disabling the regular physics' collision in order\
      \ to use its own. Setting bCollideWorld to true when you set the physics back\
      \ to PHYS_Walking will prevent the player from falling through the floor, but\
      \ it still won't get back up or do anything except look around and shoot. (Because\
      \ its \"state\" hasn't changed in the Pawn class, it still thinks it's walking.)\
      \ However, no animations will play and it will not move anywhere.\n\n====Freezing\
      \ the Ragdoll====\n\n<uscript>\nexec function UnKarmaMe3()\n{\n\tKFreezeRagdoll();\n\
      \n\tSetPhysics(PHYS_Walking);\n}\n</uscript>\n\nThis was tried by Soldat and\
      \ caused the ragdoll to freeze. Aside from not falling into the floor, this\
      \ was no more successful than removing the skeleton.\n\n====Spawn a New Pawn\
      \ above the Ragdoll ====\n\nSoldat's initial idea was to simply destroy the\
      \ ragdoll and spawn a new pawn on top of where the ragdoll used to be. The problem\
      \ with this, was that it would telefrag anyone the ragdoll fell under. Another\
      \ problem was that it didn't have a cool animation to show the person getting\
      \ back up. :P The telefragging was solved with a suggestion from Mysterial and\
      \ expanded by CheshireCat to disable the collision on the new pawn until it\
      \ was no longer touching anyone else, then reenable it. The only existing problem\
      \ with this method is that there is no real smooth way of showing the player\
      \ get back up. As I understand, this is the current method that Soldat is experimenting\
      \ with.\n\n===Animating a Ragdoll===\n\nA short study revealed that merely setting\
      \ the Physics to PHYS_KarmaRagdoll with cause serious problems with animation\
      \ and will prevent any animations from being played, even if physics is reset\
      \ to PHYS_Walking immediately after the call to change it to PHYS_KarmaRagdoll.\
      \ In other words, the pawn does not have to spend any time being a ragdoll to\
      \ cause this effect. I am still researching this find out a way to get animations\
      \ to work after returning the physics to normal. Soldat (I believe) is using\
      \ the last method detailed above (making a new pawn to replace the old one)\
      \ and is trying to find a way to make it look like the new pawn is actually\
      \ the old pawn getting up.\n\n==Discussion==\n\n'''Foxpaw:''' This page has\
      \ been mainly refactored from [[Legacy:Words About Karma Ragdoll Deaths|Words\
      \ About Karma Ragdoll Deaths]] along with some stuff I wrote myself. Credit\
      \ for all of the ideas provided has been given to their respective authors,\
      \ I believe. I hope I didn't leave anyone out. By the way, Soldat, I had an\
      \ idea - you may be able to set the person to a crouching idle animation and\
      \ tween to a standing animation, then, you could make it so when the player\
      \ lands flat on the ground, it kicks up a dust cloud or something like that,\
      \ that would obscure the jump from lying down to the crouching position. Let\
      \ me know how that turns out if you try it, I'm going to continue working on\
      \ a way to get the original pawn to move again.\n\n'''Foxpaw:''' Eureka! I've\
      \ gotten the thing to animate again after returning from ragdoll mode. It wipes\
      \ out the current position and replaces it with the default but at least it\
      \ doesn't require spawning a new pawn and moving over all of the health, etc.\
      \ from it. All you have to do is change the mesh. So basically, call something\
      \ like the following:\n\n<uscript>\n// Reenables animations after returning\
      \ from Karma Ragdoll simulation. Requires a global\n// variable SafeMesh, which\
      \ is a mesh object which we can be guaranteed that this object\n// is not. If\
      \ we try to do this with the same mesh that we are it will not work, therefore,\n\
      // it is imperative that a player never be the mesh stored in safemesh. An alternative\n\
      // is to have two \"safe meshes\" and check to see if the players mesh == the\
      \ first safemesh,\n// if so use the second safemesh. Otherwise just use the\
      \ first. This function assumes a\n// safemesh that is guaranteed to never be\
      \ what the player is set to.\nfunction ReinitializeMesh()\n{\n  local Mesh OldMesh;\n\
      \n  OldMesh = Mesh;\n  LinkMesh( SafeMesh );\n  LinkMesh( OldMesh );\n\n  return;\n\
      }\n</uscript>\n\nI also noticed that you must be careful to not engage the ragdoll\
      \ simulation for too short of a time. When ragdoll simulation first begins,\
      \ your limbs are all concentrated in one spot and they spread out until they\
      \ are in the correct position. This takes only a fraction of a second, though\
      \ it may vary on different computers. If you try to use the karma injury system\
      \ for something mild like a glancing blow that just moves you for a split second\
      \ it will make you turn into a ball of limbs instead!\n\n'''Foxpaw:''' I noticed\
      \ a small problem, but it may be solveable by a bit of number fudging. The momentum\
      \ imparted by various weapons varies immensely. Assault Rifle and Lightning\
      \ gun are only 1, minigun is 1200, each flak shard is 10000, rockets are 50000,\
      \ shock gun primary 60000, flak grenades 75000, and the shock combo in excess\
      \ of 130000. The problem, here, of course, is if I set it up so that a rocket\
      \ puts him down for 3 seconds, he's out like a light if he gets hit by a shock\
      \ combo. If, however, it's set so that a shock combo merely keeps him out for\
      \ 5 seconds, the minigun/AR/lightning gun do diddly squat. Aside from the fact\
      \ that you have to wait a while for the target to recover, it's pretty fun.\
      \ I did notice a couple of things though: A) your ragdoll assumes you were standing.\
      \ Getting ragdolled while crouching does not produce the same effect. B) Ragdolls\
      \ have a tendancy to \"fall through\" very thin surfaces. (IE A 'grate' over\
      \ a pit of slime)  Though cool, the pawn gets stuck when it recovers. This occurs\
      \ with my \"pawns\", regular pawns may act differently.\n\n'''Chema:''' Great!\
      \ and... weird!!  I had been trying the UnKarma stuff for a few days.  I also\
      \ got stuck by the animation.  Here is a full (I think) UnKarmaMe(), incluiding\
      \ the double mesh link:\n\n<uscript>\nexec function UnKarmaMe()\n{\n\tlocal\
      \ Mesh OldMesh;\n\n\tSetPhysics(PHYS_Walking);\t// Reset physics\n\tbCollideWorld\
      \ = true;\t\t// And world collision\n\t\t\t\t\t\t\t\t// (KActors use\tKSetBlockKarma\
      \ for that)\n\tSetCollision(true, true , true); // Block actors and players\
      \ again\n\n\tOldMesh = Mesh;\n\tLinkMesh( SafeMesh );\t\t// Global mesh, you\
      \ will not see it\n\tLinkMesh( OldMesh );\t\t// This puts your mesh back\n}\n\
      </uscript>\n\nThe doble mesh link is really weird, but works.  And it is dificult\
      \ to find what to do whit all those native functions, wich we don't have an\
      \ idea what really do.\n\nNow, to fix the abrupt standing, we could try an immediate\
      \ crouch, or better, I saw somewhere a function to initialize the mesh anim\
      \ before spawn.\n\n'''Foxpaw:''' My pawn comes up in the crouching position.\
      \ It was as simple as adding PlayAnim( 'Crouch' ); after you relink the oldmesh.\
      \ (I'm pretty sure that those parameters are optional. I use a wrapper for animation\
      \ with my \"pawns,\" so my syntax is slightly different.)The real problem is\
      \ not the starting animation, but how to get the starting animation to be something\
      \ very close to what the ragdoll was using, I think. I have had ragdolls get\
      \ their foot caught in tiles on the floor and not end up falling over, just\
      \ kind of going limp - in that instance the standing is better. I've been experimenting\
      \ the the dark magic of manual skeleton rotation - I have a hunch but I'm not\
      \ quite sure how I'll go about it. If you could read the rotation of all of\
      \ the bones, you could manually set them after relinking the mesh and then from\
      \ there tween to an animation. However, obtaining the bones rotation is not\
      \ as simple as calling the GetBoneRotation, as that only returns the rotation\
      \ relative to where the current animation says that it should be. Bones seem\
      \ to use a haphazard mix of absolute and relative locations and rotations, as\
      \ well as even having their own internal coordinate system for each bone! For\
      \ that reason it's a bit confusing. [[Legacy:Skeletal Mesh|Skeletal Mesh]] has\
      \ a listing of skeletal animation functions and a short description of those\
      \ that I have experimented with. Unforunately, I haven't played with all of\
      \ the parameters of the functions. There's another interesting thing that should\
      \ be considered, but maybe this is only a problem with the juggernaut skeleton\
      \ that I'm using: The juggernaut skeleton has an overwhelming tendancy to fall\
      \ to its knees, then fall flat to its face. This may be because of the limits\
      \ on the bones though. It generally performs this if hit by a \"singular, direct\"\
      \ type of attack, like a direct hit from rocket, shock rifle, etc. Multiple-hit\
      \ type weapons like flak work fine, and if a rocket hits the ground nearby the\
      \ results are believable. One more thing. My pawns don't have this problem because\
      \ of the way that they are scripted, but the built in pawns suffer a set amount\
      \ of impulse whenever they get hit as a ragdoll. It does not use the actual\
      \ momentum of the gun, and I don't think it applies it to the actual bone hit\
      \ either. The following is a slighly modified excerpt from the code I use (the\
      \ code I use is in an else block and has an argument Bone instead of declaring\
      \ it.)\n\n<uscript>\n  local float Dummy; // Just to satisfy an out argument.\n\
      \  local name Bone;\n\n  if ( Physics == PHYS_KarmaRagdoll )\n  {\n    Bone\
      \ = GetClosestBone( HitLocation, Normal(Momentum), Dummy );\n    KAddImpulse(momentum,\
      \ hitlocation, Bone);\n  }\n\n  // If you wanted you could collapse this to\
      \ take up less space you could also just do:\n  local float Dummy; // Just to\
      \ satisfy an out argument.\n\n  if ( Physics == PHYS_KarmaRagdoll )\n    KAddImpulse(momentum,\
      \ hitlocation, GetClosestBone( HitLocation, Normal(Momentum), Dummy ));\n</uscript>\n\
      \nI have no idea why Digital Extremes used that RagSkelVel and SkelParams.KShotStrength\
      \ nonsense. This looks way more ragdollish and much cooler as it allows for\
      \ multiple sources of force to be acting in rapid succession. IE when you get\
      \ nailed at close range with the flak cannon. (Of course you probrably wouldn't\
      \ survive anyways but maybe if you had lots of shields and health)\n\n'''Foxpaw:'''\
      \ I got the getting up part a bit better. Your position on the ground is now\
      \ recreated once the mesh is reset, but only on key bones. So now I'm a running\
      \ dilapitated pile of crumpled up bones. :P I'll try to find an efficient way\
      \ to tween out the dilapitatedness into normal movement.\n\n'''Chema:''' Houston,\
      \ I can get up... but can't crouch!  \n\nAdding PlayAnim( 'Crouch' ); to UnKarmaMe\
      \ doesn't work.  Actually, it works normally, but not when I'm Karmed: I stand\
      \ up, but don't crouch.  If I call UnKarmaMe again, from console, then it works.\
      \  Simply put: I can't animate the mesh in the same call that UnKarmaMe, no\
      \ matter if I put in a different function.  \n\nAny idea whats wrong with me?\
      \  And with my code? (hehe). Are you doing anything special apart of the stuff\
      \ in the previous UnKarmaMe()?  I'm setting my TestxPawn trough the URL (dm-gael?Game=Test.TestGame?Class=Test.TestxPawn),\
      \ but there should be a scripted way to do it for a game.  An equivalent of\
      \ the CheckReplacement of the Mutators? (Thanks for all your help!)\n\n'''Foxpaw:'''\
      \ It may be that the animation won't play on the same call. As you may have\
      \ noticed, (maybe, it's kind of hard to see.) For a short time after becoming\
      \ a ragdoll you are just a ball of concentrated body parts. It is possible that\
      \ your ragdollness persists until the next tick. Or something. The 'personnell'\
      \ on my mod are completely custom - I've written my own classes for everything\
      \ below actor, because Pawns have lots of built in junk. :P It has an attached\
      \ \"Mesh Controller\" which monitors animation, etc. and would play the idling\
      \ animation the next opportunity it got... so if it cannot indeed be called\
      \ from the same function it would try again the next tick. That may be why mine\
      \ goes back to the idling animation while yours requires a second call. I believe\
      \ that you can use checkreplacement in mutators to replace your xpawn with the\
      \ one you have made.. I haven't tested it but I believe that you can because\
      \ I think that checkreplacement is called from within spawn, before the controller\
      \ would make its Possess call, which I believe does not occur until after the\
      \ spawn has returned. I haven't tested that part out, the order that the controller\
      \ stuff goes in because I just wrap the controller class, so I don't really\
      \ use it for anything.\n\n'''Foxpaw:''' I noticed another thing, but it might\
      \ not be a big deal for your application. If you really clobber a ragdoll sometimes\
      \ it will suffer a simerror as a result of its joints being spun so fast. This\
      \ will, by default, result in it being destroyed - definately a bad thing if\
      \ the player was merely injured! You can set bDestroyOnSimError in its KParams\
      \ to prevent this, but it doesn't protect against everything. bKImportantRagdoll\
      \ (maybe doesn't have a K, I don't remember for sure) might also be good because\
      \ it prevents the ragdoll from being destroyed if the system runs low on memory\
      \ and wants to make a new ragdoll. The simerror thing may not apply in your\
      \ application, because generally that will only result from things such as flak\
      \ to the head at point blank or similar events, which would kill the pawn anyway.\
      \ It might also be worth investigating what effects mutators that affect the\
      \ ragdolls will have. I'm not sure about Floaty Cadavers, but I know that Slow\
      \ Motion Corpses works by slowing down the entire Karma Ragdoll simulation system.\
      \ This would slow down injured players as well. I don't know if that's a problem\
      \ or not, but it's worth checking out.\n\n'''OBWANDO:''' I took a few hours\
      \ fighting with this, and it wouldnt work at all in any way. Heres what I found...\
      \ If you want to get the pawns to go back to their original animated mesh, you\
      \ need to link with another VALID different mesh. If you try to link with a\
      \ null or non-specified mesh, it will simply not link at all which then you\
      \ will wind up linking the original named mesh and that does absolutely nothing.\
      \ In the end heres what seemed to work for me:\n\nIn my pawn class (RBxPawn.uc):\n\
      \n<uscript>\n\nvar\t(Global) mesh SafeMesh;\n\nexec function KarmaMe()\n{\n\
      \  local KarmaParamsSkel SkelParams;\n  local String RagSkelName;\n\n  SafeMesh\
      \ = Mesh;                                            // This is where I am getting\
      \ the pawn's original mesh\n  RagSkelName = Species.static.GetRagSkelName(GetMeshName());\n\
      \  KMakeRagdollAvailable();                                    // allocate a\
      \ space for the incoming ragdoll\n\n  skelParams = KarmaParamsSkel(KParams);\
      \                      // create a new skelParams object based off current KParams\n\
      \  skelParams.KSkeleton = RagSkelName;                         // with our new\
      \ ragdoll\n  KParams = skelParams;                                       //\
      \ and now, voila! KParams is the new skelParams\n\n  KSetBlockKarma(true); \
      \                                       // without this line, I fall THROUGH\
      \ the floor... gross\n\n  SetPhysics(PHYS_KarmaRagdoll);                   \
      \           // actually create the ragdoll\n}\n\nexec function UnKarmaMe()\n\
      {\n  KarmaParamsSkel(KParams).KSkeleton = \"\";\n\n  SetPhysics(PHYS_Walking);\
      \        // Reset physics\n  bCollideWorld = true;            // And world collision\n\
      \                                         // (KActors use KSetBlockKarma for\
      \ that)\n  SetCollision(true, true , true); // Block actors and players again\n\
      \n  LinkMesh( SkeletalMesh'Weapons.AssaultRifle_1st' );  // I am using a valid\
      \ mesh which is not the same as the pawn's original mesh\n                 \
      \                  // You should probably use a precached mesh for performance\
      \ reasons, the gun seemed good here\n  LinkMesh( SafeMesh );\t         // Link\
      \ the pawn's original mesh and we're done!\n}\n</uscript>\n\n'''Foxpaw:''' I\
      \ believe that is the same as what I wrote above. SafeMesh DOES need to be defined\
      \ as a mesh, I guess I should have explicitly stated that. The OldMesh is the\
      \ mesh that we want to return to and is read in the unkarmatize function on\
      \ my \"livingthing\" class. (This is the \"livingthing\" equivalent of the unkarmame\
      \ function.) I could have sworn we discussed the idea of using two safemeshes\
      \ in case, for whatever reason, the pawn was using one of those meshes, I don't\
      \ see that anywhere on this page though so maybe I just imagined it. :P Should\
      \ we remove the failed attempts listed above or leave them so others can learn\
      \ that those methods don't work and why the didn't work?\n\n'''OBWANDO:''' I\
      \ would say leave it in place, it shows the evolution of the learning curve\
      \ to a final conclusion. You did mention (or i assumed) that there were 2 safemeshes,\
      \ but I did not know that 1 had to be explicitly defined, and that was what\
      \ threw me, and could others. I wouldn't have made it this far without everything\
      \ being available to read.\n\n'''Foxpaw:''' Okay. Both safemeshes would actually\
      \ need to be defined, but you can usually get away with using just one, depending\
      \ on the application. In this instance it's highly unlikely that a pawn would\
      \ have a first person weapon mesh as their mesh so you could get away with the\
      \ way you did it. \n\n'''Foxpaw:''' I've noticed one small issue but it's not\
      \ that big of a deal. If you rotate bones using Unrealscript, the karma ragdoll\
      \ is not rotated appropriately. The visual representation of it is, but the\
      \ actual collision/simulation information remains unchanged. That's probrably\
      \ not a big issue, I've been experimenting with rotating bones to have the player\
      \ \"get back up\" from whatever position they ended up in. In this instance,\
      \ the simulation can be slightly innaccurate if you are hit again while getting\
      \ up.\n\n'''Foxpaw:''' I almost forgot - there's a big problem with this code,\
      \ but it might not be that hard to work around. There's a limit on the number\
      \ of ragdolls that you can have in play at any time. I believe it may be per\
      \ zone, however. The limit appears to be rather low, unfortunately, approximately\
      \ 3 ragdolls per zone. If you had two carcasses and two injured players, one\
      \ would be denied a ragdoll and would just stand still. You could work around\
      \ this by using the IsRagdollAvailible, and if one is not the player could just\
      \ play some other injury animation and be simulated using regular physics.\n\
      \n'''OBWANDO:''' I agree, I listed a piece of simple code to get the idea, but\
      \ to prevent the problems from occuring here is a small snip that you could\
      \ use as well to combat the problems of unavailability.\n\n<uscript>\nexec function\
      \ KarmaMe()\n{\n  local KarmaParamsSkel SkelParams;\n  local String RagSkelName;\n\
      \n  SafeMesh = Mesh;                                            // This is where\
      \ I am getting the pawn's original mesh\n\n  if( RagdollOverride != \"\")  \
      \                                // Try to get the rag-doll setup.\n  \tRagSkelName\
      \ = RagdollOverride;                        // If there is an override, use\
      \ it first\n  else if(Species != None)                                    //\
      \ if not, use species.\n  \tRagSkelName = Species.static.GetRagSkelName( GetMeshName()\
      \ );\n\n  if( RagSkelName != \"\" )                                        \
      \ // If we did find one, try to allocate the space.\n  {\n  \tKMakeRagdollAvailable();\
      \                                  // allocate a space for the incoming ragdoll\n\
      \  }\n  \t\n  if( KIsRagdollAvailable() && RagSkelName != \"\" )\n  {  \n  \
      \  skelParams = KarmaParamsSkel(KParams);                    // create a new\
      \ skelParams object based off current KParams\n    skelParams.KSkeleton = RagSkelName;\
      \                       // with our new ragdoll\n    KParams = skelParams; \
      \                                    // and now, voila! KParams is the new skelParams\n\
      \  \n    KSetBlockKarma(true);                                     // without\
      \ this line, I fall THROUGH the floor... gross\n  \n    SetPhysics(PHYS_KarmaRagdoll);\
      \                            // actually create the ragdoll\n  }\n}\n</uscript>\n\
      \n'''OBWANDO:''' One thing I have noticed that that you can crash the client\
      \ pretty easily if you try to do this in a dedicated network mode. On a local\
      \ client there are no problems, but from what I have seen, a dedicated server\
      \ will not allow the physics to change to ragdoll, so your client will show\
      \ a ragdoll, but your server will still show the last known physics mode (like\
      \ PHYS_Walking, or PHYS_Falling). Maybe we should look at starting a thread\
      \ or page on network implementation.\n\n'''Foxpaw:''' I don't understand what\
      \ you mean by that.. how do you mean the server will \"show\" the last known\
      \ physics mode, if it is a dedicated server? The server/client problem you are\
      \ having is likely due to the KarmaMe function not being replicated.. or something\
      \ like that. I haven't tested mine over network yet but it is set to be triggered\
      \ when hit, if the imparted momentum is over a certain threshold. I am not sure\
      \ how the autonomous proxy treats exec functions so the problem could be with\
      \ that. If you want to ensure that the ragdolling is consistant on both client\
      \ and server you could have a boolean variable that is replicated reliably from\
      \ server to client, and a check in tick - if the variable is true and we are\
      \ not in PHYS_KarmaRagdoll, then call the KarmaMe function, if the variable\
      \ is false and we are in PHYS_KarmaRagdoll, then call the UnKarmaMe function.\
      \ This, of course, would require those functions split into two pieces because\
      \ you wouldn't want to call an exec function and have the cause the server to\
      \ request that same function to be called on the client, which would then cause\
      \ the server to request that same function to be called on the client again,\
      \ etc. Enough talk! :P The implementation could be something like this: (I didn't\
      \ actually compile and test this, there could be typos. It would also maybe\
      \ need some tweaking to allow for running out of ragdolls. You could use a timer\
      \ or whatever you want for unkarmame. I use a manually implemented timer in\
      \ tick.)\n\n<uscript>\nvar bool bIsRagdolling;\nvar float RagdollThreshold;\n\
      \nreplication\n{\n  reliable if ( ROLE==ROLE_Authority )\n    bIsRagdolling;\n\
      }\n\nsimulated function TakeDamage(int Damage, Pawn Instigator, Vector HitLocation,\
      \ Vector Momentum, class<DamageType> DamageType)\n{\n  Super.TakeDamage(Damage,\
      \ Instigator, HitLocation, Momentum, DamageType);\n  if (Role == ROLE_Authority\
      \ && VSize(Momentum) > RagdollThreshold)\n    bIsRagdolling = true;\n}\n\nsimulated\
      \ function Tick(float DeltaTime)\n{\n  Super.Tick(DeltaTime);\n\n  if (Role\
      \ < ROLE_Authority)\n    if (bIsRagdolling && Physics != PHYS_KarmaRagdoll)\n\
      \      KarmaMe();\n    else if (!bIsRagdolling && Physics == PHYS_KarmaRagdoll)\n\
      \      UnKarmaMe();\n}\n\n\nsimulated function KarmaMe()\n{\n  // Do your karmame\
      \ stuff here.\n}\n\nsimulated function UnKarmaMe()\n{\n  // Do your unkarmame\
      \ stuff here.\n}\n\n</uscript>\n\n'''OBWANDO:''' Heres what I've seen. In most\
      \ of the Epic code, you will see that they have the karma sequences set up so\
      \ that the server's pawn doesnt actually get its physics set into KarmaRagdoll\
      \ mode (Level.NetMode != NM_DedicatedServer). Only the client does. Now this\
      \ may seem simple in theory, but the reality is that if you touch a floor surface,\
      \ or its a bot (or a player) that jumps then the physics on the server will\
      \ change and as a result the physics from the server will be replicated as part\
      \ of the normal parent class replication to that physics mode. Thats where the\
      \ problems begin since on the client you are in KarmaRagdoll, and the server\
      \ replicates a PHYS_Walking, or whatever, but its not Ragdoll, so the client\
      \ crashes since you cannot have a walking pawn that is in PHYS_KarmaRagdoll.\
      \ This means you have to address the problem to prevent the client from getting\
      \ the physics change unless you have restored the physics and mesh back and\
      \ are ready for that PHYS mode.\n\n'''Foxpaw:''' Ah, yes. The ragdolls aren't\
      \ simulated on the server usually because that just wastes resources. They are\
      \ \"torn off\" when they are created, so they cease to replicate. I think that\
      \ the implementation I listed above should work.. I hope. I haven't tested that\
      \ or played around with it, I don't really know all of the nuances of the pawn\
      \ class since I don't use it for anything, but it seems logical.\n\n'''Foxpaw:'''\
      \ Apparently, the limit placed on ragdolls is optional. If you just remove the\
      \ MakeRagdollAvailible part and the IsRagdollAvailible check, you can apparently\
      \ make as many ragdolls as you want. Finally, my battlefields can have carcasses\
      \ littered all around, instead of that stupid de-res thing. :P\n\n'''PlaneGuy:'''\
      \ I tried the MP ragdoll code above, but it still crashes. I was thinking if\
      \ being ragdolled is a state, you can set the pawn to ignore any non-ragdoll/karma\
      \ related action in that state. Thoughts?\n\n'''OBWANDO:''' Here is the code\
      \ I created that successfully works. I used a manual timer since the SetTimer\
      \ was too flaky for me. The server first of all is the only one that will REALLY\
      \ know what mode our client is supposed to be in. When we are ragdolling, we\
      \ should probably prevent the bots from moving the ragdoll, or when we come\
      \ back out, the client will show the pawn pretty far away from where it should\
      \ have been. and most importantly, we need to make sure the client does not\
      \ try to change the physics via update from the server.\n\n<uscript>\nvar bool\
      \ bKarma; // server paramater to client if you need to be set to karma mode\n\
      var bool bInKarma; // server parameter letting the client know to override any\
      \ physics changes to karma.\nvar bool bTickMe; // my tick timer boolean\nvar\
      \ bool bClKarma; // the client flag that lets us know that the client is indeed\
      \ in karma mode. (remember Physics will be changed from replication)\nvar int\t\
      iTickTime; // a timer counter since SetTimer was too flaky to use over network.\n\
      \nreplication\n{\n\treliable if (Role == ROLE_Authority )\n\t\tbKarma, bInKarma;\n\
      }\n\nsimulated event PostNetReceive()\n{\n\tif ( PlayerReplicationInfo != None\
      \ )\n    {\n\t\tSetup(class'xUtil'.static.FindPlayerRecord(PlayerReplicationInfo.CharacterName));\n\
      \t\tif ( AmbientGlow == 70 )\n\t\t\tAmbientGlow = Default.AmbientGlow;\n   \
      \     //bNetNotify = false;\n    }\n\n\tif ( (bInKarma == false) && (bKarma\
      \ == false) && (Physics == PHYS_KarmaRagdoll) ) UnKarmaMe(); // ok release karma\
      \ mode go back to a pawn\n\n}\n\nsimulated function Tick(float DeltaTime)\n\
      {\n    if (Role == ROLE_Authority ) {\n\tif (bTickMe) {\n\t\tiTickTime--;\n\t\
      \tif (iTickTime < 1) {\n\t\t\tbTickMe = false;\n\t\t\tUnKarmaMe();\n\t\t}\n\t\
      }\n    }\n\n    if ( (bInKarma && !bTearOff) ) // if we're in karma, but not\
      \ dead, prevent player induced motion from occuring.\n    {\n\tAcceleration\
      \ = vect(0,0,0);\n\tVelocity = vect(0,0,0);\n    }\n    if ( (Physics != PHYS_KarmaRagdoll)\
      \ && (bKarma == true) && (bInKarma == false) ) KarmaMe(); //set the Ragdoll\
      \ Mode\n\n    if ( Level.NetMode == NM_DedicatedServer )\n  \t\treturn;\n  //******\
      \ ONLY LOCAL AND CLIENT STUFF BELOW HERE\n\n    if ( (Physics != PHYS_KarmaRagdoll)\
      \ && (bClKarma == false) && (bInKarma == true) ) KarmaMe(); //Seems replication\
      \ isnt perfect, so lets make sure\n\n    if ( Controller != None ) OldController\
      \ = Controller;\n\n    if ( (bInKarma == true) && (bKarma == false) && (Physics\
      \ != PHYS_KarmaRagdoll) ) SetPhysics(PHYS_KarmaRagdoll); // Enforce Ragdoll\
      \ on clients\n\n    TickFX(DeltaTime);\n\n    if ( bDeRes )\n    {\n       \
      \ TickDeRes(DeltaTime);\n    }\n    // assume dead if bTearOff - for remote\
      \ clients unfff unfff\n    if ( bTearOff )\n    {\n        if ( !bPlayedDeath\
      \ )\n            PlayDying(HitDamageType, TakeHitLocation);\n        return;\n\
      \    }\n\n}\n\nsimulated function UnKarmaMe()\n{\n\tif (ROLE != Role_Authority)\
      \ {\n\t\t\n\t\tKarmaParamsSkel(KParams).KSkeleton = \"\";\n\t\tSetPhysics(PHYS_Falling);\
      \   // Reset physics\n\t\tbCollideWorld = true;       // And world collision\n\
      \t\t\t\t\t\t\t\t\t// (KActors use KSetBlockKarma for that)\n\t\tSetCollision(true,\
      \ true , true); // Block actors and players again\n\t\t\n\t\tLinkMesh( SkeletalMesh'Weapons.AssaultRifle_1st'\
      \ );\n\t\tLinkMesh( SafeMesh );\n\t\tbClKarma = false;\n\t} \n\n\tif ( Role\
      \ == ROLE_Authority ) { //servers set the parameters\n\n\t\tbKarma = false;\n\
      \t\tbInKarma = false;\n\t}\n}\n</uscript>\n\nIn your KarmaMe() routine, add\
      \ this to your karma code:\n\n<uscript>\n\tif (ROLE == Role_Authority) \n\t\
      {\n\t\tbKarma = false;\n\t\tbInKarma = true;\n\t}\n\tif ( Level.NetMode != NM_DedicatedServer\
      \ )\n\t}\n\n... karma code etc...\n\n\t     SetPhysics(PHYS_KarmaRagdoll);\n\
      \t     bClKarma = true; // dont forget to let its own client know its mesh should\
      \ stay in karma mode.\n\t}\n</uscript>\n\nRemember, you need to set the bClKarma\
      \ on the client only, the server has no idea as to what that boolean parameter\
      \ is.\n\nSo why check for unkarma in PostNetReceive? Simple, I need to check\
      \ when it changes, and not every tick. Since normally you are not in karma,\
      \ and you're karma flag is false when you are playing, no point tying up CPU\
      \ cycles testing a scenario that can be predicted from the server.\n\nWhen you\
      \ are ready to invoke the karma mode, use this piece of code:\n\n<uscript>\n\
      \tif (Role == ROLE_Authority ) // we need to set the karma ragdoll time and\
      \ flag true if applicable on server only\n\t{\n\t\tif ( (bKarma == false) &&\
      \ (bInKarma == false) ) { // if you're already in karma mode, no need to do\
      \ it agin.\n\t\t\tbKarma=true;\n\t\t}\n\t\tiTickTime = iTickTime + vSize(momentum)/30;\
      \ // or whatever you want to use.\n\t\tbTickMe = true;\n\t}\n</uscript>\n\n\
      I use it in my TakeDamage function. \n\nOne last thing, in you class add these\
      \ to your defaultproperties:\n\n<uscript>\ndefaultproperties\n{\n\tbKarma =\
      \ false\n\tbInKarma= false\n\tbAlwaysRelevant=True // should already be set\
      \ if its a pawn\n\tbGameRelevant=True // i believe same here as above\n\tbTickMe\
      \ = false\n\tiTickTime = 0\n\tbNetNotify=true // important \n\tbClKarma = false\n\
      }\n</uscript>\n\nHopefully this will shed some light on the karna networking\
      \ topic and get more mods looking and feeling realistic. I will add my code\
      \ soon that will allow for you to successfully get your pawn back up correctly\
      \ using bone lifters, and timing (notice I set the timer from the momentum parm\
      \ in the takedamage function). I'm sure the code could be optimized and done\
      \ in many ways, but it works, and its something to start from.\n\nGood luck,\
      \ and if you have any questions post em, or look for me on IRC... im usually\
      \ around in #unrealwiki, #unrealed, or #unrealscript.\n\n'''Foxpaw:''' I would\
      \ not recommend using bone lifters for the \"getting back up\" portion.. bone\
      \ lifters require collision to be disabled, effectively making the player invulnerable\
      \ while recovering. It would also be kind of wierd looking. I think that tweening\
      \ from the dead body position back to crouching animation would be better and\
      \ is probrably quite possible.\n\n'''Foxpaw:''' I got tweening back to animation\
      \ to \"work.\" So far it doesn't look all that natural though. I have an idea\
      \ how to make it more natural but I'd like to do so without any hacks.\n\n'''Foxpaw:'''\
      \ Improved the tweening.. making it faster makes the wierd nuances unnoticeable\
      \ and bringing them back to the crouched position instead of standing helped\
      \ as well. Now I only have one problem: the relinking of the mesh starts the\
      \ person off in a standing position. This causes the person to tween from standing\
      \ to crouching when they get up which looks a bit wierd. I know how I could\
      \ probrably fix that but it's a hack, so I don't want to do it that way. Any\
      \ ideas of how I could do this cleanly?\n\n'''OBWANDO:''' Drop some code in\
      \ here, lets take a look. I was playing with LinkSkelAnim( (anim), (mesh) )\
      \ instead of LinkMesh. Its a native as well, but from what I see in the actor.uc,\
      \ it will start the mesh up in that animation.\n\n'''Foxpaw:''' Unfortunately,\
      \ since my class heirarchy is completely different, the function calls, etcetera\
      \ will be different. I'll put the contents of the \"skeletoncontroller\" class\
      \ here anyway, you can probrably see the idea. An explanation would probrably\
      \ serve you better: When we return from ragdolling, before relinking the mesh\
      \ we read the orientation of all of the main bones, using GetBoneCoords. The\
      \ X axis of that coordinate system that it returns is a vector pointing along\
      \ the length of the bone, thus giving us its rotation. I store this information,\
      \ relink the meshes, then use SetBoneDirection to recreate the ragdoll's position\
      \ after the relinking. The SetBoneDirection has an alpha parameter that allows\
      \ us to define how much of that direction should be imposed and how much should\
      \ be left to SetBoneRotation/the animations. By tweening the alpha from 1 to\
      \ 0 always with the same directions, the body will go from its ragdolled position\
      \ to the position dictated by its animation over the course of the time that\
      \ it takes to tween the alpha. This can create wierd effects if you do it slowly,\
      \ though, because of the bone heirarchy and all. If done quickly enough, however,\
      \ it appears fairly smooth. The only problem with this setup is that it uses\
      \ some fair network bandwidth, because for some reason setbonedirection is not\
      \ simulated, even though SetBoneRotation is.\n\nThere are some functions that\
      \ are not related to the ragdolling in here, and some interplay with a class\
      \ \"UniversalThing\" and \"SkeletalMeshController,\" but you should be able\
      \ to get the idea from this:\n\n<uscript>\n// The skeleton of a skeletal mesh.\n\
      class SkeletonController extends UniversalThing notplaceable;\n\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n\nstruct BoneData                                 // A stored bone structure,\
      \ used for ragdoll recovery.\n{\n  var name      BoneName;                 \
      \      // The name of this bone.\n  var coords    BoneCoords;              \
      \       // The 'coordinates' of this bone.\n  var rotator   Rotation;      \
      \                 // The current added rotation of this bone.\n};\n\nstruct\
      \ TweenBoneDirection\n{\n  var name      BoneName;                       //\
      \ The name of the bone.\n  var rotator   Direction;                      //\
      \ The direction of the bone.\n  var float     TweenTime;                   \
      \   // Time remaining to tween.\n  var float     StartTweenTime;           \
      \      // How long to tween in total.\n};\n\nvar Mesh                SafeMesh1,\
      \ SafeMesh2;   // TODO: This is duplicated in the meshcontroller.\n\nvar array<BoneData>\
      \     Bones;\nvar array<TweenBoneDirection> BoneTweenData;    // Data for tweening\
      \ of bone directions.\n\nvar array<name>         BoneNames;              //\
      \ Important bones that will be retained through ragdoll recovery.\nvar array<name>\
      \         AimBones;               // Bones that take part in aiming.\n\nvar\
      \ name                HeldBone;               // Bone that we use for holding\
      \ things.\nvar name                ViewBone;               // Bone that the\
      \ camera should view from.\n\nvar actor               Flesh;               \
      \   // Our \"flesh.\"\n\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n\nsimulated function postbeginplay()\n{\n  Super.postbeginplay();\n}\n\
      \nsimulated function Initialize()\n{\n  local int i;\n  \n  Flesh.AnimBlendParams(1,\
      \ 1.0, 0.0, 0.2, AimBones[0]);\n\n  for (i=0;i<BoneNames.Length;i++)\n    SetBoneRot(\
      \ BoneNames[i], Rot(0,0,0) );\n}\n\nsimulated function BoneData StoreBone( name\
      \ BoneName )\n{\n  local BoneData NewBone;\n  \n  if ( Flesh == None ) return\
      \ NewBone;\n\n  NewBone.BoneName = BoneName;\n  NewBone.BoneCoords = Flesh.GetBoneCoords(\
      \ BoneName );\n  \n  return NewBone;\n}\n\nsimulated function array<BoneData>\
      \ StoreBoneData()\n{\n  local int i;\n  local array<BoneData> BoneData;\n  \n\
      \  if ( Flesh == None ) return BoneData;\n\n  for (i=0;i<Default.BoneNames.Length;i++)\n\
      \    BoneData[BoneData.Length] = StoreBone( Default.BoneNames[i] );\n    \n\
      \  return BoneData;\n}\n\n\n// Set me back up for animation after I've ragdolled.\n\
      simulated function SolidifyRagdoll()\n{\n  local array<BoneData> BoneData;\n\
      \  \n  if ( Flesh == None ) return;\n  \n  BoneData = StoreBoneData();\n  \n\
      \  if ( ( Flesh.Mesh == Default.SafeMesh1 || Default.SafeMesh1 == None ) &&\
      \ ( Default.SafeMesh2 != None ) )\n    Flesh.LinkMesh( Default.SafeMesh2 );\n\
      \  else if ( Default.SafeMesh1 != None )\n    Flesh.LinkMesh( Default.SafeMesh1\
      \ );\n    \n  if ( UniversalThing( Flesh ) != None )\n    UniversalThing(Flesh).InitializeMesh();\n\
      \  \n  RecoverBoneData( BoneData );\n}\n\nsimulated function RecoverBoneData(\
      \ array<BoneData> BoneData )\n{\n  local int i;\n  \n  if ( Flesh == None )\
      \ return;\n\n  for (i=0;i<BoneData.Length;i++)\n    RecoverBone( BoneData[i]\
      \ );\n}\n\nsimulated function RecoverBone( BoneData BoneData )\n{\n  if ( Flesh\
      \ == None ) return;\n\n  Flesh.SetBoneLocation( BoneData.BoneName, BoneData.BoneCoords.Origin\
      \ );\n  SetBoneDir( BoneData.BoneName, Rotator( BoneData.BoneCoords.XAxis ),0.25\
      \ );\n}\n\nsimulated function TweakBoneRotation( name BoneName, out rotator\
      \ Rot )\n{\n  if ( BoneName == HeldBone )\n    Rot += Rot(16384,0,0);\n\n  /////\
      \ Note: This function is best described as a \"hack.\" It allows a meshcontroller\
      \ to\n  ///// manually override bone directions by assigning a fixed direction\
      \ to them. It will\n  ///// not work properly on bones that take part in aiming,\
      \ etc. It merely exists as a\n  ///// method to retrofit existing models with\
      \ bones in wierd orientations.\n}\n\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n\nsimulated function SetAim( rotator Aim )\n{\n  local int i;\n \n  if\
      \ ( Flesh == None ) return;\n\n  // TODO: Hackriffic. Make the transormation\
      \ matrix confusitroniness. Maybe make a \"skeleton\" class,\n  // which would\
      \ be owned by the Thing, that stores our current animation positions. Technically\
      \ that\n  // should go here so maybe the meshcontroller could be instantiated.\n\
      \  Flesh.SetRotation( Aim );\n  \n  Aim -= Flesh.Rotation;\n\n  for (i=0;i<Default.AimBones.Length;i++)\n\
      \  {\n    Aim.Roll =  Aim.Yaw;\n    Aim.Yaw  = -Aim.Pitch;\n    Aim.Pitch =\
      \ 0;\n    SetBoneRot( Default.AimBones[i], Aim / Default.AimBones.Length );\n\
      \  }\n  \n  return;\n}\n\nsimulated function vector FindBoneLocation( name Bone,\
      \ optional out vector Rot )\n{\n  local Coords Coords;\n  \n  if ( Flesh ==\
      \ None || Bone == '' ) return Vect(0,0,0);\n  \n  Coords = Flesh.GetBoneCoords(\
      \ Bone );\n  Rot = Coords.XAxis;\n  return Coords.Origin;\n}\n\nsimulated function\
      \ rotator FindBoneRotation( name Bone )\n{\n  if ( Flesh == None || Bone ==\
      \ '' ) return Rot(0,0,0);\n\n  return Flesh.GetBoneRotation( Bone );\n}\n\n\
      // TODO: This function name is misleading.\nsimulated function vector FindHeldLocation(\
      \ optional out vector Rot )\n{\n  if ( Flesh == None || Default.HeldBone ==\
      \ '' ) return Vect(0,0,0);\n\n  return FindBoneLocation( Default.HeldBone, Rot\
      \ );\n}\n\n// TODO: This function name is misleading.\nsimulated function vector\
      \ FindHeldRotation( optional out vector Loc )\n{\n  if ( Flesh == None || Default.HeldBone\
      \ == '' ) return Vect(0,0,0);\n\n  Loc = FindBoneLocation( Default.HeldBone\
      \ );\n  return Vector( FindBoneRotation( Default.HeldBone ) );\n}\n\nsimulated\
      \ function SetBoneRot( name BoneName, rotator Rot )\n{\n  if ( Flesh == None\
      \ ) return;\n  TweakBoneRotation( BoneName, Rot );\n  Flesh.SetBoneRotation(\
      \ BoneName, Rot );\n}\n\nfunction SetBoneDir( name BoneName, rotator Dir, optional\
      \ float TweenTime )\n{\n  local TweenBoneDirection NewTween;\n  \n  if ( Flesh\
      \ == None ) return;\n\n  if ( TweenTime != 0 )\n  {\n    NewTween.BoneName =\
      \ BoneName;\n    NewTween.Direction = Dir;\n    NewTween.TweenTime = TweenTime;\n\
      \    NewTween.StartTweenTime = TweenTime;\n    BoneTweenData[BoneTweenData.Length]\
      \ = NewTween;\n  }\n  \n  Flesh.SetBoneDirection( BoneName, Dir,,1 );\n}\n\n\
      function bool TweenBone( out TweenBoneDirection BoneData, float Delta )\n{\n\
      \  local bool Result;\n  Result = false;\n  \n  if ( Flesh == None ) return\
      \ Result;\n\n  BoneData.TweenTime -= Delta;\n  if ( BoneData.TweenTime < 0 )\n\
      \  {\n    BoneData.TweenTime = 0;\n    Result = true;\n  }\n\n  Flesh.SetBoneDirection(\
      \ BoneData.BoneName, BoneData.Direction,,BoneData.TweenTime/BoneData.StartTweenTime\
      \ );\n  \n  return Result;\n}\n\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n\nsimulated function Tick( float Delta )\n{\n  local int i;\n  \n  for\
      \ (i=0;i<BoneTweenData.Length;i++)\n    if ( TweenBone( BoneTweenData[i], Delta\
      \ ) )\n      BoneTweenData.Remove(i,1);\n    \n  Super.Tick( Delta );\n}\n\n\
      // ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n// ****************************************************************************************\
      \ //\n\ndefaultproperties\n{\n  Bonenames(0)=Spine\n  Bonenames(1)=Head\n  Bonenames(2)=LShoulder\n\
      \  Bonenames(3)=RShoulder\n  Bonenames(4)=LThigh\n  Bonenames(5)=RThigh\n  Bonenames(6)=LFARM\n\
      \  Bonenames(7)=RFARM\n  Bonenames(8)=RightHand\n  Bonenames(9)=LFoot\n  Bonenames(10)=RFoot\n\
      \  Bonenames(11)=Bone_Weapon\n  \n  AimBones(0)=Spine\n    \n  HeldBone=Bone_Weapon\n\
      \  ViewBone=Head\n\n  SafeMesh1=Mesh'Jugg.JuggMaleA'\n  SafeMesh2=Mesh'Jugg.JuggFemaleA'\n\
      }\n</uscript>\n\n'''AlphaOne:''' Could I ask anyone to please taker their time\
      \ to post a '''complete''' solution(s) here because I'm having a hard time putting\
      \ your code together. It would be REALLY nice if it was downloadable...(I like\
      \ being spoon fed)\n\n'''Foxpaw:''' Unfortunately, because all of the people\
      \ working on this have different applications it's kind of hard to package one\
      \ solution.. however, I suspect that a mutator could be made of this (I think\
      \ theres a modifydamage function or something that could cause the karmatizing\
      \ and an array of pointers to pawns and their respective karma-ing specific\
      \ values could possibly be stored there. Unfortunately, since my application\
      \ is highly different, I can't really be the one to do this. Most of the snippets\
      \ I've provided here are fairly general, but the last one is highly specific\
      \ and wouldn't work without extensive modification.\n\n'''Plane Guy:''' RAGDOLL\
      \ POSTULATION OUT OF NOWHERE. My mod involves grabbing a player pawn and dragging\
      \ him around. Thing is, with the ragdoll I have to attach to a bone and karma\
      \ yank the doll around BUT the server has no ragdoll (else it crashes). Would\
      \ it be plausible to karma impulse the \"standing\" player pawn on the server\
      \ and get karma-based dragging client-side? Does the flippity-floppity nature\
      \ of ragdolls require I act on it directly with Karma, or will the client recognize\
      \ the server has moved the doll and flail its limbs accordingly?\n\n'''Foxpaw:'''\
      \ Hmm, I'm pretty sure that it's possible to have an actor using PHYS_KarmaRagdoll\
      \ on the server.. though I don't know how well xPawns handle that. Anyways,\
      \ Karma ragdolls don't replicate very well, so it would probrably be best to\
      \ do the bone attach to whatever they're getting dragged behind and have the\
      \ dragging completely client side. (And have whatever is dragging them get replicated)\n\
      \n'''Plane Guy:''' Hmmmm. Well I had it working on client-side only, but when\
      \ the dragging stops, the pawn reappears where it was first ragdolled. Would\
      \ I have to replicate that movement BACK to the server (server is NOT the man,\
      \ oh noes)? Wouldn't I have to, once replicated to the server, replicate it\
      \ back to the other clients? Gee, this is getting complicated.\n\n'''Foxpaw:'''\
      \ I recall someone else having a similar issue. This seems to be a behaviour\
      \ of the xPawn class, though I can't say that with 100% certainty. xPawns store\
      \ movements and then go off of their saved movement - this reduces apparent\
      \ lag in network games. However, it also means that if you move a Pawn by a\
      \ means other than the Pawn was intended to move, the stored movements don't\
      \ get updated. I'm not sure if there's an easy way around that or not, since\
      \ I haven't really looked at the network stuff for Pawn.\n\n'''Dirk Fist:'''\
      \ I have'nt done much with 2k3, But could'nt the ''Actor>NavigationPoint>SmallNavigationPoint>Teleporter\
      \ '' accept() function, be modified for setting an actors location?\n\n'''Plane\
      \ Guy:''' I don't know if it matters, but I'm in 2K4 now. Perhaps a \"ragdoll\
      \ location\" variable, and have the server actor.move() to it while ragdolled.\
      \ It'd be choppy though, though since the server is going to update the client\
      \ with its old location.\n\nThe other idea I had was to karma impluse the same\
      \ on all clients - replicate the impulse vector - and actor.move() only on the\
      \ server. Everyone'd get a slightly different karma show, but I don't think\
      \ they'd notice.\n\n'''OlympusMons:''' Ok guys just an idea. I was thinking\
      \ after reading this, I know it need a [[:Category:Legacy Refactor Me]] Please!\
      \ Anyways I was thinking maybe you could subclass svehicle or ONSvehicle or\
      \ one of those and since those are pawns, which use skeletal anims and karma,\
      \ maybe you could make the player use a pawn and hope in then when you get KO'd\
      \ you hope out of the vehicle, play KO stuff, then hop back in. Just an idea\
      \ anyways Im not really skilled at uscript, yet hehe, so i'm not going to attempt\
      \ this, yet hehe. Well feel free to give me what for if I dunno what Im talking\
      \ about.\n\n[[Category:Legacy Refactor Me|{{PAGENAME}}]]\n[[Category:Legacy\
      \ Refactor Me|{{PAGENAME}}]]"
  properties: []
  revId: 4045
name: "Legacy:Karma Ragdoll Injury System"
revision:
  revid: 4045
  parentid: 4047
  user: "Wormbo"
  timestamp: 1158225745.000000000
  comment: "heil revert"
timestamp: 1668764692.535497000
