---
parse:
  title: "Legacy:Genetic Programming/Nodes"
  text:
    text: "<p>First off, read the introduction on <a href=\"/Legacy:Genetic_Programming\"\
      \ title=\"Legacy:Genetic Programming\">Genetic Programming</a>, and go look\
      \ at the animated tutorial at <a rel=\"nofollow\" class=\"external text\" href=\"\
      http://www.genetic-programming.com/gpanimatedtutorial.html\">www.genetic-programming.com/gpanimatedtutorial.html</a>\
      \ or all of this is all going to be nonsense&#160;:)</p>\n<p>OK, by now you\
      \ should know that GP uses a tree structure of linked objects to do its 'thinking'\
      \ these objects are either 'Terminals' (i.e. 'leaves' at the end of the tree\
      \ branches which return either sensor input or constant values) or 'Functions'\
      \ which take one or more values and return another.</p>\n<p>In my implimentation\
      \ all nodes take and return floats as arguments so it doesn't matter how much\
      \ you mix things up, no node gets presented with data it can't cope with.</p>\n\
      <p>Here's a simple node that adds together its two inputs:</p>\n<div dir=\"\
      ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"co1\">//-----------------------------------------------------------</span>\n\
      <span class=\"co1\">// arithmetic addition function</span>\n<span class=\"co1\"\
      >//-----------------------------------------------------------</span>\n<span\
      \ class=\"kw1\">class</span> GPFplus <span class=\"kw1\">extends</span> GPnode;\n\
      \ \n \n<span class=\"kw1\">function</span> <span class=\"kw5\">float</span>\
      \ evaluate<span class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n  <span class=\"kw2\">return</span><span class=\"br0\">(</span>\
      \ children<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"\
      br0\">]</span>.<span class=\"me0\">evaluate</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span> <span class=\"sy0\">+</span> children<span class=\"\
      br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span>.<span\
      \ class=\"me0\">evaluate</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span\
      \ class=\"kw1\">function</span> <span class=\"kw5\">string</span> makemytoken<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw2\">return</span><span class=\"br0\">(</span><span class=\"\
      st0\">\"+\"</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n\
      \ \n \n<span class=\"kw1\">DefaultProperties</span>\n<span class=\"br0\">{</span>\n\
      \ childcount<span class=\"sy0\">=</span><span class=\"nu0\">2</span>\n<span\
      \ class=\"br0\">}</span></pre></div>\n</div>\n<p>It extends GPnode which is\
      \ the base class of all the nodes and includes lots of baggage to be explained\
      \ later, for now just notice that the nodes below it in the parse tree are referenced\
      \ by the children[] array and that the evaluate method is called on these children\
      \ in order to get the values that need to be added together. This is the basic\
      \ magic, all the objects in the tree are linked together and control flows down\
      \ the branches until something that actually returns a value is evaluated. Some\
      \ nodes are conditional and branches get evaluated or not depending on conditions...\
      \ in this way we can produce a program that actually varies its behavior according\
      \ to conditions, unlike any of the simple examples in the tutorial linked to\
      \ above which are more like equations than anything we'd call 'code'.</p>\n\
      <p>As an example here's evaluate for the 'less than' node:</p>\n<div dir=\"\
      ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"kw1\">function</span> <span class=\"kw5\"\
      >float</span> evaluate<span class=\"br0\">(</span><span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"\
      kw5\">float</span> arg1,arg2;\n  arg1<span class=\"sy0\">=</span>children<span\
      \ class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span>.<span\
      \ class=\"me0\">evaluate</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n  arg2<span class=\"sy0\">=</span>children<span class=\"br0\">[</span><span\
      \ class=\"nu0\">1</span><span class=\"br0\">]</span>.<span class=\"me0\">evaluate</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n  <span class=\"kw2\"\
      >if</span><span class=\"br0\">(</span>arg1<span class=\"sy0\">&lt;</span>arg2<span\
      \ class=\"br0\">)</span> <span class=\"kw2\">return</span><span class=\"br0\"\
      >(</span>children<span class=\"br0\">[</span><span class=\"nu0\">2</span><span\
      \ class=\"br0\">]</span>.<span class=\"me0\">evaluate</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span><span class=\"br0\">)</span>;\n  <span\
      \ class=\"kw2\">else</span>\n    <span class=\"kw2\">return</span><span class=\"\
      br0\">(</span>children<span class=\"br0\">[</span><span class=\"nu0\">3</span><span\
      \ class=\"br0\">]</span>.<span class=\"me0\">evaluate</span><span class=\"br0\"\
      >(</span><span class=\"br0\">)</span><span class=\"br0\">)</span>;\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>Notice how sometimes children[2] gets\
      \ evaluated and other times it's children[3] that gets to see some action.</p>\n\
      <p>Now in order to get any of this to work we need a way of storing the tree\
      \ so it can be passed around and manipulated, this is where makemytoken() comes\
      \ in, its job is to return the string representation of that node... pretty\
      \ simple here but nodes which hold values need something more... here's evaluate\
      \ and makemytoken for the 'constant' terminal node:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">var</span> <span class=\"kw5\">float</span>\
      \ val;\n \n<span class=\"kw1\">function</span> <span class=\"kw5\">float</span>\
      \ evaluate<span class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n    <span class=\"kw2\">return</span><span class=\"br0\">(</span>val<span\
      \ class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\"\
      >function</span> <span class=\"kw5\">string</span> makemytoken<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n \
      \ <span class=\"kw2\">return</span><span class=\"br0\">(</span><span class=\"\
      st0\">\"K\"</span><span class=\"sy0\">$</span>val<span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>As you can see I use the\
      \ character K to flag a constant and then append the value to is using uscripts\
      \ really rather useful built in type conversions.</p>\n<p>Enough specifics,\
      \ I hope that conveys the gist, here's the core GPnode code in it's glory:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"co1\">//-----------------------------------------------------------</span>\n\
      <span class=\"co1\">// Genetic Programming parse tree node root class</span>\n\
      <span class=\"co1\">//-----------------------------------------------------------</span>\n\
      <span class=\"kw1\">class</span> GPnode <span class=\"kw1\">extends</span> <span\
      \ class=\"kw9\">Actor</span>;\n \n \n<span class=\"kw1\">Var</span> <span class=\"\
      kw5\">int</span> Childcount;\n<span class=\"kw1\">var</span> GPnode children<span\
      \ class=\"br0\">[</span><span class=\"nu0\">4</span><span class=\"br0\">]</span>,\
      \ parent;\n<span class=\"kw1\">var</span> <span class=\"kw5\">int</span> childnum,\
      \ depth; <span class=\"co1\">// self = parent.chilren[childnum]</span>\n<span\
      \ class=\"kw1\">var</span> <span class=\"kw5\">string</span> mytoken;\n<span\
      \ class=\"kw1\">var</span> <span class=\"kw9\">actor</span> mypawn;        \
      \    <span class=\"co1\">// might not be always be a pawn, hence type = actor\
      \ for now</span>\n<span class=\"kw1\">var</span> <span class=\"kw1\">const</span>\
      \ <span class=\"kw5\">string</span> terminators, functions;\n<span class=\"\
      kw1\">var</span> <span class=\"kw1\">const</span> <span class=\"kw5\">string</span>\
      \ alltypes;\n \n \n<span class=\"kw1\">function</span> <span class=\"kw5\">float</span>\
      \ evaluate<span class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n  <span class=\"kw2\">return</span><span class=\"br0\">(</span>children<span\
      \ class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span>.<span\
      \ class=\"me0\">evaluate</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>Variables and a very empty evaluate method.</p>\n<p>Now more recursion:\
      \ this is how the tree gets written out as a string: the node writes it's own\
      \ token to the string then calls writetostring on its children, those children\
      \ in turn get their children to write a token to the string and so on... somehow\
      \ satisfyingly cool to someone like myself who's never been beyond a simple\
      \ recursive factiorial function before&#160;:)</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">function</span> WriteToString<span class=\"\
      br0\">(</span> <span class=\"kw1\">out</span> <span class=\"kw5\">string</span>\
      \ genome <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n <span\
      \ class=\"kw1\">local</span> <span class=\"kw5\">int</span> i;\n genome <span\
      \ class=\"sy0\">=</span> genome<span class=\"sy0\">$</span>MakeMyToken<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n <span class=\"kw2\"\
      >if</span><span class=\"br0\">(</span>childcount <span class=\"sy0\">==</span>\
      \ <span class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"kw2\"\
      >return</span>;\n <span class=\"kw2\">else</span>\n  <span class=\"br0\">{</span>\n\
      \    <span class=\"kw2\">for</span><span class=\"br0\">(</span>i<span class=\"\
      sy0\">=</span><span class=\"nu0\">0</span>;i<span class=\"sy0\">&lt;</span>childcount;i<span\
      \ class=\"sy0\">++</span><span class=\"br0\">)</span>\n     <span class=\"br0\"\
      >{</span>\n       children<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span\
      \ class=\"me0\">WriteToString</span><span class=\"br0\">(</span>genome<span\
      \ class=\"br0\">)</span>;\n     <span class=\"br0\">}</span>\n  <span class=\"\
      br0\">}</span>\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">function</span>\
      \ <span class=\"kw5\">string</span> makemytoken<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n<span class=\"co1\"\
      >//log(\"makemytoken called on \"$self);</span>\n<span class=\"co1\">// null\
      \ token for base class, make this return the string that represents</span>\n\
      <span class=\"co1\">// any subclass (mostly one char but constant terminators\
      \ need to write out</span>\n<span class=\"co1\">// their value forinstance)</span>\n\
      <span class=\"kw2\">return</span><span class=\"br0\">(</span><span class=\"\
      st0\">\"\"</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>Notice also cunning use of an 'out' declaration there so all that\
      \ needs to be done to create the genome string is simply call WriteToString(s)\
      \ on the root node of the tree and as if by magic, S gets an encoded version\
      \ of the object tree written to it.. by now I'm really starting to grock recursion\
      \ properly and feel like I'm on a run, the elegence of these objects all describing\
      \ themselves is appealing but in the background I can't help wondering if it\
      \ all might fall apart somehow...</p>\n<p>Doubts or not, this is how most of\
      \ the functionality has shaped up, simply call a method on the root node and\
      \ all else follows for various tree manipulation tasks.</p>\n<p>Now having written\
      \ this string we neeed a way of reading it back in and creating an object tree\
      \ out of it... so let's go all recursive again and we have the imaginatively\
      \ named:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n\
      <div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\"\
      >Function</span> ReadFromString<span class=\"br0\">(</span> <span class=\"kw1\"\
      >out</span> <span class=\"kw5\">string</span> genome<span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span> <span class=\"\
      kw5\">int</span> i;\n  <span class=\"kw1\">local</span> <span class=\"kw5\"\
      >string</span> <span class=\"kw5\">char</span>;\n  <span class=\"kw1\">local</span>\
      \ GPnode node;\n  <span class=\"kw2\">for</span> <span class=\"br0\">(</span>\
      \ i <span class=\"sy0\">=</span><span class=\"nu0\">0</span>; i<span class=\"\
      sy0\">&lt;</span>childcount;i<span class=\"sy0\">++</span><span class=\"br0\"\
      >)</span>\n  <span class=\"br0\">{</span>\n    <span class=\"co1\">// eat and\
      \ analyse first (leftmost) char of string</span>\n \n    <span class=\"kw5\"\
      >char</span> <span class=\"sy0\">=</span> <span class=\"kw3\">left</span><span\
      \ class=\"br0\">(</span>genome,<span class=\"nu0\">1</span><span class=\"br0\"\
      >)</span>;\n    genome <span class=\"sy0\">=</span> <span class=\"kw3\">right</span><span\
      \ class=\"br0\">(</span>genome,<span class=\"kw3\">len</span><span class=\"\
      br0\">(</span>genome<span class=\"br0\">)</span><span class=\"sy0\">-</span><span\
      \ class=\"nu0\">1</span><span class=\"br0\">)</span>;\n    node <span class=\"\
      sy0\">=</span> addchild<span class=\"br0\">(</span> <span class=\"kw5\">char</span>,i<span\
      \ class=\"br0\">)</span>;\n    node.<span class=\"me0\">ReadFromString</span><span\
      \ class=\"br0\">(</span>genome<span class=\"br0\">)</span>;\n <span class=\"\
      br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>So basically\
      \ you start by spawning a gpnode as the root, feed it the string of gobbledegook\
      \ generated by writetostring and it reads (and discards) the first character,\
      \ spawns the appropriate node actor, makes that its first child and passes the\
      \ rest of the string to it so it can make any children it might need in turn...\
      \ and so it goes on down the tree.</p>\n<p>Addchild is a big switch that takes\
      \ care of spawning the right sort of node type according to the character token\
      \ that has been read in:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">function</span> gpnode addchild<span class=\"br0\">(</span><span class=\"\
      kw5\">string</span> childtype, <span class=\"kw5\">int</span> i<span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw1\">local</span>\
      \ class<span class=\"sy0\">&lt;</span>actor<span class=\"sy0\">&gt;</span> \
      \ child<span class=\"re0\">class</span>&lt; SEMI &gt;\n  <span class=\"kw1\"\
      >local</span> gpnode node;\n \n   <span class=\"kw2\">switch</span><span class=\"\
      br0\">(</span>childtype<span class=\"br0\">)</span>\n   <span class=\"br0\"\
      >{</span>\n    <span class=\"co1\">// functions first</span>\n      <span class=\"\
      kw2\">case</span> <span class=\"st0\">\"+\"</span>:\n          childclass <span\
      \ class=\"sy0\">=</span> <span class=\"kw1\">class</span><span class=\"st0\"\
      >'GPFplus'</span>;\n          <span class=\"kw2\">break</span>;\n      <span\
      \ class=\"kw2\">case</span> <span class=\"st0\">\"-\"</span>:\n          childclass\
      \ <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span class=\"\
      st0\">'GPFminus'</span>;\n          <span class=\"kw2\">break</span>;\n    \
      \  <span class=\"kw2\">case</span> <span class=\"st0\">\"*\"</span>:\n     \
      \     childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFmultiply'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"%\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFsafeDivide'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"&lt;\"</span>:\n\
      \          childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFlessThan'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"Q\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFSqrt'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"N\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFMin'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"X\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFMax'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"co1\">// then the terminators</span>\n      <span class=\"\
      kw2\">case</span> <span class=\"st0\">\"R\"</span>:\n          childclass <span\
      \ class=\"sy0\">=</span> <span class=\"kw1\">class</span><span class=\"st0\"\
      >'GPFrightTurn'</span>;\n          <span class=\"kw2\">break</span>;\n     \
      \ <span class=\"kw2\">case</span> <span class=\"st0\">\"L\"</span>:\n      \
      \    childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPFleftTurn'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"K\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTconstant'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"A\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookAhead'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"B\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookAheadRight'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"C\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookRight'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"D\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookBackRight'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"E\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookBack'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"F\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookBackLeft'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"G\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookLeft'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw2\">case</span> <span class=\"st0\">\"H\"</span>:\n \
      \         childclass <span class=\"sy0\">=</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'GPTlookAheadLeft'</span>;\n          <span class=\"kw2\">break</span>;\n\
      \      <span class=\"kw1\">default</span>:\n          <span class=\"kw3\">log</span><span\
      \ class=\"br0\">(</span> <span class=\"st0\">\" *gennode* Uh Oh! unknown token!\
      \ \"</span><span class=\"sy0\">$</span>childtype<span class=\"br0\">)</span>;\n\
      \          <span class=\"kw2\">break</span>;\n    <span class=\"br0\">}</span>\n\
      \   <span class=\"co1\">// log(\" childclass = \"$childclass);</span>\n    node\
      \ <span class=\"sy0\">=</span> gpnode<span class=\"br0\">(</span> <span class=\"\
      kw4\">spawn</span><span class=\"br0\">(</span>childclass<span class=\"br0\"\
      >)</span><span class=\"br0\">)</span>;\n    children<span class=\"br0\">[</span>i<span\
      \ class=\"br0\">]</span><span class=\"sy0\">=</span>node;\n    node.<span class=\"\
      me0\">mypawn</span> <span class=\"sy0\">=</span> mypawn;\n    node.<span class=\"\
      me0\">parent</span><span class=\"sy0\">=</span><span class=\"kw6\">self</span>;\n\
      \    node.<span class=\"me0\">childnum</span><span class=\"sy0\">=</span>i;\n\
      \    node.<span class=\"me0\">depth</span><span class=\"sy0\">=</span>depth<span\
      \ class=\"sy0\">+</span><span class=\"nu0\">1</span>;\n    <span class=\"kw2\"\
      >return</span><span class=\"br0\">(</span>node<span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p>... and the sands of time\
      \ draw a close to the first session editing this page... things are already\
      \ a lot clearer in my head thanks to explaining a little to you, dear reader...\
      \ till the next time I leave you with the remainder of the gpnode class which\
      \ deals with things like growing random sub trees and other housekeeping. You\
      \ can view the rest of the classes so far on CVS at the home of UTron on sourcefore\
      \ here: <a rel=\"nofollow\" class=\"external autonumber\" href=\"https://sourceforge.net/projects/utron/\"\
      >[1]</a> click on 'browse CVS' and look for classes in the package 'UTron' with\
      \ names beginning with GP.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">function</span> RandomGrow <span class=\"br0\">(</span> <span class=\"\
      kw5\">int</span> depth, <span class=\"kw5\">int</span> maxdepth <span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n<span class=\"kw1\">local</span>\
      \ <span class=\"kw5\">int</span> i,j,r;\n<span class=\"kw1\">local</span> <span\
      \ class=\"kw5\">string</span> <span class=\"kw5\">char</span>;\n<span class=\"\
      kw1\">local</span> GPnode node;\n  <span class=\"co1\">//log(\" random grow\
      \ called on \"$self@\"depth = \"$depth);</span>\n  <span class=\"kw2\">for</span>\
      \ <span class=\"br0\">(</span> i <span class=\"sy0\">=</span><span class=\"\
      nu0\">0</span>; i<span class=\"sy0\">&lt;</span>childcount;i<span class=\"sy0\"\
      >++</span><span class=\"br0\">)</span>\n  <span class=\"br0\">{</span>\n   <span\
      \ class=\"co1\">//log(\" randomgrow on \"$self$\"choosing child\"$i);</span>\n\
      \    <span class=\"kw2\">if</span><span class=\"br0\">(</span>depth <span class=\"\
      sy0\">==</span> maxdepth<span class=\"br0\">)</span> <span class=\"br0\">{</span>\n\
      \     <span class=\"co1\">// log(\"max depth reached\");</span>\n      <span\
      \ class=\"kw5\">char</span> <span class=\"sy0\">=</span> <span class=\"kw3\"\
      >mid</span><span class=\"br0\">(</span>terminators,<span class=\"kw3\">rand</span><span\
      \ class=\"br0\">(</span><span class=\"kw3\">len</span><span class=\"br0\">(</span>terminators<span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span>;\n  <span class=\"co1\">//    log(\"char = \"$char);</span>\n\
      \      node <span class=\"sy0\">=</span> addchild<span class=\"br0\">(</span><span\
      \ class=\"kw5\">char</span>,i<span class=\"br0\">)</span>;\n    <span class=\"\
      co1\">//  log(\"new terminator node = \"$node);</span>\n    <span class=\"br0\"\
      >}</span>\n    <span class=\"kw2\">else</span>\n      <span class=\"br0\">{</span>\n\
      \       <span class=\"kw2\">if</span><span class=\"br0\">(</span>depth <span\
      \ class=\"sy0\">&lt;</span><span class=\"nu0\">4</span><span class=\"br0\">)</span>\
      \ <span class=\"kw5\">char</span> <span class=\"sy0\">=</span> <span class=\"\
      kw3\">mid</span><span class=\"br0\">(</span>functions,<span class=\"kw3\">rand</span><span\
      \ class=\"br0\">(</span><span class=\"kw3\">len</span><span class=\"br0\">(</span>functions<span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span>; <span class=\"co1\">// add a bit of depth to start\
      \ with for testing</span>\n        <span class=\"kw2\">else</span> <span class=\"\
      kw5\">char</span> <span class=\"sy0\">=</span> <span class=\"kw3\">mid</span><span\
      \ class=\"br0\">(</span>alltypes,<span class=\"kw3\">rand</span><span class=\"\
      br0\">(</span><span class=\"kw3\">len</span><span class=\"br0\">(</span>alltypes<span\
      \ class=\"br0\">)</span><span class=\"br0\">)</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span>;\n      <span class=\"co1\">// log(\"char = \"$char);</span>\n\
      \       node <span class=\"sy0\">=</span> addchild<span class=\"br0\">(</span>\
      \ <span class=\"kw5\">char</span>,i<span class=\"br0\">)</span>;\n      <span\
      \ class=\"co1\">// log(\"new node = \"$node);</span>\n       <span class=\"\
      kw2\">if</span><span class=\"br0\">(</span>node.<span class=\"me0\">Childcount</span>\
      \ <span class=\"sy0\">&gt;</span><span class=\"nu0\">0</span><span class=\"\
      br0\">)</span>  node.<span class=\"me0\">RandomGrow</span><span class=\"br0\"\
      >(</span>depth<span class=\"sy0\">+</span><span class=\"nu0\">1</span>,maxdepth<span\
      \ class=\"br0\">)</span>;\n      <span class=\"br0\">}</span>\n  <span class=\"\
      br0\">}</span>\n \n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>RandomGrow\
      \ is the function that creates random trees for seeding the initial population\
      \ and for use in the genetic 'mutation' operation too. Note the plentiful commented\
      \ out log statments... no more than curious fossils now, they were useful in\
      \ the extreme when debugging this stuff, a comment after every line is usually\
      \ a sign that I was tracking down an accessed none... I really should get round\
      \ to deleting them&#160;:)</p>\n<p>Since there are currently quite a few more\
      \ terminal nodes defined that there are functions the tree had a habit of being\
      \ very small most of the time so you'll notice that I make sure that all nodes\
      \ up to depth 4 are chosen from the set of functions in order to give it a bit\
      \ of depth... strictly speaking this is biasing what should be a totally random\
      \ process, the fitness selection and evolution should take care of any runts,\
      \ so this will probably go once things are fully set up. For now though it's\
      \ a handy feature for testing.</p>\n<p>Sometimes we might need to prune off\
      \ the branch of a tree before replacing it with something else (like a branch\
      \ chosen randomly from a tree that performs well at our chosen task, or just\
      \ another random growth when mutating ) so the prune function recursively destroys\
      \ nodes below the one on which it is first called.</p>\n<p>It still feels a\
      \ little crufty, that first check on childcount should be redundant really as\
      \ the parent of any nodes with childcount == 0 will destroy them so that will\
      \ go soon methinks. In fact a more elegant system would have terminal nodes\
      \ destroy themselves but at the time I wasn't confident that a function in a\
      \ node that called that nodes destroy() function would actually return, so nodes\
      \ destroy their children instead (after having called prune on child nodes to\
      \ ensure that their children get destroyed in turn ).</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"kw1\">function</span> prune<span class=\"\
      br0\">(</span><span class=\"br0\">)</span>    <span class=\"co1\">// remove\
      \ objects below this node</span>\n<span class=\"br0\">{</span>\n  <span class=\"\
      kw1\">local</span> <span class=\"kw5\">int</span> i;\n  <span class=\"kw2\"\
      >if</span><span class=\"br0\">(</span>childcount <span class=\"sy0\">==</span>\
      \ <span class=\"nu0\">0</span> <span class=\"br0\">)</span> <span class=\"kw2\"\
      >return</span>;\n  <span class=\"kw2\">else</span>\n    <span class=\"kw2\"\
      >for</span><span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"\
      nu0\">0</span>;i<span class=\"sy0\">&lt;</span>childcount;i<span class=\"sy0\"\
      >++</span><span class=\"br0\">)</span>\n      <span class=\"kw2\">if</span><span\
      \ class=\"br0\">(</span>children<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span>.<span class=\"me0\">Childcount</span><span class=\"sy0\">==</span><span\
      \ class=\"nu0\">0</span><span class=\"br0\">)</span> children<span class=\"\
      br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"kw4\">Destroy</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n        <span class=\"\
      kw2\">else</span>\n           <span class=\"br0\">{</span>\n             children<span\
      \ class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me0\">prune</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n             children<span\
      \ class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"kw4\">Destroy</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n             children<span\
      \ class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">=</span><span\
      \ class=\"kw5\">none</span>;\n           <span class=\"br0\">}</span>\n  <span\
      \ class=\"kw2\">return</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>All of the tree manipulation functions used in creating new trees from an\
      \ exisiting one need to chose a node at random and then do stuff to it. So the\
      \ two functions below are used to:</p>\n<ol>\n<li>Count the nodes in the tree\
      \ so that correct range can be used when a random number is generated to pick\
      \ a node.</li>\n<li>Actually return a reference to that random node</li>\n</ol>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">function</span>\
      \ countnodes<span class=\"br0\">(</span><span class=\"kw1\">out</span> <span\
      \ class=\"kw5\">int</span> nodecount<span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n <span class=\"kw1\">local</span> <span class=\"kw5\">int</span>\
      \ i;\n <span class=\"co1\">//recursively count nodes in tree below this one</span>\n\
      \ nodecount <span class=\"sy0\">++</span>;\n <span class=\"kw2\">for</span>\
      \ <span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"nu0\"\
      >0</span>;i<span class=\"sy0\">&lt;</span>childcount;i<span class=\"sy0\">++</span><span\
      \ class=\"br0\">)</span>  children<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span>.<span class=\"me0\">countnodes</span><span class=\"br0\">(</span>nodecount<span\
      \ class=\"br0\">)</span>;\n <span class=\"kw2\">return</span>;\n<span class=\"\
      br0\">}</span>\n \n<span class=\"kw1\">function</span> gpnode findnode<span\
      \ class=\"br0\">(</span><span class=\"kw1\">out</span> <span class=\"kw5\">int</span>\
      \ nodenum<span class=\"br0\">)</span> \n<span class=\"br0\">{</span>\n  <span\
      \ class=\"kw1\">local</span> <span class=\"kw5\">int</span> i;\n  <span class=\"\
      kw1\">local</span> gpnode result;\n  nodenum <span class=\"sy0\">--</span>;\n\
      \  <span class=\"kw2\">if</span><span class=\"br0\">(</span>nodenum <span class=\"\
      sy0\">==</span><span class=\"nu0\">0</span><span class=\"br0\">)</span> <span\
      \ class=\"kw2\">return</span><span class=\"br0\">(</span><span class=\"kw6\"\
      >self</span><span class=\"br0\">)</span>;\n  <span class=\"kw2\">else</span>\n\
      \    <span class=\"br0\">{</span>\n       <span class=\"kw2\">for</span> <span\
      \ class=\"br0\">(</span>i<span class=\"sy0\">=</span><span class=\"nu0\">0</span>;i<span\
      \ class=\"sy0\">&lt;</span>childcount;i<span class=\"sy0\">++</span><span class=\"\
      br0\">)</span>\n         <span class=\"br0\">{</span>\n           result <span\
      \ class=\"sy0\">=</span> children<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span>.<span class=\"me0\">findnode</span><span class=\"br0\">(</span>nodenum<span\
      \ class=\"br0\">)</span>;\n           <span class=\"kw2\">if</span><span class=\"\
      br0\">(</span>result <span class=\"sy0\">!=</span> <span class=\"kw5\">none</span><span\
      \ class=\"br0\">)</span>\n              <span class=\"kw2\">return</span><span\
      \ class=\"br0\">(</span>result<span class=\"br0\">)</span>;\n         <span\
      \ class=\"br0\">}</span>\n       <span class=\"kw2\">return</span><span class=\"\
      br0\">(</span><span class=\"kw5\">none</span><span class=\"br0\">)</span>;\n\
      \    <span class=\"br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>last but not least, cloneme() spawns a duplicate of a node and all\
      \ the tree below it... yet more recursive majick&#160;:)</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"kw1\">function</span> gpnode cloneme<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"co1\">// clone this object, used recursively to duplicate subtrees</span>\n\
      \  <span class=\"kw1\">local</span> <span class=\"kw5\">int</span> i;\n  <span\
      \ class=\"kw1\">local</span> gpnode newnode;\n \n  newnode <span class=\"sy0\"\
      >=</span> <span class=\"kw4\">spawn</span><span class=\"br0\">(</span><span\
      \ class=\"kw1\">class</span><span class=\"br0\">)</span>;\n  <span class=\"\
      kw2\">for</span><span class=\"br0\">(</span>i<span class=\"sy0\">=</span><span\
      \ class=\"nu0\">0</span>;i<span class=\"sy0\">&lt;</span>childcount;i<span class=\"\
      sy0\">++</span><span class=\"br0\">)</span>\n    newnode.<span class=\"me0\"\
      >children</span><span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span\
      \ class=\"sy0\">=</span> children<span class=\"br0\">[</span>i<span class=\"\
      br0\">]</span>.<span class=\"me0\">cloneme</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n    newnode.<span class=\"me0\">mypawn</span><span\
      \ class=\"sy0\">=</span>mypawn;\n  <span class=\"kw2\">return</span><span class=\"\
      br0\">(</span>newnode<span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>The most interesting things in the deafult properties are the strings\
      \ which are used to hold lists of the tokens of the different types of nodes.\
      \ Add to these when new nodes are made (my current one character per token scheme\
      \ is nice and simple and I reckon if you find yourself running out of characters\
      \ as node types undergo runaway expansion you need to think again about how\
      \ much control you're willing to hand over to the evolution process... stick\
      \ to minimal building blocks and let complexity sort itself out... another lesson\
      \ from mr Turing&#160;:) )</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">DefaultProperties</span>\n<span class=\"br0\">{</span>\n<span class=\"\
      kw7\">DrawType</span><span class=\"sy0\">=</span><span class=\"kw7\">DT_none</span>\n\
      bCollideWorld<span class=\"sy0\">=</span><span class=\"kw6\">false</span>\n\
      bCollideActors<span class=\"sy0\">=</span><span class=\"kw6\">false</span>\n\
      bProjtarget<span class=\"sy0\">=</span><span class=\"kw6\">false</span>\nchildcount<span\
      \ class=\"sy0\">=</span><span class=\"nu0\">1</span>\nTerminators<span class=\"\
      sy0\">=</span><span class=\"st0\">\"RLKABCDEFGH\"</span>\nAllTypes<span class=\"\
      sy0\">=</span><span class=\"st0\">\"+-*%&lt;RLKABCDEFGHQNX\"</span>\nfunctions<span\
      \ class=\"sy0\">=</span><span class=\"st0\">\"+-*%&lt;QNX\"</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>So there you have it, the core node class.\
      \ But for this to do any good we need a way of storing 'genes' and keeping track\
      \ of which ones are doing well at our trials, as well as performing the actual\
      \ 'breeding' and mutation of those high performers. Find the class that does\
      \ this and further ramblings over at:</p>\n<p><a href=\"/Legacy:Genetic_Programming/Genes\"\
      \ title=\"Legacy:Genetic Programming/Genes\">Genetic Programming/Genes</a></p>\n\
      <h2><span class=\"mw-headline\" id=\"Your_Comments_Welcome\">Your Comments Welcome</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Genetic_Programming/Nodes?section=1\" title=\"Edit section:\
      \ Your Comments Welcome\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p><b>DJPaul:</b> Blimey.</p>\n<p><b>Zedsquared</b> heh! I'll take that as a\
      \ good 'Blimey' then&#160;;) food for thought I hope?</p>\n<p><b>Chazums:</b>\
      \ Strangely enough, just stumbled onto the idea of using this kind of thing\
      \ for AI today. Nicely written walk through, makes things clearer in my mind\
      \ too.</p>\n<p><b>Zedsquared</b> Cheers Chazums, glad my explanations make some\
      \ sense to you, here's a good link to a page full of such goodies (the whole\
      \ site is good for AI too) <a rel=\"nofollow\" class=\"external text\" href=\"\
      http://www.gameai.com/genetics.html\">GameAi.com</a></p>\n\n<!-- \nNewPP limit\
      \ report\nCPU time usage: 0.305 seconds\nReal time usage: 0.616 seconds\nPreprocessor\
      \ visited node count: 111/1000000\nPreprocessor generated node count: 248/1000000\n\
      Post‐expand include size: 0/2097152 bytes\nTemplate argument size: 0/2097152\
      \ bytes\nHighest expansion depth: 2/40\nExpensive parser function count: 0/100\n\
      -->\n\n<!-- \nTransclusion expansion time report (%,ms,calls,template)\n100.00%\
      \    0.000      1 - -total\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:1363-0!*!0!*!*!*!*\
      \ and timestamp 20221118161311 and revision id 3460\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:Genetic Programming/Genes"
  - ns: 100
    exists: true
    name: "Legacy:Genetic Programming"
  templates: []
  images: []
  externallinks:
  - "http://www.gameai.com/genetics.html"
  - "http://www.genetic-programming.com/gpanimatedtutorial.html"
  - "https://sourceforge.net/projects/utron/"
  sections:
  - toclevel: 1
    level: "2"
    line: "Your Comments Welcome"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Genetic_Programming/Nodes"
    byteoffset: 14411
    anchor: "Your_Comments_Welcome"
  displaytitle: "Legacy:Genetic Programming/Nodes"
  iwlinks: []
  wikitext:
    text: "First off, read the introduction on [[Legacy:Genetic Programming|Genetic\
      \ Programming]], and go look at the animated tutorial at [http://www.genetic-programming.com/gpanimatedtutorial.html\
      \ www.genetic-programming.com/gpanimatedtutorial.html] or all of this is all\
      \ going to be nonsense :)\n\nOK, by now you should know that GP uses a tree\
      \ structure of linked objects to do its 'thinking' these objects are either\
      \ 'Terminals' (i.e. 'leaves' at the end of the tree branches which return either\
      \ sensor input or constant values) or 'Functions' which take one or more values\
      \ and return another.\n\nIn my implimentation all nodes take and return floats\
      \ as arguments so it doesn't matter how much you mix things up, no node gets\
      \ presented with data it can't cope with.\n\nHere's a simple node that adds\
      \ together its two inputs:\n\n<uscript>\n//-----------------------------------------------------------\n\
      // arithmetic addition function\n//-----------------------------------------------------------\n\
      class GPFplus extends GPnode;\n\n\nfunction float evaluate()\n{\n  return( children[0].evaluate()\
      \ + children[1].evaluate());\n}\n\nfunction string makemytoken()\n{\n  return(\"\
      +\");\n}\n\n\nDefaultProperties\n{\n childcount=2\n}\n\n</uscript>\n\nIt extends\
      \ GPnode which is the base class of all the nodes and includes lots of baggage\
      \ to be explained later, for now just notice that the nodes below it in the\
      \ parse tree are referenced by the children[] array and that the evaluate method\
      \ is called on these children in order to get the values that need to be added\
      \ together. This is the basic magic, all the objects in the tree are linked\
      \ together and control flows down the branches until something that actually\
      \ returns a value is evaluated. Some nodes are conditional and branches get\
      \ evaluated or not depending on conditions... in this way we can produce a program\
      \ that actually varies its behavior according to conditions, unlike any of the\
      \ simple examples in the tutorial linked to above which are more like equations\
      \ than anything we'd call 'code'.\n\nAs an example here's evaluate for the 'less\
      \ than' node:\n\n<uscript>\n\nfunction float evaluate()\n{\n  local float arg1,arg2;\n\
      \  arg1=children[0].evaluate();\n  arg2=children[1].evaluate();\n  if(arg1<arg2)\
      \ return(children[2].evaluate());\n  else\n    return(children[3].evaluate());\n\
      }\n\n</uscript>\n\nNotice how sometimes children[2] gets evaluated and other\
      \ times it's children[3] that gets to see some action.\n\nNow in order to get\
      \ any of this to work we need a way of storing the tree so it can be passed\
      \ around and manipulated, this is where makemytoken() comes in, its job is to\
      \ return the string representation of that node... pretty simple here but nodes\
      \ which hold values need something more... here's evaluate and makemytoken for\
      \ the 'constant' terminal node:\n\n<uscript>\n\nvar float val;\n\nfunction float\
      \ evaluate()\n{\n    return(val);\n}\n\nfunction string makemytoken()\n{\n \
      \ return(\"K\"$val);\n}\n\n</uscript>\n\nAs you can see I use the character\
      \ K to flag a constant and then append the value to is using uscripts really\
      \ rather useful built in type conversions.\n\nEnough specifics, I hope that\
      \ conveys the gist, here's the core GPnode code in it's glory:\n\n<uscript>\n\
      \n//-----------------------------------------------------------\n// Genetic\
      \ Programming parse tree node root class\n//-----------------------------------------------------------\n\
      class GPnode extends Actor;\n\n\nVar int Childcount;\nvar GPnode children[4],\
      \ parent;\nvar int childnum, depth; // self = parent.chilren[childnum]\nvar\
      \ string mytoken;\nvar actor mypawn;            // might not be always be a\
      \ pawn, hence type = actor for now\nvar const string terminators, functions;\n\
      var const string alltypes;\n\n\nfunction float evaluate()\n{\n  return(children[0].evaluate());\n\
      }\n\n\n</uscript>\n\nVariables and a very empty evaluate method.\n\nNow more\
      \ recursion: this is how the tree gets written out as a string: the node writes\
      \ it's own token to the string then calls writetostring on its children, those\
      \ children in turn get their children to write a token to the string and so\
      \ on... somehow satisfyingly cool to someone like myself who's never been beyond\
      \ a simple recursive factiorial function before :)\n\n<uscript>\n\nfunction\
      \ WriteToString( out string genome )\n{\n local int i;\n genome = genome$MakeMyToken();\n\
      \ if(childcount == 0) return;\n else\n  {\n    for(i=0;i<childcount;i++)\n \
      \    {\n       children[i].WriteToString(genome);\n     }\n  }\n}\n\nfunction\
      \ string makemytoken()\n{\n//log(\"makemytoken called on \"$self);\n// null\
      \ token for base class, make this return the string that represents\n// any\
      \ subclass (mostly one char but constant terminators need to write out\n// their\
      \ value forinstance)\nreturn(\"\");\n}\n\n\n\n\n\n\n\n\n\n</uscript>\n\nNotice\
      \ also cunning use of an 'out' declaration there so all that needs to be done\
      \ to create the genome string is simply call WriteToString(s) on the root node\
      \ of the tree and as if by magic, S gets an encoded version of the object tree\
      \ written to it.. by now I'm really starting to grock recursion properly and\
      \ feel like I'm on a run, the elegence of these objects all describing themselves\
      \ is appealing but in the background I can't help wondering if it all might\
      \ fall apart somehow... \n\nDoubts or not, this is how most of the functionality\
      \ has shaped up, simply call a method on the root node and all else follows\
      \ for various tree manipulation tasks.\n\nNow having written this string we\
      \ neeed a way of reading it back in and creating an object tree out of it...\
      \ so let's go all recursive again and we have the imaginatively named:\n\n<uscript>\n\
      Function ReadFromString( out string genome)\n{\n  local int i;\n  local string\
      \ char;\n  local GPnode node;\n  for ( i =0; i<childcount;i++)\n  {\n    //\
      \ eat and analyse first (leftmost) char of string\n    \n    char = left(genome,1);\n\
      \    genome = right(genome,len(genome)-1);\n    node = addchild( char,i);\n\
      \    node.ReadFromString(genome);\n }\n}\n\n</uscript>\n\nSo basically you start\
      \ by spawning a gpnode as the root, feed it the string of gobbledegook generated\
      \ by writetostring and it reads (and discards) the first character, spawns the\
      \ appropriate node actor, makes that its first child and passes the rest of\
      \ the string to it so it can make any children it might need in turn... and\
      \ so it goes on down the tree.\n\nAddchild is a big switch that takes care of\
      \ spawning the right sort of node type according to the character token that\
      \ has been read in:\n\n<uscript>\n\n\nfunction gpnode addchild(string childtype,\
      \ int i)\n{\n  local class<actor>  childclass;\n  local gpnode node;\n\n   switch(childtype)\n\
      \   {\n    // functions first\n      case \"+\":\n          childclass = class'GPFplus';\n\
      \          break;\n      case \"-\":\n          childclass = class'GPFminus';\n\
      \          break;\n      case \"*\":\n          childclass = class'GPFmultiply';\n\
      \          break;\n      case \"%\":\n          childclass = class'GPFsafeDivide';\n\
      \          break;\n      case \"<\":\n          childclass = class'GPFlessThan';\n\
      \          break;\n      case \"Q\":\n          childclass = class'GPFSqrt';\n\
      \          break;\n      case \"N\":\n          childclass = class'GPFMin';\n\
      \          break;\n      case \"X\":\n          childclass = class'GPFMax';\n\
      \          break;\n      // then the terminators\n      case \"R\":\n      \
      \    childclass = class'GPFrightTurn';\n          break;\n      case \"L\":\n\
      \          childclass = class'GPFleftTurn';\n          break;\n      case \"\
      K\":\n          childclass = class'GPTconstant';\n          break;\n      case\
      \ \"A\":\n          childclass = class'GPTlookAhead';\n          break;\n  \
      \    case \"B\":\n          childclass = class'GPTlookAheadRight';\n       \
      \   break;\n      case \"C\":\n          childclass = class'GPTlookRight';\n\
      \          break;\n      case \"D\":\n          childclass = class'GPTlookBackRight';\n\
      \          break;\n      case \"E\":\n          childclass = class'GPTlookBack';\n\
      \          break;\n      case \"F\":\n          childclass = class'GPTlookBackLeft';\n\
      \          break;\n      case \"G\":\n          childclass = class'GPTlookLeft';\n\
      \          break;\n      case \"H\":\n          childclass = class'GPTlookAheadLeft';\n\
      \          break;\n      default:\n          log( \" *gennode* Uh Oh! unknown\
      \ token! \"$childtype);\n          break;\n    }\n   // log(\" childclass =\
      \ \"$childclass);\n    node = gpnode( spawn(childclass));\n    children[i]=node;\n\
      \    node.mypawn = mypawn;\n    node.parent=self;\n    node.childnum=i;\n  \
      \  node.depth=depth+1;\n    return(node);\n}\n\n</uscript>\n\n... and the sands\
      \ of time draw a close to the first session editing this page... things are\
      \ already a lot clearer in my head thanks to explaining a little to you, dear\
      \ reader... till the next time I leave you with the remainder of the gpnode\
      \ class which deals with things like growing random sub trees and other housekeeping.\
      \ You can view the rest of the classes so far on CVS at the home of UTron on\
      \ sourcefore here: [https://sourceforge.net/projects/utron/] click on 'browse\
      \ CVS' and look for classes in the package 'UTron' with names beginning with\
      \ GP.\n\n<uscript>\n\n\n\nfunction RandomGrow ( int depth, int maxdepth )\n\
      {\nlocal int i,j,r;\nlocal string char;\nlocal GPnode node;\n  //log(\" random\
      \ grow called on \"$self@\"depth = \"$depth);\n  for ( i =0; i<childcount;i++)\n\
      \  {\n   //log(\" randomgrow on \"$self$\"choosing child\"$i);\n    if(depth\
      \ == maxdepth) {\n     // log(\"max depth reached\");\n      char = mid(terminators,rand(len(terminators)),1);\n\
      \  //    log(\"char = \"$char);\n      node = addchild(char,i);\n    //  log(\"\
      new terminator node = \"$node);\n    }\n    else\n      {\n       if(depth <4)\
      \ char = mid(functions,rand(len(functions)),1); // add a bit of depth to start\
      \ with for testing\n        else char = mid(alltypes,rand(len(alltypes)),1);\n\
      \      // log(\"char = \"$char);\n       node = addchild( char,i);\n      //\
      \ log(\"new node = \"$node);\n       if(node.Childcount >0)  node.RandomGrow(depth+1,maxdepth);\n\
      \      }\n  }\n\n}\n\n</uscript>\n\nRandomGrow is the function that creates\
      \ random trees for seeding the initial population and for use in the genetic\
      \ 'mutation' operation too. Note the plentiful commented out log statments...\
      \ no more than curious fossils now, they were useful in the extreme when debugging\
      \ this stuff, a comment after every line is usually a sign that I was tracking\
      \ down an accessed none... I really should get round to deleting them :)\n\n\
      Since there are currently quite a few more terminal nodes defined that there\
      \ are functions the tree had a habit of being very small most of the time so\
      \ you'll notice that I make sure that all nodes up to depth 4 are chosen from\
      \ the set of functions in order to give it a bit of depth... strictly speaking\
      \ this is biasing what should be a totally random process, the fitness selection\
      \ and evolution should take care of any runts, so this will probably go once\
      \ things are fully set up. For now though it's a handy feature for testing.\n\
      \nSometimes we might need to prune off the branch of a tree before replacing\
      \ it with something else (like a branch chosen randomly from a tree that performs\
      \ well at our chosen task, or just another random growth when mutating ) so\
      \ the prune function recursively destroys nodes below the one on which it is\
      \ first called.\n\nIt still feels a little crufty, that first check on childcount\
      \ should be redundant really as the parent of any nodes with childcount == 0\
      \ will destroy them so that will go soon methinks. In fact a more elegant system\
      \ would have terminal nodes destroy themselves but at the time I wasn't confident\
      \ that a function in a node that called that nodes destroy() function  would\
      \ actually return, so nodes destroy their children instead (after having called\
      \ prune on child nodes to ensure that their children get destroyed in turn ).\n\
      \n<uscript>\n\nfunction prune()    // remove objects below this node\n{\n  local\
      \ int i;\n  if(childcount == 0 ) return;\n  else\n    for(i=0;i<childcount;i++)\n\
      \      if(children[i].Childcount==0) children[i].Destroy();\n        else\n\
      \           {\n             children[i].prune();\n             children[i].Destroy();\n\
      \             children[i]=none;\n           }\n  return;\n}\n\n</uscript>\n\n\
      All of the tree manipulation functions used in creating new trees from an exisiting\
      \ one need to chose a node at random and then do stuff to it. So the two functions\
      \ below are used to:\n# Count the nodes in the tree so that correct range can\
      \ be used when a random number is generated to pick a node.\n# Actually return\
      \ a reference to that random node\n\n<uscript>\nfunction countnodes(out int\
      \ nodecount)\n{\n local int i;\n //recursively count nodes in tree below this\
      \ one\n nodecount ++;\n for (i=0;i<childcount;i++)  children[i].countnodes(nodecount);\n\
      \ return;\n}\n\nfunction gpnode findnode(out int nodenum) \n{\n  local int i;\n\
      \  local gpnode result;\n  nodenum --;\n  if(nodenum ==0) return(self);\n  else\n\
      \    {\n       for (i=0;i<childcount;i++)\n         {\n           result = children[i].findnode(nodenum);\n\
      \           if(result != none)\n              return(result);\n         }\n\
      \       return(none);\n    }\n}\n\n\n</uscript>\n\nlast but not least, cloneme()\
      \ spawns a duplicate of a node and all the tree below it... yet more recursive\
      \ majick :)\n\n<uscript>\n\nfunction gpnode cloneme()\n{\n  // clone this object,\
      \ used recursively to duplicate subtrees\n  local int i;\n  local gpnode newnode;\n\
      \n  newnode = spawn(class);\n  for(i=0;i<childcount;i++)\n    newnode.children[i]\
      \ = children[i].cloneme();\n    newnode.mypawn=mypawn;\n  return(newnode);\n\
      }\n\n</uscript>\n\nThe most interesting things in the deafult properties are\
      \ the strings which are used to hold lists of the tokens of the different types\
      \ of nodes. Add to these when new nodes are made (my current one character per\
      \ token scheme is nice and simple and I reckon if you find yourself running\
      \ out of characters as node types undergo runaway expansion you need to think\
      \ again about how much control you're willing to hand over to the evolution\
      \ process... stick to minimal building blocks and let complexity sort itself\
      \ out... another lesson from mr Turing :) )\n\n<uscript>\n\nDefaultProperties\n\
      {\nDrawType=DT_none\nbCollideWorld=false\nbCollideActors=false\nbProjtarget=false\n\
      childcount=1\nTerminators=\"RLKABCDEFGH\"\nAllTypes=\"+-*%<RLKABCDEFGHQNX\"\n\
      functions=\"+-*%<QNX\"\n}\n\n</uscript>\n\nSo there you have it, the core node\
      \ class. But for this to do any good we need a way of storing 'genes' and keeping\
      \ track of which ones are doing well at our trials, as well as performing the\
      \ actual 'breeding' and mutation of those high performers. Find the class that\
      \ does this and further ramblings over at:\n\n[[Legacy:Genetic Programming/Genes|Genetic\
      \ Programming/Genes]]\n\n==Your Comments Welcome ==\n\n'''DJPaul:''' Blimey.\n\
      \n'''Zedsquared'''  heh!  I'll take that as a good 'Blimey' then ;) food for\
      \ thought I hope?\n\n'''Chazums:''' Strangely enough, just stumbled onto the\
      \ idea of using this kind of thing for AI today.  Nicely written walk through,\
      \ makes things clearer in my mind too.\n\n'''Zedsquared''' Cheers Chazums, glad\
      \ my explanations make some sense to you, here's a good link to a page full\
      \ of such goodies (the whole site is good for AI too) [http://www.gameai.com/genetics.html\
      \ GameAi.com]"
  properties: []
  revId: 3460
name: "Legacy:Genetic Programming/Nodes"
revision:
  revid: 3460
  parentid: 3461
  user: "Tarquin"
  timestamp: 1090745655.000000000
  comment: "*"
timestamp: 1668787841.444757000
