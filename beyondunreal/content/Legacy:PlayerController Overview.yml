---
parse:
  title: "Legacy:PlayerController Overview"
  text:
    text: "<p>A UT200x player is composed of a number of classes that all work together\
      \ to accept and process input from the player and handle collision with the\
      \ world. Bots use much the same system, so processing of AI also takes place\
      \ (for Bot-specific subclasses; more on that in a minute) within the same code.\
      \ What follows is an attempt to explain the different classes involved and how\
      \ they interact.</p>\n<p></p>\n<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\"\
      >\n<h2>Contents</h2>\n</div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a\
      \ href=\"#A_Quick_Nod_to_the_Controller_Class\"><span class=\"tocnumber\">1</span>\
      \ <span class=\"toctext\">A Quick Nod to the Controller Class</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-2\"><a href=\"#PlayerController\"><span class=\"\
      tocnumber\">2</span> <span class=\"toctext\">PlayerController</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-3\"><a href=\"#Views\"><span class=\"tocnumber\"\
      >3</span> <span class=\"toctext\">Views</span></a></li>\n<li class=\"toclevel-1\
      \ tocsection-4\"><a href=\"#Spectators\"><span class=\"tocnumber\">4</span>\
      \ <span class=\"toctext\">Spectators</span></a></li>\n<li class=\"toclevel-1\
      \ tocsection-5\"><a href=\"#Movement_and_Control\"><span class=\"tocnumber\"\
      >5</span> <span class=\"toctext\">Movement and Control</span></a>\n<ul>\n<li\
      \ class=\"toclevel-2 tocsection-6\"><a href=\"#Capturing_Player_Input\"><span\
      \ class=\"tocnumber\">5.1</span> <span class=\"toctext\">Capturing Player Input</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-7\"><a href=\"#Player_Movement_and_Replication\"\
      ><span class=\"tocnumber\">5.2</span> <span class=\"toctext\">Player Movement\
      \ and Replication</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-8\"\
      ><a href=\"#Related_Topics\"><span class=\"tocnumber\">6</span> <span class=\"\
      toctext\">Related Topics</span></a></li>\n<li class=\"toclevel-1 tocsection-9\"\
      ><a href=\"#Discussion\"><span class=\"tocnumber\">7</span> <span class=\"toctext\"\
      >Discussion</span></a></li>\n</ul>\n</div>\n<p></p>\n<h2><span class=\"mw-headline\"\
      \ id=\"A_Quick_Nod_to_the_Controller_Class\">A Quick Nod to the Controller Class</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:PlayerController_Overview?section=1\" title=\"Edit section:\
      \ A Quick Nod to the Controller Class\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Here's what the class header of Controller has to\
      \ say.</p>\n<blockquote class=\"legacyquote\">\n<p>Controllers are non-physical\
      \ actors that can be attached to a pawn to control its actions. PlayerControllers\
      \ are used by human players to control pawns, while AI Controllers implement\
      \ the artificial intelligence for the pawns they control. Controllers take control\
      \ of a pawn using their Possess() method, and relinquish control of the pawn\
      \ by calling UnPossess().</p>\n<p>Controllers receive notifications for many\
      \ of the events occuring for the Pawn they are controlling. This gives the controller\
      \ the opportunity to implement the behavior in response to this event, intercepting\
      \ the event and superceding the Pawn's default behavior.</p>\n</blockquote>\n\
      <p>Although a full discussion of the properties of Controller is beyond the\
      \ scope of this page there are a couple of interesting (to me anyway) properties\
      \ defined at this level.</p>\n<ul>\n<li>bGodMode - Set at this level it allows\
      \ computer controlled players to enter god mode.</li>\n<li>FovAngle - The controller's\
      \ field of view - allows bots to have wider FOV's. There's potential here for\
      \ some bot customisation for the competative, as some players use a non standard\
      \ FOV.</li>\n</ul>\n<h2><span class=\"mw-headline\" id=\"PlayerController\"\
      >PlayerController</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=2\" title=\"\
      Edit section: PlayerController\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>The PlayerController class is where the real action\
      \ happens as far as human players go. This class determines what the player\
      \ sees when in first person view and in third person view and how the \"camera\"\
      \ behaves. It handles things like view shaking and the display of fog. There\
      \ are also handling functions in there for force-feedback events and support\
      \ for more console commands than you can shake a stick at.</p>\n<p>The most\
      \ important thing to remember about the PlayerController is that it serves two\
      \ purposes. The controller's <b>ViewTarget</b> is responsible for driving the\
      \ location and rotation of the scene the player sees. The controller's <b>Pawn</b>\
      \ is the pawn that is actually controlled by the PlayerController class. They\
      \ do not have to reference the same <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\"\
      >Actor</a>.</p>\n<dl>\n<dd><b>Mychaeel:</b> What do you mean by the last sentence?</dd>\n\
      </dl>\n<dl>\n<dd><b>EntropicLqd:</b> When playing in the game the ViewTarget\
      \ is normally the same object as the controlled Pawn. This does not have to\
      \ be the case though, and it would be quite possible to set the ViewTarget to\
      \ an actor that's trailing the controller Pawn for example. I say that ... but\
      \ I've not tested it yet - hopefully I'll have the chance tonight. I should\
      \ be working on <a href=\"/Legacy:Customising_The_Player_View\" title=\"Legacy:Customising\
      \ The Player View\">Customising the Player View</a> tonight so I'll probably\
      \ cover it off in there. Watch this space so to speak.</dd>\n</dl>\n<dl>\n<dd><b>Mychaeel:</b>\
      \ Ah, that. Yes, it works. &#160;:)</dd>\n</dl>\n<p>The PlayerController and\
      \ the controlled Pawn are tied explicitly to each other. The controller receives\
      \ many events to do with the current state and actions of the Pawn it's controlling.\
      \ These <i>event functions</i> are actually invoked by the Pawn being controlled\
      \ as it moves through the world and interacts with it's environment. The following\
      \ code is fairly typical of the Pawn callbacks on offer. In the example below\
      \ if the Pawn has a controller then it is up to the controller to return the\
      \ view rotation. By <i>default</i> this will actually be the rotation of the\
      \ Pawn.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div\
      \ class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\"\
      >simulated</span> <span class=\"kw1\">function</span> <span class=\"kw5\">rotator</span>\
      \ GetViewRotation<span class=\"br0\">(</span><span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n\t<span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> <span class=\"kw9\">Controller</span> <span class=\"sy0\">==</span>\
      \ <span class=\"kw5\">None</span> <span class=\"br0\">)</span>\n\t\t<span class=\"\
      kw2\">return</span> <span class=\"kw7\">Rotation</span>;\n\t<span class=\"kw2\"\
      >return</span> <span class=\"kw9\">Controller</span>.<span class=\"me0\">GetViewRotation</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<h2><span class=\"mw-headline\" id=\"Views\">Views</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=3\"\
      \ title=\"Edit section: Views\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>The view you see as a player is driven by an event\
      \ defined at the PlayerController level. The function definition is shown below.</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">event</span> PlayerCalcView<span\
      \ class=\"br0\">(</span><span class=\"kw1\">out</span> <span class=\"kw9\">actor</span>\
      \ ViewActor, <span class=\"kw1\">out</span> <span class=\"kw5\">vector</span>\
      \ CameraLocation, <span class=\"kw1\">out</span> <span class=\"kw5\">rotator</span>\
      \ CameraRotation <span class=\"br0\">)</span></pre></div>\n</div>\n<p>The values\
      \ passed in ViewActor, CameraLocation, and CameraRotation are derived from an\
      \ alternate universe (I've not found where yet). In essence this function performs\
      \ the following steps.</p>\n<ul>\n<li>Calls the <i>SpecialCalcView()</i> function\
      \ on the Pawn (possibly the view target, possibly the currently possessed pawn).\
      \ This gives the Pawn an opportunity to construct a custom view based upon what\
      \ it sees. (used for remote control robots and stuff I guess - possibly even\
      \ the 'deemer although I've not looked). If this function calculates the view\
      \ the player sees then it should return true. NOTE: The Pawn's bSpecialCalcView\
      \ property must be true for this function to be called.</li>\n<li>If a special\
      \ view was not constructed by the pawn then the current view target of the controller\
      \ is checked to make sure it still exists or is not about to be deleted from\
      \ the world. If deletion is pending then a new view target is obtained.</li>\n\
      <li>If the current view target is the current \"Pawn\" associated with the controller\
      \ then either CalcBehindView() or CalcFirstPersonView() is called to produce\
      \ the camera location and rotation required.</li>\n<li>If the current view target\
      \ is the controller itself then the controller's rotation is used as the camera\
      \ rotation.</li>\n<li>If the current view target is a projectile then the camera\
      \ location is set to the view target's collision height, and the camera rotation\
      \ is set to that of the projectile being followed.</li>\n<li>If none of the\
      \ above conditions are met then the view target is checked to see if it is a\
      \ <a href=\"/Legacy:Pawn\" title=\"Legacy:Pawn\">Pawn</a>. If this is the case\
      \ then the following happens:\n<ul>\n<li>If we are a client of a networked game\
      \ and our view target is a player pawn then we use the location of the view\
      \ target and the rotation of the controller (it reduces the perception of lag\
      \ and allows you to look around in behind view).</li>\n<li>If are the server\
      \ (or running a standalone game) then both the location and rotation of the\
      \ view target is used.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>The Default Behaviour</li>\n\
      </ul>\n<p>So, lets examine the PlayerCalcView() function. I've reproduced it\
      \ here in its entirety as there are a couple of things worth noting about it.\
      \ I've taken the liberty of adding some additional comments to the code in order\
      \ to cover the things I think are important.</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\">  <span class=\"co1\">// If desired, call the possessed pawn's\
      \ own view calculation function.  If this function</span>\n  <span class=\"\
      co1\">// calculates the view the player should see then it must return true.\
      \  Otherwise the</span>\n  <span class=\"co1\">// calculated view will be replaced\
      \ by the usual view.</span>\n  <span class=\"kw2\">if</span><span class=\"br0\"\
      >(</span> <span class=\"kw9\">Pawn</span> <span class=\"sy0\">!=</span> <span\
      \ class=\"kw5\">None</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"\
      kw9\">Pawn</span>.<span class=\"me0\">bSpecialCalcView</span> <span class=\"\
      br0\">)</span> <span class=\"br0\">{</span>\n    <span class=\"co1\">// try\
      \ the 'special' calcview. This may return false if its not applicable, and we\
      \ do the usual.</span>\n    <span class=\"kw2\">if</span><span class=\"br0\"\
      >(</span> <span class=\"kw9\">Pawn</span>.<span class=\"me0\">SpecialCalcView</span><span\
      \ class=\"br0\">(</span>ViewActor, CameraLocation, CameraRotation<span class=\"\
      br0\">)</span> <span class=\"br0\">)</span>\n      <span class=\"kw2\">return</span>;\
      \ <span class=\"co1\">// EXIT point from function.</span>\n  <span class=\"\
      br0\">}</span>\n \n  <span class=\"co1\">// If the controller does not have\
      \ a view target, or, it's view target is about to be removed from</span>\n \
      \ <span class=\"co1\">// the level then we need to get one.</span>\n  <span\
      \ class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"br0\">(</span>ViewTarget\
      \ <span class=\"sy0\">==</span> <span class=\"kw5\">None</span><span class=\"\
      br0\">)</span> <span class=\"sy0\">||</span> ViewTarget.<span class=\"me0\"\
      >bDeleteMe</span> <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n\
      \    <span class=\"kw2\">if</span> <span class=\"br0\">(</span> bViewBot <span\
      \ class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">(</span><span class=\"\
      kw8\">CheatManager</span> <span class=\"sy0\">!=</span> <span class=\"kw5\"\
      >None</span><span class=\"br0\">)</span> <span class=\"br0\">)</span>\n    \
      \  <span class=\"kw8\">CheatManager</span>.<span class=\"me0\">ViewBot</span><span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>;\n    <span class=\"kw2\"\
      >else</span> <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span\
      \ class=\"br0\">(</span><span class=\"kw9\">Pawn</span> <span class=\"sy0\"\
      >!=</span> <span class=\"kw5\">None</span><span class=\"br0\">)</span> <span\
      \ class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span><span class=\"\
      kw9\">Pawn</span>.<span class=\"me0\">bDeleteMe</span> <span class=\"br0\">)</span>\n\
      \      SetViewTarget<span class=\"br0\">(</span><span class=\"kw9\">Pawn</span><span\
      \ class=\"br0\">)</span>;\n    <span class=\"kw2\">else</span>\n      SetViewTarget<span\
      \ class=\"br0\">(</span><span class=\"kw6\">self</span><span class=\"br0\">)</span>;\n\
      \  <span class=\"br0\">}</span>\n \n  ViewActor <span class=\"sy0\">=</span>\
      \ ViewTarget;               <span class=\"co1\">// Set the output variable ViewActor\
      \ with the new view target</span>\n  CameraLocation <span class=\"sy0\">=</span>\
      \ ViewTarget.<span class=\"kw7\">Location</span>; <span class=\"co1\">// Set\
      \ the output variable CameraLocation with the view targets location</span>\n\
      \ \n  <span class=\"co1\">// If the view target of the controller is the currently\
      \ possessed pawn then the</span>\n  <span class=\"co1\">// calculation of the\
      \ view the player sees is deferred to the first person and</span>\n  <span class=\"\
      co1\">// behind view calculation functions.</span>\n  <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> ViewTarget <span class=\"sy0\">==</span> <span\
      \ class=\"kw9\">Pawn</span> <span class=\"br0\">)</span>\n  <span class=\"br0\"\
      >{</span>\n    <span class=\"kw2\">if</span><span class=\"br0\">(</span> bBehindView\
      \ <span class=\"br0\">)</span> <span class=\"co1\">//up and behind</span>\n\
      \      CalcBehindView<span class=\"br0\">(</span>CameraLocation, CameraRotation,\
      \ CameraDist <span class=\"sy0\">*</span> <span class=\"kw9\">Pawn</span>.<span\
      \ class=\"kw1\">Default</span>.<span class=\"kw7\">CollisionRadius</span><span\
      \ class=\"br0\">)</span>;\n    <span class=\"kw2\">else</span>\n      CalcFirstPersonView<span\
      \ class=\"br0\">(</span> CameraLocation, CameraRotation <span class=\"br0\"\
      >)</span>;\n    <span class=\"kw2\">return</span>; <span class=\"co1\">// EXIT\
      \ point from function</span>\n  <span class=\"br0\">}</span>\n \n  <span class=\"\
      co1\">// When all else fails the view target of the controller is itself.  If\
      \ the camera</span>\n  <span class=\"co1\">// position is locked then a fixed\
      \ rotation is used.  If not then the output variable</span>\n  <span class=\"\
      co1\">// is set to the controller's rotation. </span>\n  <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> ViewTarget <span class=\"sy0\">==</span>\
      \ <span class=\"kw6\">self</span> <span class=\"br0\">)</span> <span class=\"\
      br0\">{</span>\n    <span class=\"kw2\">if</span> <span class=\"br0\">(</span>\
      \ bCameraPositionLocked <span class=\"br0\">)</span>\n      CameraRotation <span\
      \ class=\"sy0\">=</span> <span class=\"kw8\">CheatManager</span>.<span class=\"\
      me0\">LockedRotation</span>;\n    <span class=\"kw2\">else</span>\n      CameraRotation\
      \ <span class=\"sy0\">=</span> <span class=\"kw7\">Rotation</span>;\n    <span\
      \ class=\"kw2\">return</span>; <span class=\"co1\">// EXIT point from function</span>\n\
      \  <span class=\"br0\">}</span>\n \n  <span class=\"co1\">// If we are watching\
      \ a projectile and we are in first person view then raise the camera</span>\n\
      \  <span class=\"co1\">// vertically upwards by the projectiles collision height.\
      \  The camera rotation is set to</span>\n  <span class=\"co1\">// the rotation\
      \ of the controller.</span>\n  <span class=\"kw2\">if</span> <span class=\"\
      br0\">(</span> ViewTarget.<span class=\"kw3\">IsA</span><span class=\"br0\"\
      >(</span><span class=\"st0\">'Projectile'</span><span class=\"br0\">)</span>\
      \ <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>bBehindView\
      \ <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n    CameraLocation\
      \ <span class=\"sy0\">+=</span> <span class=\"br0\">(</span>ViewTarget.<span\
      \ class=\"kw7\">CollisionHeight</span><span class=\"br0\">)</span> <span class=\"\
      sy0\">*</span> <span class=\"kw3\">vect</span><span class=\"br0\">(</span><span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span>;\n    CameraRotation <span class=\"sy0\">=</span> <span\
      \ class=\"kw7\">Rotation</span>;\n    <span class=\"kw2\">return</span>; <span\
      \ class=\"co1\">// EXIT point from function</span>\n  <span class=\"br0\">}</span>\n\
      \ \n  <span class=\"co1\">// Set the camera rotation to the rotation of the\
      \ current view target.</span>\n  CameraRotation <span class=\"sy0\">=</span>\
      \ ViewTarget.<span class=\"kw7\">Rotation</span>;\n \n  PTarget <span class=\"\
      sy0\">=</span> <span class=\"kw9\">Pawn</span><span class=\"br0\">(</span>ViewTarget<span\
      \ class=\"br0\">)</span>;\n  <span class=\"kw2\">if</span> <span class=\"br0\"\
      >(</span> PTarget <span class=\"sy0\">!=</span> <span class=\"kw5\">None</span>\
      \ <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n    <span class=\"\
      co1\">// If the view target is a pawn, and we are a client of a networked</span>\n\
      \    <span class=\"co1\">// game then we need to do some additional processing</span>\n\
      \    <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      kw7\">Level</span>.<span class=\"me0\">NetMode</span> <span class=\"sy0\">==</span>\
      \ NM_Client <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n    \
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> PTarget.<span\
      \ class=\"me0\">IsPlayerPawn</span><span class=\"br0\">(</span><span class=\"\
      br0\">)</span> <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n \
      \       <span class=\"co1\">// If we are looking at a player pawn then the view\
      \ rotation</span>\n        <span class=\"co1\">// is set to the TargetViewRotation\
      \ (how the TargetViewRotation</span>\n        <span class=\"co1\">// is set\
      \ is a mystery).  The view target's rotation is also set</span>\n        <span\
      \ class=\"co1\">// to this value.</span>\n        PTarget.<span class=\"me0\"\
      >SetViewRotation</span><span class=\"br0\">(</span>TargetViewRotation<span class=\"\
      br0\">)</span>;\n        CameraRotation <span class=\"sy0\">=</span> TargetViewRotation;\n\
      \      <span class=\"br0\">}</span>\n \n      <span class=\"co1\">// Adjust\
      \ the view targets eye height.</span>\n      PTarget.<span class=\"me0\">EyeHeight</span>\
      \ <span class=\"sy0\">=</span> TargetEyeHeight;\n      <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> PTarget.<span class=\"kw9\">Weapon</span> <span\
      \ class=\"sy0\">!=</span> <span class=\"kw5\">None</span> <span class=\"br0\"\
      >)</span>\n        PTarget.<span class=\"kw9\">Weapon</span>.<span class=\"\
      me0\">PlayerViewOffset</span> <span class=\"sy0\">=</span> TargetWeaponViewOffset;\n\
      \    <span class=\"br0\">}</span>\n    <span class=\"kw2\">else</span> <span\
      \ class=\"kw2\">if</span> <span class=\"br0\">(</span> PTarget.<span class=\"\
      me0\">IsPlayerPawn</span><span class=\"br0\">(</span><span class=\"br0\">)</span>\
      \ <span class=\"br0\">)</span>\n      CameraRotation <span class=\"sy0\">=</span>\
      \ PTarget.<span class=\"me0\">GetViewRotation</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n \n    <span class=\"co1\">// If we are not in behind\
      \ view then the position the camera location</span>\n    <span class=\"co1\"\
      >// at the view target's eye height.</span>\n    <span class=\"kw2\">if</span>\
      \ <span class=\"br0\">(</span> <span class=\"sy0\">!</span>bBehindView <span\
      \ class=\"br0\">)</span>\n      CameraLocation <span class=\"sy0\">+=</span>\
      \ PTarget.<span class=\"me0\">EyePosition</span><span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>;\n  <span class=\"br0\">}</span>\n \n  <span class=\"\
      co1\">// This is the view calculations used to determine the \"behind view\"\
      \ when</span>\n  <span class=\"co1\">// the View Target is not the same as the\
      \ Possessed pawn.</span>\n  <span class=\"kw2\">if</span> <span class=\"br0\"\
      >(</span> bBehindView <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n\
      \    CameraLocation <span class=\"sy0\">=</span> CameraLocation <span class=\"\
      sy0\">+</span> <span class=\"br0\">(</span>ViewTarget.<span class=\"kw1\">Default</span>.<span\
      \ class=\"kw7\">CollisionHeight</span> <span class=\"sy0\">-</span> ViewTarget.<span\
      \ class=\"kw7\">CollisionHeight</span><span class=\"br0\">)</span> <span class=\"\
      sy0\">*</span> <span class=\"kw3\">vect</span><span class=\"br0\">(</span><span\
      \ class=\"nu0\">0</span>,<span class=\"nu0\">0</span>,<span class=\"nu0\">1</span><span\
      \ class=\"br0\">)</span>;\n    CalcBehindView<span class=\"br0\">(</span>CameraLocation,\
      \ CameraRotation, CameraDist <span class=\"sy0\">*</span> ViewTarget.<span class=\"\
      kw1\">Default</span>.<span class=\"kw7\">CollisionRadius</span><span class=\"\
      br0\">)</span>;\n  <span class=\"br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p><b>OlympusMons:</b> I took this from <a rel=\"nofollow\" class=\"\
      external free\" href=\"http://wiki.beyondunreal.com/wiki/Customising_The_Player_View\"\
      >http://wiki.beyondunreal.com/wiki/Customising_The_Player_View</a> and put it\
      \ here I though this was a better place.</p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Spectators\">Spectators</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=4\"\
      \ title=\"Edit section: Spectators\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Spectating is also handled by the PlayerController\
      \ class. A state hierarchy is used to enabled and disabled various player functions\
      \ and generally keep things tidy. The hierarchy is shown below.</p>\n<pre> BaseSpectating\n\
      \   +- Spectating\n   |    +- AttractMode (also defined in xGame.xPlayer)\n\
      \   +- PlayerWaiting\n   +- WaitingForPawn\n</pre>\n<p>If you spend any time\
      \ looking through the spectating code (which does more or less what you'd expect)\
      \ you'll notice something really odd. A pathalogical desire to set the view\
      \ target.</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n\
      <div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"co1\"\
      >// Spectating - AltFire() calls ServerViewSelf() to return to your corpse (if\
      \ you've been killed or whatever)</span>\n \n<span class=\"co1\">// ServerViewSelf()\
      \ does the following:</span>\n    SetViewTarget<span class=\"br0\">(</span><span\
      \ class=\"kw6\">self</span><span class=\"br0\">)</span>;\n    ClientSetViewTarget<span\
      \ class=\"br0\">(</span><span class=\"kw6\">self</span><span class=\"br0\">)</span>;\n\
      \ \n<span class=\"co1\">// ClientSetViewTarget() is defined as:</span>\n<span\
      \ class=\"kw1\">function</span> ClientSetViewTarget<span class=\"br0\">(</span>\
      \ <span class=\"kw9\">Actor</span> a <span class=\"br0\">)</span>\n<span class=\"\
      br0\">{</span>\n    SetViewTarget<span class=\"br0\">(</span> a <span class=\"\
      br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n<p>In fact,\
      \ every call to ClientSetViewTarget( target ) is preceded with a call to SetViewTarget(\
      \ target ). Is this simply an example of redundant code within the code base\
      \ or something more sinister? I'll leave it up to the reader to decide.</p>\n\
      <p><b>DaWrecka</b>: More likely this is code that executes on the server. SetViewTarget()\
      \ sets the server's copy of ViewTarget, but the client needs to have it updated;\
      \ Hence the code calls ClientSetViewTarget(), which is replicated to the client\
      \ and updates the client's side to match the server's. The presence of ClientSetViewTarget()\
      \ in the replication block under \"reliable if(Role == ROLE_Authority)\" would\
      \ seem to back me up.</p>\n<h2><span class=\"mw-headline\" id=\"Movement_and_Control\"\
      >Movement and Control</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=5\" title=\"\
      Edit section: Movement and Control\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Player movement and control can be split into two\
      \ sections. The first is capturing input from the player and doing stuff with\
      \ it. The second is ensuring that the player's position in the world is consistent\
      \ between the client and the server.</p>\n<h3><span class=\"mw-headline\" id=\"\
      Capturing_Player_Input\">Capturing Player Input</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=6\"\
      \ title=\"Edit section: Capturing Player Input\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>There are two classes shipped with UT2003 responsible\
      \ for handling the player's input, and managing the <i>input configuration</i>.\
      \ Both of these are in the Engine class. The two classes are shown below.</p>\n\
      <pre>Engine.<a href=\"/Legacy:PlayerInput\" title=\"Legacy:PlayerInput\">PlayerInput</a>\n\
      \   +- Engine.<a href=\"/edit/Legacy:XBoxPlayerInput?redlink=1\" class=\"new\"\
      \ title=\"Legacy:XBoxPlayerInput (page does not exist)\">XBoxPlayerInput</a>\n\
      </pre>\n<p>The PlayerInput class is defined as being <i>within PlayerController</i>.\
      \ This means that the class has visibility of the attributes of the PlayerController\
      \ class. These classes only exist on the client. The entry points into the PlayerInput\
      \ class from a handling point of view are shown below.</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"co1\">// This function is called from PlayerController.PlayerTick(\
      \ float DeltaTime )</span>\n<span class=\"co1\">// to figure out what the player\
      \ is up to.</span>\n<span class=\"kw1\">event</span> <span class=\"kw8\">PlayerInput</span><span\
      \ class=\"br0\">(</span> <span class=\"kw5\">float</span> DeltaTime <span class=\"\
      br0\">)</span>\n \n<span class=\"co1\">// This function is called from PlayerController.PlayerMove(\
      \ float DeltaTime )</span>\n<span class=\"co1\">// it determines whether the\
      \ player is dodging and if so, in which direction.</span>\n<span class=\"kw1\"\
      >function</span> <span class=\"kw9\">Actor</span>.<span class=\"me0\">eDoubleClickDir</span>\
      \ CheckForDoubleClickMove<span class=\"br0\">(</span><span class=\"kw5\">float</span>\
      \ DeltaTime<span class=\"br0\">)</span></pre></div>\n</div>\n<p><i>It's pretty\
      \ arcane in there. The logic within the double click move function is particularly\
      \ tortuous. I'll need sleep before tackling that one.</i></p>\n<h3><span class=\"\
      mw-headline\" id=\"Player_Movement_and_Replication\">Player Movement and Replication</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:PlayerController_Overview?section=7\" title=\"Edit section:\
      \ Player Movement and Replication\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<blockquote class=\"legacyquote\">\n<p><b>Mychaeel:</b>\
      \ Player movement replication roughly works like this: Locally, the player moves\
      \ freely, and the client sends information about that to the server. The server\
      \ then tries to replay those moves when it receives them, and then sends information\
      \ back to the client on whether the movements worked out or not (and, if not,\
      \ where the player actually is right now). That way you don't experience any\
      \ lag in your own movement when playing on a game server unless you interact\
      \ with conflicting dynamic objects (for instance, other players or movers or\
      \ projectiles).</p>\n</blockquote>\n<p>Here's what the PlayerController class\
      \ has to say about the player's movement replication. It's a good summary of\
      \ exactly what is going on.</p>\n<blockquote class=\"legacyquote\">\n<p>Here's\
      \ how player movement prediction, replication and correction works in network\
      \ games:</p>\n</blockquote>\n<blockquote class=\"legacyquote\">\n<p>Every tick,\
      \ the PlayerTick() function is called. It calls the PlayerMove() function (which\
      \ is implemented in various states). PlayerMove() figures out the acceleration\
      \ and rotation, and then calls ProcessMove() (for single player or listen servers),\
      \ or ReplicateMove() (if its a network client).</p>\n</blockquote>\n<blockquote\
      \ class=\"legacyquote\">\n<p>ReplicateMove() saves the move (in the PendingMove\
      \ list), calls ProcessMove(), and then replicates the move to the server by\
      \ calling the replicated function ServerMove() - passing the movement parameters,\
      \ the client's resultant position, and a timestamp.</p>\n</blockquote>\n<blockquote\
      \ class=\"legacyquote\">\n<p>ServerMove() is executed on the server. It decodes\
      \ the movement parameters and causes the appropriate movement to occur. It then\
      \ looks at the resulting position and if enough time has passed since the last\
      \ response, or the position error is significant enough, the server calls ClientAdjustPosition(),\
      \ a replicated function.</p>\n</blockquote>\n<blockquote class=\"legacyquote\"\
      >\n<p>ClientAdjustPosition() is executed on the client. The client sets its\
      \ position to the servers version of position, and sets the bUpdatePosition\
      \ flag to true.</p>\n</blockquote>\n<blockquote class=\"legacyquote\">\n<p>When\
      \ PlayerTick() is called on the client again, if bUpdatePosition is true, the\
      \ client will call ClientUpdatePosition() before calling PlayerMove(). ClientUpdatePosition()\
      \ replays all the moves in the pending move list which occured after the timestamp\
      \ of the move the server was adjusting.</p>\n</blockquote>\n<p>I guess the above\
      \ comments really beg the question, \"How exactly do replicated functions work\
      \ then?\".</p>\n<h2><span class=\"mw-headline\" id=\"Related_Topics\">Related\
      \ Topics</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:PlayerController_Overview?section=8\" title=\"\
      Edit section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:Controller_Overview\" title=\"\
      Legacy:Controller Overview\">Controller Overview</a></li>\n<li><a href=\"/Legacy:Creating_An_Interaction_From_A_PlayerController\"\
      \ title=\"Legacy:Creating An Interaction From A PlayerController\">Creating\
      \ an Interaction from a PlayerController</a></li>\n<li><a href=\"/Legacy:Customising_The_Player_View\"\
      \ title=\"Legacy:Customising The Player View\">Customising the Player View</a></li>\n\
      </ul>\n<h2><span class=\"mw-headline\" id=\"Discussion\">Discussion</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:PlayerController_Overview?section=9\" title=\"Edit section:\
      \ Discussion\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p><b>OlympusMons:</b> Ok I put all the stuff that was on the player controller\
      \ page here for an overview similar to <a href=\"/Legacy:Controller_Overview\"\
      \ title=\"Legacy:Controller Overview\">Controller Overview</a>. This is probably\
      \ temporary until the <a href=\"/Legacy:PlayerController\" title=\"Legacy:PlayerController\"\
      >PlayerController</a> page can be brought to standard formatting. If I was wrong\
      \ in doing this please fix this&#160;;)</p>\n<p><b>SuperApe:</b> Looks pretty\
      \ good for the most part.</p>\n<hr />\n<p><a href=\"/Category:Legacy_Refactor_Me\"\
      \ title=\"Category:Legacy Refactor Me\">Category:Legacy Refactor Me</a> – Some\
      \ things here just need a little careful organization.</p>\n\n<!-- \nNewPP limit\
      \ report\nCPU time usage: 0.166 seconds\nReal time usage: 0.337 seconds\nPreprocessor\
      \ visited node count: 169/1000000\nPreprocessor generated node count: 341/1000000\n\
      Post‐expand include size: 6079/2097152 bytes\nTemplate argument size: 2643/2097152\
      \ bytes\nHighest expansion depth: 3/40\nExpensive parser function count: 0/100\n\
      -->\n\n<!-- \nTransclusion expansion time report (%,ms,calls,template)\n100.00%\
      \  192.853      1 - -total\n 10.33%   19.914      8 - Template:Innerbox\n-->\n\
      \n<!-- Saved in parser cache with key wiki:pcache:idhash:2546-0!*!0!!en!*!*\
      \ and timestamp 20221117210515 and revision id 6087\n -->\n"
  categories:
  - sortkey: "PlayerController Overview"
    name: "Legacy_Refactor_Me"
  links:
  - ns: 100
    exists: true
    name: "Legacy:Pawn"
  - ns: 100
    exists: true
    name: "Legacy:PlayerInput"
  - ns: 100
    exists: true
    name: "Legacy:PlayerController"
  - ns: 100
    exists: false
    name: "Legacy:XBoxPlayerInput"
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  - ns: 100
    exists: true
    name: "Legacy:Creating An Interaction From A PlayerController"
  - ns: 14
    exists: true
    name: "Category:Legacy Refactor Me"
  - ns: 100
    exists: true
    name: "Legacy:Controller Overview"
  - ns: 100
    exists: true
    name: "Legacy:Customising The Player View"
  templates:
  - ns: 10
    exists: true
    name: "Template:Innerbox"
  images: []
  externallinks:
  - "http://wiki.beyondunreal.com/wiki/Customising_The_Player_View"
  sections:
  - toclevel: 1
    level: "2"
    line: "A Quick Nod to the Controller Class"
    number: "1"
    index: "1"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 396
    anchor: "A_Quick_Nod_to_the_Controller_Class"
  - toclevel: 1
    level: "2"
    line: "PlayerController"
    number: "2"
    index: "2"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 1599
    anchor: "PlayerController"
  - toclevel: 1
    level: "2"
    line: "Views"
    number: "3"
    index: "3"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 3778
    anchor: "Views"
  - toclevel: 1
    level: "2"
    line: "Spectators"
    number: "4"
    index: "4"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 10476
    anchor: "Spectators"
  - toclevel: 1
    level: "2"
    line: "Movement and Control"
    number: "5"
    index: "5"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 12022
    anchor: "Movement_and_Control"
  - toclevel: 2
    level: "3"
    line: "Capturing Player Input"
    number: "5.1"
    index: "6"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 12294
    anchor: "Capturing_Player_Input"
  - toclevel: 2
    level: "3"
    line: "Player Movement and Replication"
    number: "5.2"
    index: "7"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 13489
    anchor: "Player_Movement_and_Replication"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "6"
    index: "8"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 15887
    anchor: "Related_Topics"
  - toclevel: 1
    level: "2"
    line: "Discussion"
    number: "7"
    index: "9"
    fromtitle: "Legacy:PlayerController_Overview"
    byteoffset: 16138
    anchor: "Discussion"
  displaytitle: "Legacy:PlayerController Overview"
  iwlinks: []
  wikitext:
    text: "A UT200x player is composed of a number of classes that all work together\
      \ to accept and process input from the player and handle collision with the\
      \ world.  Bots use much the same system, so processing of AI also takes place\
      \ (for Bot-specific subclasses; more on that in a minute) within the same code.\
      \  What follows is an attempt to explain the different classes involved and\
      \ how they interact.\n\n==A Quick Nod to the Controller Class ==\n\nHere's what\
      \ the class header of Controller has to say.\n\n{{innerbox|Controllers are non-physical\
      \ actors that can be attached to a pawn to control its actions.  PlayerControllers\
      \ are used by human players to control pawns, while AI Controllers implement\
      \ the artificial intelligence for the pawns they control.  Controllers take\
      \ control of a pawn using their Possess() method, and relinquish control of\
      \ the pawn by calling UnPossess().\n\nControllers receive notifications for\
      \ many of the events occuring for the Pawn they are controlling.  This gives\
      \ the controller the opportunity to implement the behavior in response to this\
      \ event, intercepting the event and superceding the Pawn's default behavior.\
      \  \n\n}}\n\nAlthough a full discussion of the properties of Controller is beyond\
      \ the scope of this page there are a couple of interesting (to me anyway) properties\
      \ defined at this level.\n* bGodMode - Set at this level it allows computer\
      \ controlled players to enter god mode.\n* FovAngle - The controller's field\
      \ of view - allows bots to have wider FOV's.  There's potential here for some\
      \ bot customisation for the competative, as some players use a non standard\
      \ FOV.\n\n==PlayerController==\n\nThe PlayerController class is where the real\
      \ action happens as far as human players go.  This class determines what the\
      \ player sees when in first person view and in third person view and how the\
      \ \"camera\" behaves.  It handles things like view shaking and the display of\
      \ fog.  There are also handling functions in there for force-feedback events\
      \ and support for more console commands than you can shake a stick at.\n\nThe\
      \ most important thing to remember about the PlayerController is that it serves\
      \ two purposes.  The controller's '''ViewTarget''' is responsible for driving\
      \ the location and rotation of the scene the player sees.  The controller's\
      \ '''Pawn''' is the pawn that is actually controlled by the PlayerController\
      \ class.  They do not have to reference the same [[Legacy:Actor|Actor]].\n\n\
      :'''Mychaeel:''' What do you mean by the last sentence?\n\n:'''EntropicLqd:'''\
      \ When playing in the game the ViewTarget is normally the same object as the\
      \ controlled Pawn.  This does not have to be the case though, and it would be\
      \ quite possible to set the ViewTarget to an actor that's trailing the controller\
      \ Pawn for example.  I say that ... but I've not tested it yet - hopefully I'll\
      \ have the chance tonight.  I should be working on [[Legacy:Customising The\
      \ Player View|Customising the Player View]] tonight so I'll probably cover it\
      \ off in there.  Watch this space so to speak.\n\n:'''Mychaeel:''' Ah, that.\
      \  Yes, it works.  :)\n\nThe PlayerController and the controlled Pawn are tied\
      \ explicitly to each other.  The controller receives many events to do with\
      \ the current state and actions of the Pawn it's controlling.  These ''event\
      \ functions'' are actually invoked by the Pawn being controlled as it moves\
      \ through the world and interacts with it's environment.  The following code\
      \ is fairly typical of the Pawn callbacks on offer.  In the example below if\
      \ the Pawn has a controller then it is up to the controller to return the view\
      \ rotation.  By ''default'' this will actually be the rotation of the Pawn.\n\
      \n<uscript>\nsimulated function rotator GetViewRotation()\n{\n\tif ( Controller\
      \ == None )\n\t\treturn Rotation;\n\treturn Controller.GetViewRotation();\n\
      }\n</uscript>\n\n==Views==\n\nThe view you see as a player is driven by an event\
      \ defined at the PlayerController level.  The function definition is shown below.\n\
      \n<uscript>\nevent PlayerCalcView(out actor ViewActor, out vector CameraLocation,\
      \ out rotator CameraRotation )\n</uscript>\n\nThe values passed in ViewActor,\
      \ CameraLocation, and CameraRotation are derived from an alternate universe\
      \ (I've not found where yet).  In essence this function performs the following\
      \ steps.\n* Calls the ''SpecialCalcView()'' function on the Pawn (possibly the\
      \ view target, possibly the currently possessed pawn).  This gives the Pawn\
      \ an opportunity to construct a custom view based upon what it sees.  (used\
      \ for remote control robots and stuff I guess - possibly even the 'deemer although\
      \ I've not looked).  If this function calculates the view the player sees then\
      \ it should return true.  NOTE: The Pawn's bSpecialCalcView property must be\
      \ true for this function to be called.\n* If a special view was not constructed\
      \ by the pawn then the current view target of the controller is checked to make\
      \ sure it still exists or is not about to be deleted from the world.  If deletion\
      \ is pending then a new view target is obtained.\n* If the current view target\
      \ is the current \"Pawn\" associated with the controller then either CalcBehindView()\
      \ or CalcFirstPersonView() is called to produce the camera location and rotation\
      \ required.\n* If the current view target is the controller itself then the\
      \ controller's rotation is used as the camera rotation.\n* If the current view\
      \ target is a projectile then the camera location is set to the view target's\
      \ collision height, and the camera rotation is set to that of the projectile\
      \ being followed.\n* If none of the above conditions are met then the view target\
      \ is checked to see if it is a [[Legacy:Pawn|Pawn]].  If this is the case then\
      \ the following happens:\n** If we are a client of a networked game and our\
      \ view target is a player pawn then we use the location of the view target and\
      \ the rotation of the controller (it reduces the perception of lag and allows\
      \ you to look around in behind view).\n** If are the server (or running a standalone\
      \ game) then both the location and rotation of the view target is used.\n\n\
      * The Default Behaviour\n\nSo, lets examine the PlayerCalcView() function. \
      \ I've reproduced it here in its entirety as there are a couple of things worth\
      \ noting about it.  I've taken the liberty of adding some additional comments\
      \ to the code in order to cover the things I think are important.\n\n<uscript>\n\
      \  // If desired, call the possessed pawn's own view calculation function. \
      \ If this function\n  // calculates the view the player should see then it must\
      \ return true.  Otherwise the\n  // calculated view will be replaced by the\
      \ usual view.\n  if( Pawn != None && Pawn.bSpecialCalcView ) {\n    // try the\
      \ 'special' calcview. This may return false if its not applicable, and we do\
      \ the usual.\n    if( Pawn.SpecialCalcView(ViewActor, CameraLocation, CameraRotation)\
      \ )\n      return; // EXIT point from function.\n  }\n\n  // If the controller\
      \ does not have a view target, or, it's view target is about to be removed from\n\
      \  // the level then we need to get one.\n  if ( (ViewTarget == None) || ViewTarget.bDeleteMe\
      \ ) {\n    if ( bViewBot && (CheatManager != None) )\n      CheatManager.ViewBot();\n\
      \    else if ( (Pawn != None) && !Pawn.bDeleteMe )\n      SetViewTarget(Pawn);\n\
      \    else\n      SetViewTarget(self);\n  }\n\n  ViewActor = ViewTarget;    \
      \           // Set the output variable ViewActor with the new view target\n\
      \  CameraLocation = ViewTarget.Location; // Set the output variable CameraLocation\
      \ with the view targets location\n\n  // If the view target of the controller\
      \ is the currently possessed pawn then the\n  // calculation of the view the\
      \ player sees is deferred to the first person and\n  // behind view calculation\
      \ functions.\n  if ( ViewTarget == Pawn )\n  {\n    if( bBehindView ) //up and\
      \ behind\n      CalcBehindView(CameraLocation, CameraRotation, CameraDist *\
      \ Pawn.Default.CollisionRadius);\n    else\n      CalcFirstPersonView( CameraLocation,\
      \ CameraRotation );\n    return; // EXIT point from function\n  }\n\n  // When\
      \ all else fails the view target of the controller is itself.  If the camera\n\
      \  // position is locked then a fixed rotation is used.  If not then the output\
      \ variable\n  // is set to the controller's rotation. \n  if ( ViewTarget ==\
      \ self ) {\n    if ( bCameraPositionLocked )\n      CameraRotation = CheatManager.LockedRotation;\n\
      \    else\n      CameraRotation = Rotation;\n    return; // EXIT point from\
      \ function\n  }\n\n  // If we are watching a projectile and we are in first\
      \ person view then raise the camera\n  // vertically upwards by the projectiles\
      \ collision height.  The camera rotation is set to\n  // the rotation of the\
      \ controller.\n  if ( ViewTarget.IsA('Projectile') && !bBehindView ) {\n   \
      \ CameraLocation += (ViewTarget.CollisionHeight) * vect(0,0,1);\n    CameraRotation\
      \ = Rotation;\n    return; // EXIT point from function\n  }\n\n  // Set the\
      \ camera rotation to the rotation of the current view target.\n  CameraRotation\
      \ = ViewTarget.Rotation;\n\n  PTarget = Pawn(ViewTarget);\n  if ( PTarget !=\
      \ None ) {\n    // If the view target is a pawn, and we are a client of a networked\n\
      \    // game then we need to do some additional processing\n    if ( Level.NetMode\
      \ == NM_Client ) {\n      if ( PTarget.IsPlayerPawn() ) {\n        // If we\
      \ are looking at a player pawn then the view rotation\n        // is set to\
      \ the TargetViewRotation (how the TargetViewRotation\n        // is set is a\
      \ mystery).  The view target's rotation is also set\n        // to this value.\n\
      \        PTarget.SetViewRotation(TargetViewRotation);\n        CameraRotation\
      \ = TargetViewRotation;\n      }\n\n      // Adjust the view targets eye height.\n\
      \      PTarget.EyeHeight = TargetEyeHeight;\n      if ( PTarget.Weapon != None\
      \ )\n        PTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n   \
      \ }\n    else if ( PTarget.IsPlayerPawn() )\n      CameraRotation = PTarget.GetViewRotation();\n\
      \n    // If we are not in behind view then the position the camera location\n\
      \    // at the view target's eye height.\n    if ( !bBehindView )\n      CameraLocation\
      \ += PTarget.EyePosition();\n  }\n\n  // This is the view calculations used\
      \ to determine the \"behind view\" when\n  // the View Target is not the same\
      \ as the Possessed pawn.\n  if ( bBehindView ) {\n    CameraLocation = CameraLocation\
      \ + (ViewTarget.Default.CollisionHeight - ViewTarget.CollisionHeight) * vect(0,0,1);\n\
      \    CalcBehindView(CameraLocation, CameraRotation, CameraDist * ViewTarget.Default.CollisionRadius);\n\
      \  }\n}\n</uscript>\n\n'''OlympusMons:''' I took this from http://wiki.beyondunreal.com/wiki/Customising_The_Player_View\
      \ and put it here I though this was a better place.\n\n==Spectators==\n\nSpectating\
      \ is also handled by the PlayerController class.  A state hierarchy is used\
      \ to enabled and disabled various player functions and generally keep things\
      \ tidy.  The hierarchy is shown below.\n\n  BaseSpectating\n    +- Spectating\n\
      \    |    +- AttractMode (also defined in xGame.xPlayer)\n    +- PlayerWaiting\n\
      \    +- WaitingForPawn\n\nIf you spend any time looking through the spectating\
      \ code (which does more or less what you'd expect) you'll notice something really\
      \ odd.  A pathalogical desire to set the view target.\n\n<uscript>\n// Spectating\
      \ - AltFire() calls ServerViewSelf() to return to your corpse (if you've been\
      \ killed or whatever)\n\n// ServerViewSelf() does the following:\n    SetViewTarget(self);\n\
      \    ClientSetViewTarget(self);\n\n// ClientSetViewTarget() is defined as:\n\
      function ClientSetViewTarget( Actor a )\n{\n    SetViewTarget( a );\n}\n</uscript>\n\
      \nIn fact, every call to ClientSetViewTarget( target ) is preceded with a call\
      \ to SetViewTarget( target ).  Is this simply an example of redundant code within\
      \ the code base or something more sinister?  I'll leave it up to the reader\
      \ to decide.\n\n'''DaWrecka''': More likely this is code that executes on the\
      \ server. SetViewTarget() sets the server's copy of ViewTarget, but the client\
      \ needs to have it updated; Hence the code calls ClientSetViewTarget(), which\
      \ is replicated to the client and updates the client's side to match the server's.\
      \ The presence of ClientSetViewTarget() in the replication block under \"reliable\
      \ if(Role == ROLE_Authority)\" would seem to back me up.\n\n==Movement and Control\
      \ ==\n\nPlayer movement and control can be split into two sections.  The first\
      \ is capturing input from the player and doing stuff with it.  The second is\
      \ ensuring that the player's position in the world is consistent between the\
      \ client and the server.\n\n===Capturing Player Input ===\n\nThere are two classes\
      \ shipped with UT2003 responsible for handling the player's input, and managing\
      \ the ''input configuration''.  Both of these are in the Engine class.  The\
      \ two classes are shown below.\n\n Engine.[[Legacy:PlayerInput|PlayerInput]]\n\
      \    +- Engine.[[Legacy:XBoxPlayerInput|XBoxPlayerInput]]\n\nThe PlayerInput\
      \ class is defined as being ''within PlayerController''.  This means that the\
      \ class has visibility of the attributes of the PlayerController class.  These\
      \ classes only exist on the client.  The entry points into the PlayerInput class\
      \ from a handling point of view are shown below.\n\n<uscript>\n// This function\
      \ is called from PlayerController.PlayerTick( float DeltaTime )\n// to figure\
      \ out what the player is up to.\nevent PlayerInput( float DeltaTime )\n\n//\
      \ This function is called from PlayerController.PlayerMove( float DeltaTime\
      \ )\n// it determines whether the player is dodging and if so, in which direction.\n\
      function Actor.eDoubleClickDir CheckForDoubleClickMove(float DeltaTime)\n</uscript>\n\
      \n''It's pretty arcane in there.  The logic within the double click move function\
      \ is particularly tortuous.  I'll need sleep before tackling that one.''\n\n\
      ===Player Movement and Replication ===\n\n{{innerbox|'''Mychaeel:''' Player\
      \ movement replication roughly works like this:  Locally, the player moves freely,\
      \ and the client sends information about that to the server.  The server then\
      \ tries to replay those moves when it receives them, and then sends information\
      \ back to the client on whether the movements worked out or not (and, if not,\
      \ where the player actually is right now).  That way you don't experience any\
      \ lag in your own movement when playing on a game server unless you interact\
      \ with conflicting dynamic objects (for instance, other players or movers or\
      \ projectiles).\n\n}}\n\nHere's what the PlayerController class has to say about\
      \ the player's movement replication.  It's a good summary of exactly what is\
      \ going on.\n\n{{innerbox|Here's how player movement prediction, replication\
      \ and correction works in network games:\n\n}}\n\n{{innerbox| Every tick, the\
      \ PlayerTick() function is called.  It calls the PlayerMove() function (which\
      \ is implemented in various states).  PlayerMove() figures out the acceleration\
      \ and rotation, and then calls ProcessMove() (for single player or listen servers),\
      \ or ReplicateMove() (if its a network client).\n\n}}\n\n{{innerbox| ReplicateMove()\
      \ saves the move (in the PendingMove list), calls ProcessMove(), and then replicates\
      \ the move to the server by calling the replicated function ServerMove() - passing\
      \ the movement parameters, the client's resultant position, and a timestamp.\n\
      \n}}\n\n{{innerbox| ServerMove() is executed on the server.  It decodes the\
      \ movement parameters and causes the appropriate movement to occur.  It then\
      \ looks at the resulting position and if enough time has passed since the last\
      \ response, or the position error is significant enough, the server calls ClientAdjustPosition(),\
      \ a replicated function.\n\n}}\n\n{{innerbox| ClientAdjustPosition() is executed\
      \ on the client.  The client sets its position to the servers version of position,\
      \ and sets the bUpdatePosition flag to true.\n\n}}\n\n{{innerbox| When PlayerTick()\
      \ is called on the client again, if bUpdatePosition is true, the client will\
      \ call ClientUpdatePosition() before calling PlayerMove().  ClientUpdatePosition()\
      \ replays all the moves in the pending move list which occured after the timestamp\
      \ of the move the server was adjusting.\n\n}}\n\nI guess the above comments\
      \ really beg the question, \"How exactly do replicated functions work then?\"\
      .\n\n==Related Topics==\n* [[Legacy:Controller Overview|Controller Overview]]\n\
      * [[Legacy:Creating An Interaction From A PlayerController|Creating an Interaction\
      \ from a PlayerController]]\n* [[Legacy:Customising The Player View|Customising\
      \ the Player View]]\n\n==Discussion==\n\n'''OlympusMons:''' Ok I put all the\
      \ stuff that was on the player controller page here for an overview similar\
      \ to [[Legacy:Controller Overview|Controller Overview]]. This is probably temporary\
      \ until the [[Legacy:PlayerController|PlayerController]] page can be brought\
      \ to standard formatting. If I was wrong in doing this please fix this ;)\n\n\
      '''SuperApe:''' Looks pretty good for the most part.\n\n----\n\n[[:Category:Legacy\
      \ Refactor Me]] &ndash; Some things here just need a little careful organization.\n\
      [[Category:Legacy Refactor Me|{{PAGENAME}}]]"
  properties: []
  revId: 6087
name: "Legacy:PlayerController Overview"
revision:
  revid: 6087
  parentid: 6089
  user: "DaWrecka"
  timestamp: 1198033318.000000000
  comment: "* added a point of discussion to the text on SetViewTarget() and ClientSetViewTarget()"
timestamp: 1668787920.794331000
