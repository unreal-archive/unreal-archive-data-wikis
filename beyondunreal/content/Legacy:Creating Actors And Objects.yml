---
parse:
  title: "Legacy:Creating Actors And Objects"
  text:
    text: "<h2><span class=\"mw-headline\" id=\"New_Keyword\">New Keyword</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Creating_Actors_And_Objects?section=1\" title=\"Edit section:\
      \ New Keyword\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>The <i>New</i> keyword is used to create new <a href=\"/Legacy:Object\" title=\"\
      Legacy:Object\">objects</a> which are not a subclass of <a href=\"/Legacy:Actor\"\
      \ title=\"Legacy:Actor\">Actor</a>.</p>\n<p>The parameters are the owner object,\
      \ the new object's name and the object's flags. Being one of the <a href=\"\
      /Legacy:UnrealScript_Keywords\" title=\"Legacy:UnrealScript Keywords\">UnrealScript\
      \ keywords</a> rather than a function, there is no definition for New, but here's\
      \ what it would look like if there were:</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\"><span class=\"kw8\">Object</span> <span class=\"st0\">''</span><span class=\"\
      st0\">'New'</span><span class=\"st0\">''</span><span class=\"br0\">(</span>\n\
      \  <span class=\"kw1\">optional</span> <span class=\"kw8\">Object</span> <span\
      \ class=\"st0\">''</span>NewOuter<span class=\"st0\">''</span>,\n  <span class=\"\
      kw1\">optional</span> <span class=\"kw5\">string</span> <span class=\"st0\"\
      >''</span>NewName<span class=\"st0\">''</span>,\n  <span class=\"kw1\">optional</span>\
      \ <span class=\"kw5\">int</span> <span class=\"st0\">''</span>NewFlags<span\
      \ class=\"st0\">''</span>\n  <span class=\"br0\">)</span> <span class=\"kw1\"\
      >Class</span> <span class=\"st0\">''</span>NewClass<span class=\"st0\">''</span></pre></div>\n\
      </div>\n<dl>\n<dt>NewOuter&#160;</dt>\n<dd>An object which will be assigned\
      \ to the new object's Outer property. Self if omitted. If you are creating a\
      \ new object that is declared Within another class, the new outer must be an\
      \ object of that class or one of its subclasses.</dd>\n<dt>NewName&#160;</dt>\n\
      <dd>The new object's name. In <a href=\"/Legacy:UT\" title=\"Legacy:UT\" class=\"\
      mw-redirect\">UT</a> this seems to be a parameter of type Name, while in <a\
      \ href=\"/Legacy:UT2003\" title=\"Legacy:UT2003\" class=\"mw-redirect\">UT2003</a>/4\
      \ this parameter is of type String. This allows you to dynamically create it,\
      \ eg \"MyObject\"$i – you can do this sort of thing in UT, but it's more complicated.</dd>\n\
      <dt>NewFlags&#160;</dt>\n<dd>The new object's ObjectFlags. Only the <tt>RF_anything</tt>\
      \ constants from the <a href=\"/Legacy:Object\" title=\"Legacy:Object\">Object</a>\
      \ class and combinations of them are valid values, but you shouldn't use them\
      \ unless you know what you're doing.</dd>\n<dt>NewClass&#160;</dt>\n<dd>The\
      \ new object's class.</dd>\n<dt>return value&#160;</dt>\n<dd>Like the Spawn()\
      \ method described below New returns a reference to an object of the specified\
      \ class.</dd>\n</dl>\n<p>Examples:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">local</span> <span class=\"kw8\">Object</span> NewObject;\n\
      \ \nNewObject <span class=\"sy0\">=</span> <span class=\"kw1\">New</span> <span\
      \ class=\"kw1\">class</span><span class=\"st0\">'MyObjectClass'</span>;\nNewObject\
      \ <span class=\"sy0\">=</span> <span class=\"kw1\">New</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'MyObjectClass'</span>;\nNewObject <span class=\"sy0\">=</span>\
      \ <span class=\"kw1\">New</span><span class=\"br0\">(</span><span class=\"kw5\"\
      >None</span><span class=\"br0\">)</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'MyObjectClass'</span>;\nNewObject <span class=\"sy0\">=</span>\
      \ <span class=\"kw1\">New</span><span class=\"br0\">(</span>SomeOtherObject,\
      \ <span class=\"st0\">\"SomeWeirdObjectName\"</span><span class=\"br0\">)</span>\
      \ <span class=\"kw1\">class</span><span class=\"st0\">'MyObjectClass'</span>;\n\
      NewObject <span class=\"sy0\">=</span> <span class=\"kw1\">New</span><span class=\"\
      br0\">(</span><span class=\"kw5\">None</span>, <span class=\"st0\">''</span>,\
      \ <span class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"kw1\"\
      >class</span><span class=\"st0\">'MyObjectClass'</span>;</pre></div>\n</div>\n\
      <p>When non-actor objects are created in <a href=\"/Legacy:UT2003\" title=\"\
      Legacy:UT2003\" class=\"mw-redirect\">UT2003</a> then the object's Created function\
      \ is called.<br />\nCreating Actor objects with the <i>New</i> keyword causes\
      \ the game or UCC <a href=\"/Legacy:Commandlet\" title=\"Legacy:Commandlet\"\
      >commandlets</a> to crash.</p>\n<p>When dealing with non-Actor objects you must\
      \ be absolutely sure to clean up Actor references in any objects, generally\
      \ by explicitly setting those references to None where appropriate. Good places\
      \ for this would be right after calling the Actor's Destroy() method or in the\
      \ Actor's Destroyed() event. Failing to do so can effectively prevent the entire\
      \ level from being garbage-collected at map change, resulting it two levels\
      \ existing in memory at the same time, which generally crashes the game.</p>\n\
      <p>Newer engine version (i.e. UE3), however, detect this condition and crash\
      \ immediately, logging useful information, including complete reference chain.\
      \ You may need to launch the game with <code>-log</code> switch, though, as\
      \ file logs tend to be not properly flushed on crash.</p>\n<p>Object references\
      \ in Actors are no problem, though.</p>\n<p><b>Foxpaw:</b> Though you are correct\
      \ that this causes problems, actors don't get garbage collected, and there is\
      \ usually at least two levels loaded at any given time. (The current level you're\
      \ playing, and the \"entry level.\") I believe that the problem arises because\
      \ the object (which doesn't exist within the context of any level) doesn't get\
      \ garbage collected because it's referencing a valid actor, then the reference\
      \ becomes invalid due to the destruction of the actor, but the bit of code that\
      \ checks for references to actors whenever an actor is destroyed doesn't get\
      \ called on non-actors, thus you have an invalid reference that has not been\
      \ changed to None. This points to a place in memory that is either something\
      \ different or (usually) the middle of something, which, when the engine tries\
      \ to do anything with it, causes a general protection fault because it's trying\
      \ to read an object's data mid-object and getting information that appears to\
      \ be in an invalid format.</p>\n<p><b>Wormbo:</b> Actors <i>do</i> get garbage-collected\
      \ at level change. If the current level can't be garbage collected you will\
      \ effectively have three levels in memory and if the problem persists eventually\
      \ there will be too much stuff in memory to continue and the game will crash\
      \ with an out-off-memory message. The changes I did to this page are all based\
      \ on quite detailed information given by <a href=\"/Legacy:Evolution\" title=\"\
      Legacy:Evolution\">Evolution</a> on IRC in ETG #unrealscript.</p>\n<p><b>Foxpaw:</b>\
      \ I'm fairly certain that actors don't get garbage collected - I think that\
      \ the game just walks it's actor list and Destroy()s each one. I'm pretty sure\
      \ that they don't suffer normal garbage collection. Unfortunately, when I tried\
      \ to set up some classes to test it conclusively, (create a reference from an\
      \ object to an actor, change levels, see if actor still exists) turned out trickier\
      \ than I had expected. UT destroyed the actor, then found that there was no\
      \ valid references from the object, and garbage collected it. One might be able\
      \ to get around that by having a reference to the object from something that\
      \ won't get destroyed on level change, IE the GUI or the Player.</p>\n<p><b>Wormbo:</b>\
      \ Nothing gets Destroy()ed on level change, otherwise the Destroyed() event\
      \ would trigger. (That's why it's so hard to clean up stuff on map change.)\
      \ The whole level is just garbage-collected and the now unused packages are\
      \ unloaded from memory.</p>\n<p><b>Evolution:</b> Actors do get garbage collected,\
      \ but usually not immediately. When unrealscript calls the Destroy() function\
      \ on an actor, the actor's Destroyed() event is triggered, the engine sets the\
      \ Actor's bDeleteMe property to True, adds the actor to a list of actors that\
      \ are pending deletion, and removes the Actor from the level's \"live\" Actor\
      \ list [which is represented by the AllActors iterator]). Once the number of\
      \ Actors pending deletion reaches a certain number, a \"mini\" garbage collection\
      \ occurs, which actually deletes those actors. When the level changes, any actors\
      \ on the \"pending deletion\" list are deleted, even if there are less than\
      \ the required number. When this occurs, any \"live\" actors still in the level\
      \ will not receive the Destroyed() event, with the exception of PlayerController\
      \ and Pawn actors.</p>\n<p>There are actually two different problems which can\
      \ result from dangling actor references in non-Actor objects. The first problem\
      \ occurs when an actor which has been destroyed is still referenced by an object\
      \ which is rooted (\"rooted\" just means that the object is linked to some other\
      \ object which remains persistent throughout level changes, such as the GUIController\
      \ or Player, through a chain of object references). Since rooted objects (including\
      \ actors) cannot be garbage collected, they will remain in memory, and as a\
      \ result, so will the level object itself, along with any objects it's referencing,\
      \ so on and so on. This leads to more than one (excluding Entry) level existing\
      \ in memory at the same time, which typically results what most C++ books would\
      \ call \"indeterminate behavior\", or in layman's terms - \"eventually (but\
      \ usually immediately) crashes the program\".</p>\n<p>The second problem occurs\
      \ when you fail to explicitly set the Actor reference to None before unrooting\
      \ the object (i.e. ObjectA is the only object referencing ObjectB, which is\
      \ the only object (besides the level actor) referencing ActorA. ObjectA then\
      \ sets the var pointing at ObjectB to None, but ObjectB has not set its ActorA\
      \ reference to None). Assume that ActorA destroyed itself at some point after\
      \ this. When garbage collection occurs at level change, since both ObjectB and\
      \ ActorA are considered unrooted, they are allowed to be deleted. If ActorA\
      \ is deleted prior to ObjectB, then ObjectB's reference to ActorA would then\
      \ be pointing at deleted memory. When the GC process reaches ObjectB, it recursively\
      \ iterates through ObjectB's object references to determine whether ObjectB\
      \ is unrooted, and throws an access violation when it attempts to read the memory\
      \ still being pointed to by ObjectB's ActorA reference. If you are familiar\
      \ with C++ programming, it's probably very obvious what the problem is there.</p>\n\
      <p>An important caveat of Actor references in UT2003/UT2004 is that they will\
      \ return None if they are marked bDeleteMe, even if they haven't actually been\
      \ deleted yet. This is the reason I set the MyGlobalActor reference to None\
      \ even if the 'if ( MyGlobalActor&#160;!= None )' check returns false, in the\
      \ code I posted.</p>\n<p>I hope this helps clear up exactly where the danger\
      \ lies in not correctly cleaning up Actor references in your Objects. It's very\
      \ important to fully understand how to correctly clean up Actor references if\
      \ your mod has any interaction between Actors and Objects.</p>\n<blockquote\
      \ class=\"legacyquote\">\n<p>A good rule of thumb is to NEVER have a global\
      \ actor variable in a non-Actor subclass and when you must, make it a private\
      \ variable, and provide accessor functions like Get() or something, so that\
      \ you completely control the actual reference.</p>\n<dl>\n<dd><a href=\"/Legacy:Evolution\"\
      \ title=\"Legacy:Evolution\">Evolution</a></dd>\n</dl>\n</blockquote>\n<p>Here\
      \ is an example of how to safely use an actor in a non-Actor subclass:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">class</span> MyObjectThing\
      \ <span class=\"kw1\">extends</span> <span class=\"kw8\">Object</span>;\n \n\
      <span class=\"co1\">// assume MyActor is a subclass of Actor that is in your\
      \ mod</span>\n<span class=\"kw1\">var</span> <span class=\"kw1\">private</span>\
      \ MyActor MyGlobalActor;\n \n<span class=\"co1\">// this will indicate when\
      \ MyObjectThing should not be allowed to create new actors</span>\n<span class=\"\
      kw1\">var</span> <span class=\"kw1\">private</span> <span class=\"kw5\">bool</span>\
      \ bLocked;\n \n<span class=\"kw1\">function</span> MyActor GetMyActor<span class=\"\
      br0\">(</span> <span class=\"kw1\">optional</span> <span class=\"kw9\">Actor</span>\
      \ A <span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n    <span class=\"\
      kw2\">if</span> <span class=\"br0\">(</span> <span class=\"sy0\">!</span>bLocked\
      \ <span class=\"sy0\">&amp;&amp;</span> MyGlobalActor <span class=\"sy0\">==</span>\
      \ <span class=\"kw5\">None</span> <span class=\"sy0\">&amp;&amp;</span> A <span\
      \ class=\"sy0\">!=</span> <span class=\"kw5\">None</span> <span class=\"br0\"\
      >)</span>\n        MyGlobalActor <span class=\"sy0\">=</span> A.<span class=\"\
      kw4\">Spawn</span><span class=\"br0\">(</span><span class=\"kw1\">class</span><span\
      \ class=\"st0\">'MyActor'</span><span class=\"br0\">)</span>;\n \n    <span\
      \ class=\"kw2\">return</span> MyGlobalActor;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"co1\">// Call this function when you're no longer going to\
      \ be using this object, </span>\n<span class=\"co1\">// i.e. you are releasing\
      \ your reference to this object</span>\n<span class=\"co1\">// e.g. if this\
      \ was a GUIComponent, you would call this function when the page is closed</span>\n\
      <span class=\"kw1\">function</span> Shutdown<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n    <span class=\"kw2\"\
      >if</span> <span class=\"br0\">(</span> MyGlobalActor <span class=\"sy0\">!=</span>\
      \ <span class=\"kw5\">None</span> <span class=\"br0\">)</span>\n        MyGlobalActor.<span\
      \ class=\"kw4\">Destroy</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;\n \n    MyGlobalActor <span class=\"sy0\">=</span> <span class=\"\
      kw5\">None</span>;\n    bLocked <span class=\"sy0\">=</span> <span class=\"\
      kw6\">True</span>;\n<span class=\"br0\">}</span>\n \n<span class=\"kw1\">function</span>\
      \ DoSomeStuff<span class=\"br0\">(</span><span class=\"br0\">)</span>\n<span\
      \ class=\"br0\">{</span>\n    <span class=\"kw1\">local</span> <span class=\"\
      kw5\">bool</span> bExample;\n    <span class=\"kw1\">local</span> MyActor MyLocalActor;\n\
      \ \n    <span class=\"co1\">// It's good practice to avoid referencing MyGlobalActor\
      \ directly, even from within the same class</span>\n    MyLocalActor <span class=\"\
      sy0\">=</span> GetMyActor<span class=\"br0\">(</span><span class=\"br0\">)</span>;\n\
      \    bExample <span class=\"sy0\">=</span> MyLocalActor.<span class=\"me0\"\
      >IsAnExample</span><span class=\"br0\">(</span><span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p><b>Foxpaw:</b> Have you\
      \ tested the above? I'm fairly certain that you can't call Spawn from something\
      \ that isn't subclassed from actor. What with Spawn being defined in Actor and\
      \ all. Plus the actor wouldn't have a reference to a level, because it goes\
      \ into the level that the actor that spawned it was in.</p>\n<p><b>Evolution:</b>\
      \ Hehe, ya got me. Yes, you'd need to have a reference to an actor in order\
      \ to call the Spawn() function. I've changed the above code snippet to represent\
      \ this. Thanks for pointing that out.</p>\n<p><b>porkmanii:</b> What of WeaponFire\
      \ objects in Unreal Engine 2.5? I have had the game crash as a result of a Weapon\
      \ referencing the WeaponFire objects/fire-modes of a Weapon which has been destroyed.\
      \ Does this mean Weapons delete their WeaponFire objects when Destroyed, even\
      \ if other Actors are still referencing them?</p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Spawn.28.29_Method\">Spawn() Method</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Creating_Actors_And_Objects?section=2\"\
      \ title=\"Edit section: Spawn() Method\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>The <i>Spawn</i> function is used to create new actors.\
      \ Unlike the <i>New</i> keyword, <i>Spawn</i> can only be called from a non-<a\
      \ href=\"/Legacy:Static_Function\" title=\"Legacy:Static Function\">static function</a>\
      \ and can only create <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\">actors</a>.\
      \ If you need to call the <i>Spawn</i> function from a non-actor object make\
      \ sure it has access to an <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\"\
      >Actor</a> whose <i>Spawn</i> function can be used then.</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"kw1\">native</span><span class=\"br0\">(</span><span\
      \ class=\"nu0\">278</span><span class=\"br0\">)</span> <span class=\"kw1\">final</span>\
      \ <span class=\"kw1\">function</span> <span class=\"kw9\">actor</span> <span\
      \ class=\"kw4\">Spawn</span>\n<span class=\"br0\">(</span>\n   class<span class=\"\
      sy0\">&lt;</span>actor<span class=\"sy0\">&gt;</span>     SpawnClass,\n   <span\
      \ class=\"kw1\">optional</span> <span class=\"kw9\">actor</span>   SpawnOwner,\n\
      \   <span class=\"kw1\">optional</span> <span class=\"kw5\">name</span>    SpawnTag,\n\
      \   <span class=\"kw1\">optional</span> <span class=\"kw5\">vector</span>  SpawnLocation,\n\
      \   <span class=\"kw1\">optional</span> <span class=\"kw5\">rotator</span> SpawnRotation\n\
      <span class=\"br0\">)</span>;</pre></div>\n</div>\n<p>If <i>SpawnLocation</i>\
      \ and/or <i>SpawnRotation</i> is not specified the spawner's <i>Location</i>\
      \ and <i>Rotation</i> is used. (The spawner is the actor <i>Spawn</i> is called\
      \ from.)</p>\n<p><i>Spawn</i> returns an object of the class specified in <i>SpawnClass</i>,\
      \ not an object of class <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\">Actor</a>,\
      \ i.e. you don't have to cast it to the class you need. This is hardcoded in\
      \ the compiler. For example:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">local</span> <span class=\"kw9\">Projectile</span> P;\n\
      P <span class=\"sy0\">=</span> <span class=\"kw4\">Spawn</span><span class=\"\
      br0\">(</span>ProjectileClass, <span class=\"kw7\">Instigator</span>,,, <span\
      \ class=\"kw7\">Instigator</span>.<span class=\"me0\">ViewRotation</span><span\
      \ class=\"br0\">)</span>;</pre></div>\n</div>\n<p>You don't have to use <tt>P\
      \ = Projectile(Spawn(ProjectileClass))</tt>, in fact this will cause an error\
      \ when compiling.</p>\n<dl>\n<dd><b>Warning:</b> Spawning an actor for an owner\
      \ whose deletion is pending reliably crashes the game with a \"Unknown code\
      \ token\" error. If in doubt, make sure you check the new owner's <i>bDeleteMe</i>\
      \ property first.</dd>\n</dl>\n<p>Spawn also allows you to set the Tag on the\
      \ new actor. If you need to set other properties on the new actor, you'll have\
      \ to either call its accessors or set them directly once it's created. For example:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">local</span> MyClass\
      \ P;\nP <span class=\"sy0\">=</span> <span class=\"kw4\">Spawn</span><span class=\"\
      br0\">(</span>MyClass<span class=\"br0\">)</span>;\nP.<span class=\"me0\">SetMeaning</span><span\
      \ class=\"br0\">(</span><span class=\"nu0\">42</span><span class=\"br0\">)</span>;\n\
      P.<span class=\"me0\">bHasMeaning</span> <span class=\"sy0\">=</span> <span\
      \ class=\"kw6\">True</span>;</pre></div>\n</div>\n<p>On the other hand, if your\
      \ goal is simply to have certain properties set before anything else happens\
      \ to the object, you can use default properties in a sort of two part constructor:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"co1\">// In the thing\
      \ to be spawned..</span>\n<span class=\"kw1\">static</span> <span class=\"kw1\"\
      >function</span> PreInitialize<span class=\"br0\">(</span> <span class=\"kw5\"\
      >string</span> SomeVar, <span class=\"kw5\">int</span> SomeNumber <span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"co1\">// You can\
      \ preserve the original default values in other default variables if you want,\
      \ and restore them in prebeginplay. If you want.</span>\n  <span class=\"kw1\"\
      >default</span>.<span class=\"me0\">SomeOtherVar</span> <span class=\"sy0\"\
      >=</span> SomeVar;\n  <span class=\"kw1\">default</span>.<span class=\"me0\"\
      >SomeOtherNumber</span> <span class=\"sy0\">=</span> SomeNumber;\n<span class=\"\
      br0\">}</span>\n \n<span class=\"co1\">// In the spawner..</span>\n<span class=\"\
      kw1\">class</span><span class=\"st0\">'Whatever'</span>.<span class=\"kw1\"\
      >static</span>.<span class=\"me0\">PreInitialize</span><span class=\"br0\">(</span>\
      \ <span class=\"st0\">\"Cats are soft.\"</span>, <span class=\"nu0\">5</span>\
      \ <span class=\"br0\">)</span>;\n<span class=\"kw4\">Spawn</span><span class=\"\
      br0\">(</span> <span class=\"kw1\">class</span><span class=\"st0\">'Whatever'</span>\
      \ <span class=\"br0\">)</span>;</pre></div>\n</div>\n<p>Another, probably less\
      \ elegant-looking method would be exploiting the <a href=\"/Legacy:Chain_Of_Events_When_Spawning_Actors\"\
      \ title=\"Legacy:Chain Of Events When Spawning Actors\">Chain of Events when\
      \ Spawning Actors</a>:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">class</span> TheSpawningClass <span class=\"kw1\">extends</span> Some<span\
      \ class=\"re0\">Class</span>&lt; SEMI &gt;\n \n<span class=\"kw1\">event</span>\
      \ <span class=\"kw4\">GainedChild</span><span class=\"br0\">(</span><span class=\"\
      kw9\">Actor</span> Other<span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> Other.<span class=\"\
      kw1\">Class</span> <span class=\"sy0\">==</span> <span class=\"kw1\">class</span><span\
      \ class=\"st0\">'WhatEver'</span> <span class=\"br0\">)</span> <span class=\"\
      br0\">{</span>\n    <span class=\"co1\">// this is executed before the newly\
      \ spawned actor has a chance to execute its own PreBeginPlay() event</span>\n\
      \  <span class=\"br0\">}</span>\n<span class=\"br0\">}</span>\n \n<span class=\"\
      kw1\">function</span> SpawnMyChild<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n  <span class=\"kw4\">Spawn</span><span\
      \ class=\"br0\">(</span><span class=\"kw1\">class</span><span class=\"st0\"\
      >'WhatEver'</span>, <span class=\"kw6\">Self</span><span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<h2><span class=\"mw-headline\"\
      \ id=\"Related_Topics\">Related Topics</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Creating_Actors_And_Objects?section=3\"\
      \ title=\"Edit section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:UnrealScript\" title=\"Legacy:UnrealScript\"\
      >UnrealScript</a> main topic page</li>\n<li><a href=\"/Legacy:Class_Syntax\"\
      \ title=\"Legacy:Class Syntax\">Class Syntax</a></li>\n<li><a href=\"/Legacy:Chain_Of_Events_When_Spawning_Actors\"\
      \ title=\"Legacy:Chain Of Events When Spawning Actors\">Chain of Events when\
      \ Spawning Actors</a></li>\n<li><a href=\"/Legacy:Chain_Of_Events_At_Level_Startup\"\
      \ title=\"Legacy:Chain Of Events At Level Startup\">Chain of Events at Level\
      \ Startup</a></li>\n<li><a href=\"/Legacy:Destroying_Objects\" title=\"Legacy:Destroying\
      \ Objects\">Destroying Objects</a></li>\n</ul>\n<hr />\n<p><b>hc:</b> Is there\
      \ a way to get spawn create actors that don't fit in the current location? I\
      \ have to spawn some big objects and move them out of the way, but spawn fails\
      \ when there's not enough room.. My current workaround is to set the default\
      \ collision properties to zero and have the object change them to something\
      \ appropriate after it has been spawned, but that's an ugly ugly hack..</p>\n\
      \n<!-- \nNewPP limit report\nCPU time usage: 0.197 seconds\nReal time usage:\
      \ 0.728 seconds\nPreprocessor visited node count: 94/1000000\nPreprocessor generated\
      \ node count: 231/1000000\nPost‐expand include size: 650/2097152 bytes\nTemplate\
      \ argument size: 277/2097152 bytes\nHighest expansion depth: 3/40\nExpensive\
      \ parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report\
      \ (%,ms,calls,template)\n100.00%   24.822      1 - -total\n100.00%   24.822\
      \      1 - Template:Innerbox\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:698-0!*!0!!*!*!*\
      \ and timestamp 20221118003144 and revision id 45296\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript Keywords"
  - ns: 100
    exists: true
    name: "Legacy:Chain Of Events At Level Startup"
  - ns: 100
    exists: true
    name: "Legacy:Evolution"
  - ns: 100
    exists: true
    name: "Legacy:UT"
  - ns: 100
    exists: true
    name: "Legacy:Chain Of Events When Spawning Actors"
  - ns: 100
    exists: true
    name: "Legacy:UT2003"
  - ns: 100
    exists: true
    name: "Legacy:Class Syntax"
  - ns: 100
    exists: true
    name: "Legacy:Commandlet"
  - ns: 100
    exists: true
    name: "Legacy:Destroying Objects"
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  - ns: 100
    exists: true
    name: "Legacy:Static Function"
  - ns: 100
    exists: true
    name: "Legacy:Object"
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript"
  templates:
  - ns: 10
    exists: true
    name: "Template:Innerbox"
  images: []
  externallinks: []
  sections:
  - toclevel: 1
    level: "2"
    line: "New Keyword"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Creating_Actors_And_Objects"
    byteoffset: 0
    anchor: "New_Keyword"
  - toclevel: 1
    level: "2"
    line: "Spawn() Method"
    number: "2"
    index: "2"
    fromtitle: "Legacy:Creating_Actors_And_Objects"
    byteoffset: 10853
    anchor: "Spawn.28.29_Method"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "3"
    index: "3"
    fromtitle: "Legacy:Creating_Actors_And_Objects"
    byteoffset: 13712
    anchor: "Related_Topics"
  displaytitle: "Legacy:Creating Actors And Objects"
  iwlinks: []
  wikitext:
    text: "==New Keyword ==\n\nThe ''New'' keyword is used to create new [[Legacy:Object|object]]s\
      \ which are not a subclass of [[Legacy:Actor|Actor]].\n\nThe parameters are\
      \ the owner object, the new object's name and the object's flags. Being one\
      \ of the [[Legacy:UnrealScript Keywords|UnrealScript keywords]] rather than\
      \ a function, there is no definition for New, but here's what it would look\
      \ like if there were:\n\n<uscript>\nObject '''New'''(\n  optional Object ''NewOuter'',\n\
      \  optional string ''NewName'',\n  optional int ''NewFlags''\n  ) Class ''NewClass''\n\
      </uscript>\n\n; NewOuter : An object which will be assigned to the new object's\
      \ Outer property. Self if omitted. If you are creating a new object that is\
      \ declared Within another class, the new outer must be an object of that class\
      \ or one of its subclasses.\n; NewName : The new object's name. In [[Legacy:UT|UT]]\
      \ this seems to be a parameter of type Name, while in [[Legacy:UT2003|UT2003]]/4\
      \ this parameter is of type String. This allows you to dynamically create it,\
      \ eg \"MyObject\"$i &ndash; you can do this sort of thing in UT, but it's more\
      \ complicated.\n; NewFlags : The new object's ObjectFlags. Only the <tt>RF_anything</tt>\
      \ constants from the [[Legacy:Object|Object]] class and combinations of them\
      \ are valid values, but you shouldn't use them unless you know what you're doing.\n\
      ; NewClass : The new object's class.\n; return value : Like the Spawn() method\
      \ described below New returns a reference to an object of the specified class.\n\
      \nExamples:\n\n<uscript>\nlocal Object NewObject;\n\nNewObject = New class'MyObjectClass';\n\
      NewObject = New() class'MyObjectClass';\nNewObject = New(None) class'MyObjectClass';\n\
      NewObject = New(SomeOtherObject, \"SomeWeirdObjectName\") class'MyObjectClass';\n\
      NewObject = New(None, '', 0) class'MyObjectClass';\n</uscript>\n\nWhen non-actor\
      \ objects are created in [[Legacy:UT2003|UT2003]] then the object's Created\
      \ function is called.<br />Creating Actor objects with the ''New'' keyword causes\
      \ the game or UCC [[Legacy:Commandlet|commandlet]]s to crash.\n\nWhen dealing\
      \ with non-Actor objects you must be absolutely sure to clean up Actor references\
      \ in any objects, generally by explicitly setting those references to None where\
      \ appropriate. Good places for this would be right after calling the Actor's\
      \ Destroy() method or in the Actor's Destroyed() event. Failing to do so can\
      \ effectively prevent the entire level from being garbage-collected at map change,\
      \ resulting it two levels existing in memory at the same time, which generally\
      \ crashes the game. \n\nNewer engine version (i.e. UE3), however, detect this\
      \ condition and crash immediately, logging useful information, including complete\
      \ reference chain. You may need to launch the game with <code>-log</code> switch,\
      \ though, as file logs tend to be not properly flushed on crash.\n\nObject references\
      \ in Actors are no problem, though.\n\n'''Foxpaw:''' Though you are correct\
      \ that this causes problems, actors don't get garbage collected, and there is\
      \ usually at least two levels loaded at any given time. (The current level you're\
      \ playing, and the \"entry level.\") I believe that the problem arises because\
      \ the object (which doesn't exist within the context of any level) doesn't get\
      \ garbage collected because it's referencing a valid actor, then the reference\
      \ becomes invalid due to the destruction of the actor, but the bit of code that\
      \ checks for references to actors whenever an actor is destroyed doesn't get\
      \ called on non-actors, thus you have an invalid reference that has not been\
      \ changed to None. This points to a place in memory that is either something\
      \ different or (usually) the middle of something, which, when the engine tries\
      \ to do anything with it, causes a general protection fault because it's trying\
      \ to read an object's data mid-object and getting information that appears to\
      \ be in an invalid format.\n\n'''Wormbo:''' Actors ''do'' get garbage-collected\
      \ at level change. If the current level can't be garbage collected you will\
      \ effectively have three levels in memory and if the problem persists eventually\
      \ there will be too much stuff in memory to continue and the game will crash\
      \ with an out-off-memory message. The changes I did to this page are all based\
      \ on quite detailed information given by [[Legacy:Evolution|Evolution]] on IRC\
      \ in ETG #unrealscript.\n\n'''Foxpaw:''' I'm fairly certain that actors don't\
      \ get garbage collected - I think that the game just walks it's actor list and\
      \ Destroy()s each one. I'm pretty sure that they don't suffer normal garbage\
      \ collection. Unfortunately, when I tried to set up some classes to test it\
      \ conclusively, (create a reference from an object to an actor, change levels,\
      \ see if actor still exists) turned out trickier than I had expected. UT destroyed\
      \ the actor, then found that there was no valid references from the object,\
      \ and garbage collected it. One might be able to get around that by having a\
      \ reference to the object from something that won't get destroyed on level change,\
      \ IE the GUI or the Player. \n\n'''Wormbo:''' Nothing gets Destroy()ed on level\
      \ change, otherwise the Destroyed() event would trigger. (That's why it's so\
      \ hard to clean up stuff on map change.) The whole level is just garbage-collected\
      \ and the now unused packages are unloaded from memory.\n\n'''Evolution:'''\
      \ Actors do get garbage collected, but usually not immediately.  When unrealscript\
      \ calls the Destroy() function on an actor, the actor's Destroyed() event is\
      \ triggered, the engine sets the Actor's bDeleteMe property to True, adds the\
      \ actor to a list of actors that are pending deletion, and removes the Actor\
      \ from the level's \"live\" Actor list [which is represented by the AllActors\
      \ iterator]).  Once the number of Actors pending deletion reaches a certain\
      \ number, a \"mini\" garbage collection occurs, which actually deletes those\
      \ actors.  When the level changes, any actors on the \"pending deletion\" list\
      \ are deleted, even if there are less than the required number.  When this occurs,\
      \ any \"live\" actors still in the level will not receive the Destroyed() event,\
      \ with the exception of PlayerController and Pawn actors.\n\nThere are actually\
      \ two different problems which can result from dangling actor references in\
      \ non-Actor objects.  The first problem occurs when an actor which has been\
      \ destroyed is still referenced by an object which is rooted (\"rooted\" just\
      \ means that the object is linked to some other object which remains persistent\
      \ throughout level changes, such as the GUIController or Player, through a chain\
      \ of object references).  Since rooted objects (including actors) cannot be\
      \ garbage collected, they will remain in memory, and as a result, so will the\
      \ level object itself, along with any objects it's referencing, so on and so\
      \ on.  This leads to more than one (excluding Entry) level existing in memory\
      \ at the same time, which typically results what most C++ books would call \"\
      indeterminate behavior\", or in layman's terms - \"eventually (but usually immediately)\
      \ crashes the program\".  \n\nThe second problem occurs when you fail to explicitly\
      \ set the Actor reference to None before unrooting the object (i.e. ObjectA\
      \ is the only object referencing ObjectB, which is the only object (besides\
      \ the level actor) referencing ActorA.  ObjectA then sets the var pointing at\
      \ ObjectB to None, but ObjectB has not set its ActorA reference to None).  Assume\
      \ that ActorA destroyed itself at some point after this.  When garbage collection\
      \ occurs at level change, since both ObjectB and ActorA are considered unrooted,\
      \ they are allowed to be deleted.  If ActorA is deleted prior to ObjectB, then\
      \ ObjectB's reference to ActorA would then be pointing at deleted memory.  When\
      \ the GC process reaches ObjectB, it recursively iterates through ObjectB's\
      \ object references to determine whether ObjectB is unrooted, and throws an\
      \ access violation when it attempts to read the memory still being pointed to\
      \ by ObjectB's ActorA reference.  If you are familiar with C++ programming,\
      \ it's probably very obvious what the problem is there.\n\nAn important caveat\
      \ of Actor references in UT2003/UT2004 is that they will return None if they\
      \ are marked bDeleteMe, even if they haven't actually been deleted yet.  This\
      \ is the reason I set the MyGlobalActor reference to None even if the 'if (\
      \ MyGlobalActor != None )' check returns false, in the code I posted.\n\nI hope\
      \ this helps clear up exactly where the danger lies in not correctly cleaning\
      \ up Actor references in your Objects.  It's very important to fully understand\
      \ how to correctly clean up Actor references if your mod has any interaction\
      \ between Actors and Objects.  \n\n{{innerbox| A good rule of thumb is to NEVER\
      \ have a global actor variable in a non-Actor subclass and when you must, make\
      \ it a private variable, and provide accessor functions like Get() or something,\
      \ so that you completely control the actual reference.\n\n:[[Legacy:Evolution|Evolution]]\n\
      \n}}\n\nHere is an example of how to safely use an actor in a non-Actor subclass:\n\
      \n<uscript>\nclass MyObjectThing extends Object;\n\n// assume MyActor is a subclass\
      \ of Actor that is in your mod\nvar private MyActor MyGlobalActor;\n\n// this\
      \ will indicate when MyObjectThing should not be allowed to create new actors\n\
      var private bool bLocked;\n\nfunction MyActor GetMyActor( optional Actor A )\n\
      {\n    if ( !bLocked && MyGlobalActor == None && A != None )\n        MyGlobalActor\
      \ = A.Spawn(class'MyActor');\n\t\t\n    return MyGlobalActor;\n}\n\n// Call\
      \ this function when you're no longer going to be using this object, \n// i.e.\
      \ you are releasing your reference to this object\n// e.g. if this was a GUIComponent,\
      \ you would call this function when the page is closed\nfunction Shutdown()\n\
      {\n    if ( MyGlobalActor != None )\n        MyGlobalActor.Destroy();\n\t\n\
      \    MyGlobalActor = None;\n    bLocked = True;\n}\n\nfunction DoSomeStuff()\n\
      {\n    local bool bExample;\n    local MyActor MyLocalActor;\n\t\n    // It's\
      \ good practice to avoid referencing MyGlobalActor directly, even from within\
      \ the same class\n    MyLocalActor = GetMyActor();\n    bExample = MyLocalActor.IsAnExample();\n\
      }\n</uscript>\n\n'''Foxpaw:''' Have you tested the above? I'm fairly certain\
      \ that you can't call Spawn from something that isn't subclassed from actor.\
      \ What with Spawn being defined in Actor and all. Plus the actor wouldn't have\
      \ a reference to a level, because it goes into the level that the actor that\
      \ spawned it was in.\n\n'''Evolution:''' Hehe, ya got me.  Yes, you'd need to\
      \ have a reference to an actor in order to call the Spawn() function.  I've\
      \ changed the above code snippet to represent this.   Thanks for pointing that\
      \ out.\n\n'''porkmanii:''' What of WeaponFire objects in Unreal Engine 2.5?\
      \  I have had the game crash as a result of a Weapon referencing the WeaponFire\
      \ objects/fire-modes of a Weapon which has been destroyed.  Does this mean Weapons\
      \ delete their WeaponFire objects when Destroyed, even if other Actors are still\
      \ referencing them?\n\n==Spawn() Method ==\n\nThe ''Spawn'' function is used\
      \ to create new actors. Unlike the ''New'' keyword, ''Spawn'' can only be called\
      \ from a non-[[Legacy:Static Function|static function]] and can only create\
      \ [[Legacy:Actor|actor]]s. If you need to call the ''Spawn'' function from a\
      \ non-actor object make sure it has access to an [[Legacy:Actor|Actor]] whose\
      \ ''Spawn'' function can be used then.\n\n<uscript>\nnative(278) final function\
      \ actor Spawn\n(\n   class<actor>     SpawnClass,\n   optional actor   SpawnOwner,\n\
      \   optional name    SpawnTag,\n   optional vector  SpawnLocation,\n   optional\
      \ rotator SpawnRotation\n);\n</uscript>\n\nIf ''SpawnLocation'' and/or ''SpawnRotation''\
      \ is not specified the spawner's ''Location'' and ''Rotation'' is used. (The\
      \ spawner is the actor ''Spawn'' is called from.)\n\n''Spawn'' returns an object\
      \ of the class specified in ''SpawnClass'', not an object of class [[Legacy:Actor|Actor]],\
      \ i.e. you don't have to cast it to the class you need. This is hardcoded in\
      \ the compiler. For example:\n\n<uscript>\nlocal Projectile P;\nP = Spawn(ProjectileClass,\
      \ Instigator,,, Instigator.ViewRotation);\n</uscript>\n\nYou don't have to use\
      \ <tt>P = Projectile(Spawn(ProjectileClass))</tt>, in fact this will cause an\
      \ error when compiling.\n\n:'''Warning:'''  Spawning an actor for an owner whose\
      \ deletion is pending reliably crashes the game with a \"Unknown code token\"\
      \ error.  If in doubt, make sure you check the new owner's ''bDeleteMe'' property\
      \ first.\n\nSpawn also allows you to set the Tag on the new actor. If you need\
      \ to set other properties on the new actor, you'll have to either call its accessors\
      \ or set them directly once it's created. For example:\n\n<uscript>\nlocal MyClass\
      \ P;\nP = Spawn(MyClass);\nP.SetMeaning(42);\nP.bHasMeaning = True;\n</uscript>\n\
      \nOn the other hand, if your goal is simply to have certain properties set before\
      \ anything else happens to the object, you can use default properties in a sort\
      \ of two part constructor:\n\n<uscript>\n// In the thing to be spawned..\nstatic\
      \ function PreInitialize( string SomeVar, int SomeNumber )\n{\n  // You can\
      \ preserve the original default values in other default variables if you want,\
      \ and restore them in prebeginplay. If you want.\n  default.SomeOtherVar = SomeVar;\n\
      \  default.SomeOtherNumber = SomeNumber;\n}\n\n// In the spawner..\nclass'Whatever'.static.PreInitialize(\
      \ \"Cats are soft.\", 5 );\nSpawn( class'Whatever' );\n</uscript>\n\nAnother,\
      \ probably less elegant-looking method would be exploiting the [[Legacy:Chain\
      \ Of Events When Spawning Actors|Chain of Events when Spawning Actors]]:\n\n\
      <uscript>\nclass TheSpawningClass extends SomeClass;\n\nevent GainedChild(Actor\
      \ Other)\n{\n  if ( Other.Class == class'WhatEver' ) {\n    // this is executed\
      \ before the newly spawned actor has a chance to execute its own PreBeginPlay()\
      \ event\n  }\n}\n\nfunction SpawnMyChild()\n{\n  Spawn(class'WhatEver', Self);\n\
      }\n</uscript>\n\n==Related Topics ==\n* [[Legacy:UnrealScript|UnrealScript]]\
      \ main topic page\n* [[Legacy:Class Syntax|Class Syntax]]\n* [[Legacy:Chain\
      \ Of Events When Spawning Actors|Chain of Events when Spawning Actors]]\n* [[Legacy:Chain\
      \ Of Events At Level Startup|Chain of Events at Level Startup]]\n* [[Legacy:Destroying\
      \ Objects|Destroying Objects]]\n\n----\n\n'''hc:''' Is there a way to get spawn\
      \ create actors that don't fit in the current location? I have to spawn some\
      \ big objects and move them out of the way, but spawn fails when there's not\
      \ enough room.. My current workaround is to set the default collision properties\
      \ to zero and have the object change them to something appropriate after it\
      \ has been spawned, but that's an ugly ugly hack.."
  properties: []
  revId: 45296
name: "Legacy:Creating Actors And Objects"
revision:
  revid: 45296
  parentid: 2030
  user: "WGH"
  timestamp: 1356131629.000000000
  comment: ""
timestamp: 1668755097.341442000
