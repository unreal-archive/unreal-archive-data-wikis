---
parse:
  title: "Legacy:UnrealScript Language Reference/States"
  text:
    text: "<p></p>\n<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n\
      </div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#UnrealScript_Language_Reference\"\
      ><span class=\"tocnumber\">1</span> <span class=\"toctext\">UnrealScript Language\
      \ Reference</span></a></li>\n<li class=\"toclevel-1 tocsection-2\"><a href=\"\
      #States\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">States</span></a>\n\
      <ul>\n<li class=\"toclevel-2 tocsection-3\"><a href=\"#Overview_of_States\"\
      ><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Overview of States</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-4\"><a href=\"#State_Labels_and_Latent_Functions\"\
      ><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">State Labels and\
      \ Latent Functions</span></a></li>\n<li class=\"toclevel-2 tocsection-5\"><a\
      \ href=\"#State_Inheritance_and_Scoping_Rules\"><span class=\"tocnumber\">2.3</span>\
      \ <span class=\"toctext\">State Inheritance and Scoping Rules</span></a></li>\n\
      <li class=\"toclevel-2 tocsection-6\"><a href=\"#Advanced_State_Programming\"\
      ><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Advanced State\
      \ Programming</span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-7\"\
      ><a href=\"#Related_Topics\"><span class=\"tocnumber\">3</span> <span class=\"\
      toctext\">Related Topics</span></a></li>\n</ul>\n</div>\n<p></p>\n<h2><span\
      \ class=\"mw-headline\" id=\"UnrealScript_Language_Reference\">UnrealScript\
      \ Language Reference</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=1\"\
      \ title=\"Edit section: UnrealScript Language Reference\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h2>\n<p><i>This subpage is part of\
      \ a document by Tim Sweeney. The Unreal Wiki has been granted permission to\
      \ host it. Please don't make any edits to these pages other than basic formatting\
      \ of the text. If you have more to say on a topic here, please start a new Wiki\
      \ page on it, for example from <a href=\"/Legacy:UnrealScript\" title=\"Legacy:UnrealScript\"\
      >UnrealScript</a> or <a href=\"/Legacy:Unreal_Engine\" title=\"Legacy:Unreal\
      \ Engine\">Unreal Engine</a>, and then add a \"related topics\" section to the\
      \ very end of a page here.</i></p>\n<blockquote class=\"legacyquote\">\n<p>Tim\
      \ Sweeney<br />\nEpic MegaGames, Inc.<br />\ntim@epicgames.com<br />\n<a rel=\"\
      nofollow\" class=\"external free\" href=\"http://www.epicgames.com\">http://www.epicgames.com</a></p>\n\
      </blockquote>\n<h2><span class=\"mw-headline\" id=\"States\">States</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=2\" title=\"\
      Edit section: States\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <h3><span class=\"mw-headline\" id=\"Overview_of_States\">Overview of States</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=3\" title=\"\
      Edit section: Overview of States\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Historically, game programmers have been using the\
      \ concept of states ever since games evolved past the \"pong\" phase. States\
      \ (and what is known as \"state machine programming\") are a natural way of\
      \ making complex object behaviour manageable. However, before UnrealScript,\
      \ states have not been supported at the language level, requiring developers\
      \ to create C/C++ \"switch\" statements based on the object?s state. Such code\
      \ was difficult to write and update.</p>\n<p>UnrealScript supports states at\
      \ the language level.</p>\n<p>In UnrealScript, each actor in the world is always\
      \ in one and only one state. Its state reflects the action it wants to perform.\
      \ For example, moving brushes have several states like \"StandOpenTimed\" and\
      \ \"BumpOpenTimed\". Pawns have several states such as \"Dying\", \"Attacking\"\
      , and \"Wandering\".</p>\n<p>In UnrealScript, you can write functions and code\
      \ which exist in a particular state. These functions are only called when the\
      \ actor is in that state. For example, say you?re writing a monster script,\
      \ and you?re contemplating how to handle the \"SeePlayer\" function. When you?re\
      \ wandering around, you want to attack the player you see. When you?re already\
      \ attacking the player, you want to continue on uninterrupted.</p>\n<p>The easiest\
      \ way to do this is by defining several states (Wandering and Attacking), and\
      \ writing a different version of \"Touch\" in each state. UnrealScript supports\
      \ this.</p>\n<p>Before delving deeper into states, you need to understand that\
      \ there are two major benefits to states, and one complication:</p>\n<ul>\n\
      <li><b>Benefit:</b> States provide a simple way to write state-specific functions,\
      \ so that you can handle the same function in different ways, depending on what\
      \ the actor is doing.</li>\n</ul>\n<ul>\n<li><b>Benefit:</b> With a state, you\
      \ can write special \"state code\", using all of the regular UnrealScript commands\
      \ plus several special functions known as \"latent functions\". A latent function\
      \ is a function which executes \"slowly\", and may return after a certain amount\
      \ of \"game time\" has passed. This enables you to perform time-based programming&#160;?\
      \ a major benefit which neither C, C++, nor Java offer. Namely, you can write\
      \ code in the same way you conceptualize it; for example, you can write a script\
      \ that says the equivalent of \"open this door; pause 2 seconds; play this sound\
      \ effect; open that door; release that monster and have it attack the player\"\
      . You can do this with simple, linear code, and the Unreal engine takes care\
      \ of the details of managing the time-based execution of the code.</li>\n</ul>\n\
      <ul>\n<li><b>Complication:</b> Now that you can have functions (like \"Touch\"\
      ) overridden in multiple states as well as in child classes, you have the burden\
      \ of figuring out exactly which \"Touch\" function is going to be called in\
      \ a specific situation. UnrealScript provides rules which clearly delineate\
      \ this process, but it is something you must be aware of if you create complex\
      \ hierarchies of classes and states.</li>\n</ul>\n<p>Here is an example of states\
      \ from the TriggerLight script:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"co1\">// Trigger turns the light on.</span>\n<span class=\"kw1\"\
      >state</span><span class=\"br0\">(</span><span class=\"br0\">)</span> TriggerTurnsOn\n\
      <span class=\"br0\">{</span>\n\t<span class=\"kw1\">function</span> <span class=\"\
      kw4\">Trigger</span><span class=\"br0\">(</span> <span class=\"kw9\">actor</span>\
      \ Other, <span class=\"kw9\">pawn</span> EventInstigator <span class=\"br0\"\
      >)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"kw4\">Trigger</span>\
      \ <span class=\"sy0\">=</span> <span class=\"kw5\">None</span>;\n\t\tDirection\
      \ <span class=\"sy0\">=</span> <span class=\"nu0\">1.0</span>;\n\t\t<span class=\"\
      kw3\">Enable</span><span class=\"br0\">(</span> <span class=\"st0\">'Tick'</span>\
      \ <span class=\"br0\">)</span>;\n\t<span class=\"br0\">}</span>\n<span class=\"\
      br0\">}</span>\n \n<span class=\"co1\">// Trigger turns the light off.</span>\n\
      <span class=\"kw1\">state</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span> TriggerTurnsOff\n<span class=\"br0\">{</span>\n\t<span class=\"kw1\"\
      >function</span> <span class=\"kw4\">Trigger</span><span class=\"br0\">(</span>\
      \ <span class=\"kw9\">actor</span> Other, <span class=\"kw9\">pawn</span> EventInstigator\
      \ <span class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw4\">Trigger</span> <span class=\"sy0\">=</span> <span class=\"kw5\">None</span>;\n\
      \t\tDirection <span class=\"sy0\">=</span> <span class=\"sy0\">-</span><span\
      \ class=\"nu0\">1.0</span>;\n\t\t<span class=\"kw3\">Enable</span><span class=\"\
      br0\">(</span> <span class=\"st0\">'Tick'</span> <span class=\"br0\">)</span>;\n\
      \t<span class=\"br0\">}</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>Here you are declaring two different states (TriggerTurnsOn and TriggerTurnsOff),\
      \ and you?re writing a different version of the Trigger function in each state.\
      \ Though you could pull off this implementation without states, using states\
      \ makes the code far more modular and expandable: in UnrealScript, you can easily\
      \ subclass an existing class, add new states, and add new functions. If you\
      \ had tried to do this without states, the resulting code would be more difficult\
      \ to expand later.</p>\n<p>A state can be declared as editable, meaning that\
      \ the user can set an actor?s state in UnrealEd, or not. To declare an editable\
      \ state, do the following:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\"\
      >\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"\
      kw1\">state</span><span class=\"br0\">(</span><span class=\"br0\">)</span> MyState\n\
      <span class=\"br0\">{</span>\n\t<span class=\"co1\">//...</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>To declare a non-editable state, do this:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">state</span> MyState\n\
      <span class=\"br0\">{</span>\n\t<span class=\"co1\">//...</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>You can also specify the automatic, or\
      \ initial state that an actor should be in by using the \"auto\" keyword. This\
      \ causes all new actors to be placed in that state when they first are activated:</p>\n\
      <div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript\
      \ source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\">auto</span> <span\
      \ class=\"kw1\">state</span> MyState\n<span class=\"br0\">{</span>\n\t<span\
      \ class=\"co1\">//...</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <h3><span class=\"mw-headline\" id=\"State_Labels_and_Latent_Functions\">State\
      \ Labels and Latent Functions</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=4\"\
      \ title=\"Edit section: State Labels and Latent Functions\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>In addition to functions,\
      \ a state can contain one or more labels followed by UnrealScript code. For\
      \ example:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n\
      <div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"kw1\"\
      >auto</span> <span class=\"kw1\">state</span> MyState\n<span class=\"br0\">{</span>\n\
      <span class=\"kw2\">Begin</span>:\n\t<span class=\"kw3\">Log</span><span class=\"\
      br0\">(</span> <span class=\"st0\">\"MyState has just begun!\"</span> <span\
      \ class=\"br0\">)</span>;\n\t<span class=\"kw4\">Sleep</span><span class=\"\
      br0\">(</span> <span class=\"nu0\">2.0</span> <span class=\"br0\">)</span>;\n\
      \t<span class=\"kw3\">Log</span><span class=\"br0\">(</span> <span class=\"\
      st0\">\"MyState has finished sleeping\"</span> <span class=\"br0\">)</span>;\n\
      \tgoto<span class=\"br0\">(</span> <span class=\"st0\">'Begin'</span> <span\
      \ class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>The above state code prints the message \"MyState has just begun!\", then\
      \ it pauses for two seconds, then it prints the message \"MyState has finished\
      \ sleeping\". The interesting thing in this example is the call to the latent\
      \ function \"Sleep\": this function call doesn?t return immediately, but returns\
      \ after a certain amount of game time has passed. Latent functions can only\
      \ be called from within state code, and not from within functions. Latent functions\
      \ let you manage complex chains of events which include the passage of time.</p>\n\
      <p>All state code begins with a label definition; in the above example the label\
      \ is named \"Begin\". The label provides a convenient entry point into the state\
      \ code. You can use any label name in state code, but the \"Begin\" label is\
      \ special: it is the default starting point for code in that state.</p>\n<p>There\
      \ are three main latent functions available to all actors:</p>\n<dl>\n<dt>Sleep(\
      \ float Seconds )&#160;</dt>\n<dd>Pauses the state execution for a certain amount\
      \ of time, and then continues.</dd>\n</dl>\n<dl>\n<dt>FinishAnim()&#160;</dt>\n\
      <dd>Waits until the current animation sequence you?re playing completes, and\
      \ then continues. This function makes it easy to write animation-driven scripts,\
      \ scripts whose execution is governed by mesh animations. For example, most\
      \ of the AI scripts are animation-driven (as opposed to time-driven), because\
      \ smooth animation is a key goal of the AI system.</dd>\n</dl>\n<dl>\n<dt>FinishInterpolation()&#160;</dt>\n\
      <dd>Waits for the current InterpolationPoint movement to complete, and then\
      \ continues.</dd>\n</dl>\n<p>The Pawn class defines several important latent\
      \ functions for actions such as navigating through the world and short-term\
      \ movement. See the separate AI docs for descriptions of their usage.</p>\n\
      <p>Three native UnrealScript functions are particularly useful when writing\
      \ state code:</p>\n<ul>\n<li>The \"Goto\" function (similar to the C/C++/Basic\
      \ goto) within a state causes the state code to continue executing at a different\
      \ label.</li>\n</ul>\n<ul>\n<li>The special Goto('') command within a state\
      \ causes the state code execution to stop. State code execution doesn?t continue\
      \ until you go to a new state, or go to a new label within the current state.</li>\n\
      </ul>\n<ul>\n<li>The \"GotoState\" function causes the actor to go to a new\
      \ state, and optionally continue at a specified label (if you don?t specify\
      \ a label, the default is the \"Begin\" label). You can call GotoState from\
      \ within state code, and it goes to the destination immediately. You can also\
      \ call GotoState from within any function in the actor, but that does not take\
      \ effect immediately: it doesn?t take effect until execution returns back to\
      \ the state code.</li>\n</ul>\n<p>Here is an example of the state concepts discussed\
      \ so far:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code mw-content-ltr\">\n\
      <div class=\"uscript source-uscript\">\n<pre class=\"de1\"><span class=\"co1\"\
      >// This is the automatic state to execute.</span>\n<span class=\"kw1\">auto</span>\
      \ <span class=\"kw1\">state</span> Idle\n<span class=\"br0\">{</span>\n\t<span\
      \ class=\"co1\">// When touched by another actor?</span>\n\t<span class=\"kw1\"\
      >function</span> <span class=\"kw4\">Touch</span><span class=\"br0\">(</span>\
      \ <span class=\"kw9\">actor</span> Other <span class=\"br0\">)</span>\n\t<span\
      \ class=\"br0\">{</span>\n\t\t<span class=\"kw3\">log</span><span class=\"br0\"\
      >(</span> <span class=\"st0\">\"I was touched, so I?m going to Attacking\"</span>\
      \ <span class=\"br0\">)</span>;\n\t\t<span class=\"kw3\">GotoState</span><span\
      \ class=\"br0\">(</span> <span class=\"st0\">'Attacking'</span> <span class=\"\
      br0\">)</span>;\n\t\t<span class=\"kw3\">Log</span><span class=\"br0\">(</span>\
      \ <span class=\"st0\">\"I have gone to the Attacking state\"</span> <span class=\"\
      br0\">)</span>;\n\t<span class=\"br0\">}</span>\n<span class=\"kw2\">Begin</span>:\n\
      \t<span class=\"kw3\">log</span><span class=\"br0\">(</span> <span class=\"\
      st0\">\"I am idle?\"</span> <span class=\"br0\">)</span>;\n\t<span class=\"\
      kw4\">sleep</span><span class=\"br0\">(</span> <span class=\"nu0\">10</span>\
      \ <span class=\"br0\">)</span>;\n\tgoto<span class=\"br0\">(</span> <span class=\"\
      st0\">'Begin'</span> <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n\
      \ \n<span class=\"co1\">// Attacking state.</span>\n<span class=\"kw1\">state</span>\
      \ Attacking\n<span class=\"br0\">{</span>\n<span class=\"kw2\">Begin</span>:\n\
      \t<span class=\"kw3\">Log</span><span class=\"br0\">(</span> <span class=\"\
      st0\">\"I am executing the attacking state code\"</span> <span class=\"br0\"\
      >)</span>;\n\t<span class=\"co1\">//...</span>\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>When you run this program and then go touch the actor, you will see:</p>\n\
      <pre> I am idle...\n I am idle...\n I am idle...\n I was touched, so I?m going\
      \ to Attacking\n I have gone to the Attacking state\n I am executing the attacking\
      \ state code\n</pre>\n<p>Make sure you understand this important aspect of GotoState:\
      \ When you call GotoState from within a function, it does not go to the destination\
      \ immediately, rather it goes there once execution returns back to the state\
      \ code.</p>\n<h3><span class=\"mw-headline\" id=\"State_Inheritance_and_Scoping_Rules\"\
      >State Inheritance and Scoping Rules</span><span class=\"mw-editsection\"><span\
      \ class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=5\"\
      \ title=\"Edit section: State Inheritance and Scoping Rules\">edit</a><span\
      \ class=\"mw-editsection-bracket\">]</span></span></h3>\n<p>In UnrealScript,\
      \ when you subclass an existing class, your new class inherits all of the variables,\
      \ functions and states from its parent class. This is well-understood.</p>\n\
      <p>However, the addition of the state abstraction to the UnrealScript programming\
      \ model adds additional twists to the inheritance and scoping rules. The complete\
      \ inheritance rules are:</p>\n<ul>\n<li>A new class inherits all of the variables\
      \ from its parent class.</li>\n</ul>\n<ul>\n<li>A new class inherits all of\
      \ its parent class's non-state functions. You can override any of those inherited\
      \ non-state functions. You can add entirely new non-state functions.</li>\n\
      </ul>\n<ul>\n<li>A new class inherits all of its parent class's states, including\
      \ the functions and labels within those states. You can override any of the\
      \ inherited state functions, and you can override any of the inherited state\
      \ labels, you can add new state functions, and you can add new state labels.</li>\n\
      </ul>\n<p>Here is an example of all the overriding rules:</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"co1\">// Here is an example parent class.</span>\n\
      <span class=\"kw1\">class</span> MyParentClass <span class=\"kw1\">extends</span>\
      \ <span class=\"kw9\">Actor</span>;\n \n<span class=\"co1\">// A non-state function.</span>\n\
      <span class=\"kw1\">function</span> MyInstanceFunction<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\t<span class=\"kw3\"\
      >log</span><span class=\"br0\">(</span> <span class=\"st0\">\"Executing MyInstanceFunction\"\
      </span> <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span>\n \n<span\
      \ class=\"co1\">// A state.</span>\n<span class=\"kw1\">state</span> MyState\n\
      <span class=\"br0\">{</span>\n\t<span class=\"co1\">// A state function.</span>\n\
      \t<span class=\"kw1\">function</span> MyStateFunction<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw3\">Log</span><span class=\"br0\">(</span> <span class=\"st0\">\"Executing\
      \ MyStateFunction\"</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\"\
      >}</span>\n<span class=\"co1\">// The \"Begin\" label.</span>\n<span class=\"\
      kw2\">Begin</span>:\n\t<span class=\"kw3\">Log</span><span class=\"br0\">(</span><span\
      \ class=\"st0\">\"Beginning MyState\"</span><span class=\"br0\">)</span>;\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"co1\">// Here is an example child class.</span>\n\
      <span class=\"kw1\">class</span> MyChildClass <span class=\"kw1\">extends</span>\
      \ MyParent<span class=\"re0\">Class</span>&lt; SEMI &gt;\n \n<span class=\"\
      co1\">// Here I?m overriding a non-state function.</span>\n<span class=\"kw1\"\
      >function</span> MyInstanceFunction<span class=\"br0\">(</span><span class=\"\
      br0\">)</span>\n<span class=\"br0\">{</span>\n\t<span class=\"kw3\">Log</span><span\
      \ class=\"br0\">(</span> <span class=\"st0\">\"Executing MyInstanceFunction\
      \ in child class\"</span> <span class=\"br0\">)</span>;\n<span class=\"br0\"\
      >}</span>\n \n<span class=\"co1\">// Here I?m redeclaring MyState so that I\
      \ can override MyStateFunction.</span>\n<span class=\"kw1\">state</span> MyState\n\
      <span class=\"br0\">{</span>\n\t<span class=\"co1\">// Here I?m overriding MyStateFunction.</span>\n\
      \t<span class=\"kw1\">function</span> MyStateFunction<span class=\"br0\">(</span><span\
      \ class=\"br0\">)</span>\n\t<span class=\"br0\">{</span>\n\t\t<span class=\"\
      kw3\">Log</span><span class=\"br0\">(</span> <span class=\"st0\">\"Executing\
      \ MyStateFunction\"</span> <span class=\"br0\">)</span>;\n\t<span class=\"br0\"\
      >}</span>\n<span class=\"co1\">// Here I?m overriding the \"Begin\" label.</span>\n\
      <span class=\"kw2\">Begin</span>:\n\t<span class=\"kw3\">Log</span><span class=\"\
      br0\">(</span> <span class=\"st0\">\"Beginning MyState in MyChildClass\"</span>\
      \ <span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p>When you have a function that is implemented globally, in one or\
      \ more states, and in one or more parent classes, you need to understand which\
      \ version of the function will be called in a given context. The scoping rules,\
      \ which resolves these complex situations, are:</p>\n<ul>\n<li>If the object\
      \ is in a state, and an implementation of the function exists somewhere in that\
      \ state (either in the actor?s class or in some parent class), the most-derived\
      \ state version of the function is called.</li>\n</ul>\n<ul>\n<li>Otherwise,\
      \ the most-derived non-state version of the function is called.</li>\n</ul>\n\
      <h3><span class=\"mw-headline\" id=\"Advanced_State_Programming\">Advanced State\
      \ Programming</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=6\"\
      \ title=\"Edit section: Advanced State Programming\">edit</a><span class=\"\
      mw-editsection-bracket\">]</span></span></h3>\n<p>If a state doesn?t override\
      \ a state of the same name in the parent class, then you can optionally use\
      \ the \"extends\" keyword to make the state extend on an existing state in the\
      \ current class. This is useful, for example, in a situation where you have\
      \ a group of similar states (such as MeleeAttacking and RangeAttacking) which\
      \ have a lot of functionality in common. In this case you could declare a base\
      \ Attacking state as follows:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"co1\">// Base Attacking state.</span>\n<span class=\"kw1\">state</span>\
      \ Attacking\n<span class=\"br0\">{</span>\n\t<span class=\"co1\">// Stick base\
      \ functions here...</span>\n<span class=\"br0\">}</span> \n \n<span class=\"\
      co1\">// Attacking up-close.</span>\n<span class=\"kw1\">state</span> MeleeAttacking\
      \ <span class=\"kw1\">extends</span> Attacking\n<span class=\"br0\">{</span>\n\
      \t<span class=\"co1\">// Stick specialized functions here...</span>\n<span class=\"\
      br0\">}</span> \n \n<span class=\"co1\">// Attacking from a distance.</span>\n\
      <span class=\"kw1\">state</span> RangeAttacking <span class=\"kw1\">extends</span>\
      \ Attacking\n<span class=\"br0\">{</span>\n\t<span class=\"co1\">// Stick specialized\
      \ functions here...</span>\n<span class=\"br0\">}</span></pre></div>\n</div>\n\
      <p>A state can optionally use the \"ignores\" specifier to ignore functions\
      \ while in a state. The syntax for this is:</p>\n<div dir=\"ltr\" class=\"mw-geshi\
      \ mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"\
      de1\"><span class=\"co1\">// Declare a state.</span>\n<span class=\"kw1\">state</span>\
      \ Retreating\n<span class=\"br0\">{</span>\n\t<span class=\"co1\">// Ignore\
      \ the following messages...</span>\n\t<span class=\"kw1\">ignores</span> <span\
      \ class=\"kw4\">Touch</span>, <span class=\"kw4\">UnTouch</span>, MyFunction;\n\
      \ \n\t<span class=\"co1\">// Stick functions here...</span>\n<span class=\"\
      br0\">}</span></pre></div>\n</div>\n<p>You can tell what specific state an actor\
      \ is in from its \"state\" variable, a variable of type \"name\", or by the\
      \ Actor function <code>GetStateName()</code>.</p>\n<p>It is possible for an\
      \ actor to be in \"no state\" by using <code>GotoState(<i>)</i></code><i>. When\
      \ an actor is in \"no state\", only its global (non-state) functions are called.</i></p>\n\
      <p>Whever you use the GotoState command to set an actor?s state, the engine\
      \ can call two special notification functions, if you have defined them: <code>EndState()</code>\
      \ and <code>BeginState()</code>. EndState is called in the current state immediately\
      \ before the new state is begun, and BeginState is called immediately after\
      \ the new state begins. These functions provide a convenient place to do any\
      \ state-specific initialization and cleanup which your state may require.</p>\n\
      <hr />\n<p>Prev Page: <a href=\"/Legacy:UnrealScript_Language_Reference/Program_Structure\"\
      \ title=\"Legacy:UnrealScript Language Reference/Program Structure\">Legacy:UnrealScript\
      \ Language Reference/Program Structure</a> – <b>Section 6 of 9</b> – Next Page:\
      \ <a href=\"/Legacy:UnrealScript_Language_Reference/Language_Functionality\"\
      \ title=\"Legacy:UnrealScript Language Reference/Language Functionality\">Legacy:UnrealScript\
      \ Language Reference/Language Functionality</a></p>\n<h2><span class=\"mw-headline\"\
      \ id=\"Related_Topics\">Related Topics</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:UnrealScript_Language_Reference/States?section=7\"\
      \ title=\"Edit section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:State\" title=\"Legacy:State\"\
      >State</a></li>\n</ul>\n\n<!-- \nNewPP limit report\nCPU time usage: 0.159 seconds\n\
      Real time usage: 0.254 seconds\nPreprocessor visited node count: 151/1000000\n\
      Preprocessor generated node count: 343/1000000\nPost‐expand include size: 362/2097152\
      \ bytes\nTemplate argument size: 96/2097152 bytes\nHighest expansion depth:\
      \ 3/40\nExpensive parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion\
      \ time report (%,ms,calls,template)\n100.00%    4.528      1 - -total\n100.00%\
      \    4.528      1 - Template:Innerbox\n-->\n\n<!-- Saved in parser cache with\
      \ key wiki:pcache:idhash:3288-0!*!0!!en!*!* and timestamp 20221117234738 and\
      \ revision id 8514\n -->\n"
  categories: []
  links:
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript Language Reference/Language Functionality"
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript Language Reference/Program Structure"
  - ns: 100
    exists: true
    name: "Legacy:Unreal Engine"
  - ns: 100
    exists: true
    name: "Legacy:State"
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript"
  templates:
  - ns: 10
    exists: true
    name: "Template:Innerbox"
  images: []
  externallinks:
  - "http://www.epicgames.com"
  sections:
  - toclevel: 1
    level: "2"
    line: "UnrealScript Language Reference"
    number: "1"
    index: "1"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 0
    anchor: "UnrealScript_Language_Reference"
  - toclevel: 1
    level: "2"
    line: "States"
    number: "2"
    index: "2"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 591
    anchor: "States"
  - toclevel: 2
    level: "3"
    line: "Overview of States"
    number: "2.1"
    index: "3"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 604
    anchor: "Overview_of_States"
  - toclevel: 2
    level: "3"
    line: "State Labels and Latent Functions"
    number: "2.2"
    index: "4"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 4998
    anchor: "State_Labels_and_Latent_Functions"
  - toclevel: 2
    level: "3"
    line: "State Inheritance and Scoping Rules"
    number: "2.3"
    index: "5"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 8850
    anchor: "State_Inheritance_and_Scoping_Rules"
  - toclevel: 2
    level: "3"
    line: "Advanced State Programming"
    number: "2.4"
    index: "6"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 11299
    anchor: "Advanced_State_Programming"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "3"
    index: "7"
    fromtitle: "Legacy:UnrealScript_Language_Reference/States"
    byteoffset: 13353
    anchor: "Related_Topics"
  displaytitle: "Legacy:UnrealScript Language Reference/States"
  iwlinks: []
  wikitext:
    text: "==UnrealScript Language Reference ==\n\n''This subpage is part of a document\
      \ by Tim Sweeney. The Unreal Wiki has been granted permission to host it. Please\
      \ don't make any edits to these pages other than basic formatting of the text.\
      \ If you have more to say on a topic here, please start a new Wiki page on it,\
      \ for example from [[Legacy:UnrealScript|UnrealScript]] or [[Legacy:Unreal Engine|Unreal\
      \ Engine]], and then add a \"related topics\" section to the very end of a page\
      \ here.''\n\n{{innerbox| Tim Sweeney <br />Epic MegaGames, Inc. <br />tim@epicgames.com\
      \ <br />http://www.epicgames.com\n\n}}\n\n==States ==\n\n===Overview of States\
      \ ===\n\nHistorically, game programmers have been using the concept of states\
      \ ever since games evolved past the \"pong\" phase. States (and what is known\
      \ as \"state machine programming\") are a natural way of making complex object\
      \ behaviour manageable. However, before UnrealScript, states have not been supported\
      \ at the language level, requiring developers to create C/C++ \"switch\" statements\
      \ based on the object?s state. Such code was difficult to write and update.\n\
      \nUnrealScript supports states at the language level.\n\nIn UnrealScript, each\
      \ actor in the world is always in one and only one state. Its state reflects\
      \ the action it wants to perform. For example, moving brushes have several states\
      \ like \"StandOpenTimed\" and \"BumpOpenTimed\". Pawns have several states such\
      \ as \"Dying\", \"Attacking\", and \"Wandering\".\n\nIn UnrealScript, you can\
      \ write functions and code which exist in a particular state. These functions\
      \ are only called when the actor is in that state. For example, say you?re writing\
      \ a monster script, and you?re contemplating how to handle the \"SeePlayer\"\
      \ function. When you?re wandering around, you want to attack the player you\
      \ see. When you?re already attacking the player, you want to continue on uninterrupted.\n\
      \nThe easiest way to do this is by defining several states (Wandering and Attacking),\
      \ and writing a different version of \"Touch\" in each state. UnrealScript supports\
      \ this.\n\nBefore delving deeper into states, you need to understand that there\
      \ are two major benefits to states, and one complication:\n\n* '''Benefit:'''\
      \ States provide a simple way to write state-specific functions, so that you\
      \ can handle the same function in different ways, depending on what the actor\
      \ is doing.\n\n* '''Benefit:''' With a state, you can write special \"state\
      \ code\", using all of the regular UnrealScript commands plus several special\
      \ functions known as \"latent functions\". A latent function is a function which\
      \ executes \"slowly\", and may return after a certain amount of \"game time\"\
      \ has passed. This enables you to perform time-based programming ? a major benefit\
      \ which neither C, C++, nor Java offer. Namely, you can write code in the same\
      \ way you conceptualize it; for example, you can write a script that says the\
      \ equivalent of \"open this door; pause 2 seconds; play this sound effect; open\
      \ that door; release that monster and have it attack the player\". You can do\
      \ this with simple, linear code, and the Unreal engine takes care of the details\
      \ of managing the time-based execution of the code.\n\n* '''Complication:'''\
      \ Now that you can have functions (like \"Touch\") overridden in multiple states\
      \ as well as in child classes, you have the burden of figuring out exactly which\
      \ \"Touch\" function is going to be called in a specific situation. UnrealScript\
      \ provides rules which clearly delineate this process, but it is something you\
      \ must be aware of if you create complex hierarchies of classes and states.\n\
      \nHere is an example of states from the TriggerLight script:\n\n<uscript>\n\
      // Trigger turns the light on.\nstate() TriggerTurnsOn\n{\n\tfunction Trigger(\
      \ actor Other, pawn EventInstigator )\n\t{\n\t\tTrigger = None;\n\t\tDirection\
      \ = 1.0;\n\t\tEnable( 'Tick' );\n\t}\n}\n\n// Trigger turns the light off.\n\
      state() TriggerTurnsOff\n{\n\tfunction Trigger( actor Other, pawn EventInstigator\
      \ )\n\t{\n\t\tTrigger = None;\n\t\tDirection = -1.0;\n\t\tEnable( 'Tick' );\n\
      \t}\n}\n</uscript>\n\nHere you are declaring two different states (TriggerTurnsOn\
      \ and TriggerTurnsOff), and you?re writing a different version of the Trigger\
      \ function in each state. Though you could pull off this implementation without\
      \ states, using states makes the code far more modular and expandable: in UnrealScript,\
      \ you can easily subclass an existing class, add new states, and add new functions.\
      \ If you had tried to do this without states, the resulting code would be more\
      \ difficult to expand later.\n\nA state can be declared as editable, meaning\
      \ that the user can set an actor?s state in UnrealEd, or not. To declare an\
      \ editable state, do the following:\n\n<uscript>\nstate() MyState\n{\n\t//...\n\
      }\n</uscript>\n\nTo declare a non-editable state, do this:\n\n<uscript>\nstate\
      \ MyState\n{\n\t//...\n}\n</uscript>\n\nYou can also specify the automatic,\
      \ or initial state that an actor should be in by using the \"auto\" keyword.\
      \ This causes all new actors to be placed in that state when they first are\
      \ activated:\n\n<uscript>\nauto state MyState\n{\n\t//...\n}\n</uscript>\n\n\
      ===State Labels and Latent Functions ===\n\nIn addition to functions, a state\
      \ can contain one or more labels followed by UnrealScript code. For example:\n\
      \n<uscript>\nauto state MyState\n{\nBegin:\n\tLog( \"MyState has just begun!\"\
      \ );\n\tSleep( 2.0 );\n\tLog( \"MyState has finished sleeping\" );\n\tgoto(\
      \ 'Begin' );\n}\n</uscript>\n\nThe above state code prints the message \"MyState\
      \ has just begun!\", then it pauses for two seconds, then it prints the message\
      \ \"MyState has finished sleeping\". The interesting thing in this example is\
      \ the call to the latent function \"Sleep\": this function call doesn?t return\
      \ immediately, but returns after a certain amount of game time has passed. Latent\
      \ functions can only be called from within state code, and not from within functions.\
      \ Latent functions let you manage complex chains of events which include the\
      \ passage of time.\n\nAll state code begins with a label definition; in the\
      \ above example the label is named \"Begin\". The label provides a convenient\
      \ entry point into the state code. You can use any label name in state code,\
      \ but the \"Begin\" label is special: it is the default starting point for code\
      \ in that state.\n\nThere are three main latent functions available to all actors:\
      \ \n\n; Sleep( float Seconds ) : Pauses the state execution for a certain amount\
      \ of time, and then continues.\n\n; FinishAnim() : Waits until the current animation\
      \ sequence you?re playing completes, and then continues. This function makes\
      \ it easy to write animation-driven scripts, scripts whose execution is governed\
      \ by mesh animations. For example, most of the AI scripts are animation-driven\
      \ (as opposed to time-driven), because smooth animation is a key goal of the\
      \ AI system. \n\n; FinishInterpolation() : Waits for the current InterpolationPoint\
      \ movement to complete, and then continues.\n\nThe Pawn class defines several\
      \ important latent functions for actions such as navigating through the world\
      \ and short-term movement. See the separate AI docs for descriptions of their\
      \ usage.\n\nThree native UnrealScript functions are particularly useful when\
      \ writing state code: \n\n* The \"Goto\" function (similar to the C/C++/Basic\
      \ goto) within a state causes the state code to continue executing at a different\
      \ label. \n\n* The special <nowiki>Goto('')</nowiki> command within a state\
      \ causes the state code execution to stop. State code execution doesn?t continue\
      \ until you go to a new state, or go to a new label within the current state.\
      \ \n\n* The \"GotoState\" function causes the actor to go to a new state, and\
      \ optionally continue at a specified label (if you don?t specify a label, the\
      \ default is the \"Begin\" label). You can call GotoState from within state\
      \ code, and it goes to the destination immediately. You can also call GotoState\
      \ from within any function in the actor, but that does not take effect immediately:\
      \ it doesn?t take effect until execution returns back to the state code.\n\n\
      Here is an example of the state concepts discussed so far:\n\n<uscript>\n//\
      \ This is the automatic state to execute.\nauto state Idle\n{\n\t// When touched\
      \ by another actor?\n\tfunction Touch( actor Other )\n\t{\n\t\tlog( \"I was\
      \ touched, so I?m going to Attacking\" );\n\t\tGotoState( 'Attacking' );\n\t\
      \tLog( \"I have gone to the Attacking state\" );\n\t}\nBegin:\n\tlog( \"I am\
      \ idle?\" );\n\tsleep( 10 );\n\tgoto( 'Begin' );\n}\n\n// Attacking state.\n\
      state Attacking\n{\nBegin:\n\tLog( \"I am executing the attacking state code\"\
      \ );\n\t//...\n}\n</uscript>\n\nWhen you run this program and then go touch\
      \ the actor, you will see:\n\n  I am idle...\n  I am idle...\n  I am idle...\n\
      \  I was touched, so I?m going to Attacking\n  I have gone to the Attacking\
      \ state\n  I am executing the attacking state code\n\nMake sure you understand\
      \ this important aspect of GotoState: When you call GotoState from within a\
      \ function, it does not go to the destination immediately, rather it goes there\
      \ once execution returns back to the state code.\n\n===State Inheritance and\
      \ Scoping Rules ===\n\nIn UnrealScript, when you subclass an existing class,\
      \ your new class inherits all of the variables, functions and states from its\
      \ parent class. This is well-understood.\n\nHowever, the addition of the state\
      \ abstraction to the UnrealScript programming model adds additional twists to\
      \ the inheritance and scoping rules. The complete inheritance rules are:\n\n\
      * A new class inherits all of the variables from its parent class. \n\n* A new\
      \ class inherits all of its parent class's non-state functions. You can override\
      \ any of those inherited non-state functions. You can add entirely new non-state\
      \ functions.\n\n* A new class inherits all of its parent class's states, including\
      \ the functions and labels within those states. You can override any of the\
      \ inherited state functions, and you can override any of the inherited state\
      \ labels, you can add new state functions, and you can add new state labels.\n\
      \nHere is an example of all the overriding rules:\n\n<uscript>\n// Here is an\
      \ example parent class.\nclass MyParentClass extends Actor;\n\n// A non-state\
      \ function.\nfunction MyInstanceFunction()\n{\n\tlog( \"Executing MyInstanceFunction\"\
      \ );\n}\n\n// A state.\nstate MyState\n{\n\t// A state function.\n\tfunction\
      \ MyStateFunction()\n\t{\n\t\tLog( \"Executing MyStateFunction\" );\n\t}\n//\
      \ The \"Begin\" label.\nBegin:\n\tLog(\"Beginning MyState\");\n}\n</uscript>\n\
      \n<uscript>\n// Here is an example child class.\nclass MyChildClass extends\
      \ MyParentClass;\n\n// Here I?m overriding a non-state function.\nfunction MyInstanceFunction()\n\
      {\n\tLog( \"Executing MyInstanceFunction in child class\" );\n}\n\n// Here I?m\
      \ redeclaring MyState so that I can override MyStateFunction.\nstate MyState\n\
      {\n\t// Here I?m overriding MyStateFunction.\n\tfunction MyStateFunction()\n\
      \t{\n\t\tLog( \"Executing MyStateFunction\" );\n\t}\n// Here I?m overriding\
      \ the \"Begin\" label.\nBegin:\n\tLog( \"Beginning MyState in MyChildClass\"\
      \ );\n}\n</uscript>\n\nWhen you have a function that is implemented globally,\
      \ in one or more states, and in one or more parent classes, you need to understand\
      \ which version of the function will be called in a given context. The scoping\
      \ rules, which resolves these complex situations, are:\n\n* If the object is\
      \ in a state, and an implementation of the function exists somewhere in that\
      \ state (either in the actor?s class or in some parent class), the most-derived\
      \ state version of the function is called. \n\n* Otherwise, the most-derived\
      \ non-state version of the function is called.\n\n===Advanced State Programming\
      \ ===\n\nIf a state doesn?t override a state of the same name in the parent\
      \ class, then you can optionally use the \"extends\" keyword to make the state\
      \ extend on an existing state in the current class. This is useful, for example,\
      \ in a situation where you have a group of similar states (such as MeleeAttacking\
      \ and RangeAttacking) which have a lot of functionality in common. In this case\
      \ you could declare a base Attacking state as follows:\n\n<uscript>\n// Base\
      \ Attacking state.\nstate Attacking\n{\n\t// Stick base functions here...\n\
      } \n\n// Attacking up-close.\nstate MeleeAttacking extends Attacking\n{\n\t\
      // Stick specialized functions here...\n} \n\n// Attacking from a distance.\n\
      state RangeAttacking extends Attacking\n{\n\t// Stick specialized functions\
      \ here...\n}\n</uscript>\n\nA state can optionally use the \"ignores\" specifier\
      \ to ignore functions while in a state. The syntax for this is:\n\n<uscript>\n\
      // Declare a state.\nstate Retreating\n{\n\t// Ignore the following messages...\n\
      \tignores Touch, UnTouch, MyFunction;\n\n\t// Stick functions here...\n}\n</uscript>\n\
      \nYou can tell what specific state an actor is in from its \"state\" variable,\
      \ a variable of type \"name\", or by the Actor function <code>GetStateName()</code>.\n\
      \nIt is possible for an actor to be in \"no state\" by using <code>GotoState('')</code>.\
      \ When an actor is in \"no state\", only its global (non-state) functions are\
      \ called.\n\nWhever you use the GotoState command to set an actor?s state, the\
      \ engine can call two special notification functions, if you have defined them:\
      \ <code>EndState()</code> and <code>BeginState()</code>. EndState is called\
      \ in the current state immediately before the new state is begun, and BeginState\
      \ is called immediately after the new state begins. These functions provide\
      \ a convenient place to do any state-specific initialization and cleanup which\
      \ your state may require.\n\n----\n\nPrev Page: [[:{{SUBJECTSPACE}}:{{BASEPAGENAME}}/Program\
      \ Structure]] &ndash; '''Section 6 of 9''' &ndash; Next Page: [[:{{SUBJECTSPACE}}:{{BASEPAGENAME}}/Language\
      \ Functionality]]\n\n==Related Topics==\n* [[Legacy:State|State]]"
  properties: []
  revId: 8514
name: "Legacy:UnrealScript Language Reference/States"
revision:
  revid: 8514
  parentid: 8516
  user: "SuperApe"
  timestamp: 1153926693.000000000
  comment: "*"
timestamp: 1668774753.676418000
