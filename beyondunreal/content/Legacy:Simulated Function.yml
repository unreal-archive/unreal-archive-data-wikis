---
parse:
  title: "Legacy:Simulated Function"
  text:
    text: "<p>Roughly speaking, a <b>simulated function</b> is a function in an <a\
      \ href=\"/Legacy:Actor\" title=\"Legacy:Actor\">Actor</a>-derived class that\
      \ <i>can</i> be called on a client in a network game.</p>\n<p>Conversely, non-simulated\
      \ functions in an Actor-derived class cannot be executed on a client in a network\
      \ game, except in some special cases where the client owning that actor is the\
      \ authority on that actor.</p>\n<p>Simulated functions are declared with the\
      \ <a href=\"/Legacy:Function\" title=\"Legacy:Function\" class=\"mw-redirect\"\
      >function</a> modifier keyword <i>simulated</i>:</p>\n<div dir=\"ltr\" class=\"\
      mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n\
      <pre class=\"de1\"><span class=\"kw1\">simulated</span> <span class=\"kw1\"\
      >function</span> <span class=\"kw5\">bool</span> MyFunction<span class=\"br0\"\
      >(</span><span class=\"kw5\">bool</span> FirstParam<span class=\"br0\">)</span>\n\
      <span class=\"br0\">{</span>\n <span class=\"co1\">// function code</span>\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<p><br /></p>\n<p></p>\n<div\
      \ id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">\n<h2>Contents</h2>\n</div>\n\
      <ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Strict_Definition\"><span\
      \ class=\"tocnumber\">1</span> <span class=\"toctext\">Strict Definition</span></a>\n\
      <ul>\n<li class=\"toclevel-2 tocsection-2\"><a href=\"#Some_Clarifications\"\
      ><span class=\"tocnumber\">1.1</span> <span class=\"toctext\">Some Clarifications</span></a></li>\n\
      </ul>\n</li>\n<li class=\"toclevel-1 tocsection-3\"><a href=\"#Executing_Simulated_Functions\"\
      ><span class=\"tocnumber\">2</span> <span class=\"toctext\">Executing Simulated\
      \ Functions</span></a>\n<ul>\n<li class=\"toclevel-2 tocsection-4\"><a href=\"\
      #Simulated_Engine_Events\"><span class=\"tocnumber\">2.1</span> <span class=\"\
      toctext\">Simulated Engine Events</span></a></li>\n<li class=\"toclevel-2 tocsection-5\"\
      ><a href=\"#Replication_Myth:_.22Simulated_Functions_Can_Only_Be_Called_From_Other_Simulated_Functions.22\"\
      ><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Replication Myth:\
      \ \"Simulated Functions Can Only Be Called From Other Simulated Functions\"\
      </span></a></li>\n</ul>\n</li>\n<li class=\"toclevel-1 tocsection-6\"><a href=\"\
      #PlaySound.28.29_and_PlayOwnedSound.28.29_Replication_Magic\"><span class=\"\
      tocnumber\">3</span> <span class=\"toctext\">PlaySound() and PlayOwnedSound()\
      \ Replication Magic</span></a></li>\n<li class=\"toclevel-1 tocsection-7\"><a\
      \ href=\"#Overriding_Simulated_Functions\"><span class=\"tocnumber\">4</span>\
      \ <span class=\"toctext\">Overriding Simulated Functions</span></a></li>\n<li\
      \ class=\"toclevel-1 tocsection-8\"><a href=\"#Simulated_States\"><span class=\"\
      tocnumber\">5</span> <span class=\"toctext\">Simulated States</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-9\"><a href=\"#Related_Topics\"><span class=\"\
      tocnumber\">6</span> <span class=\"toctext\">Related Topics</span></a></li>\n\
      <li class=\"toclevel-1 tocsection-10\"><a href=\"#Discussion\"><span class=\"\
      tocnumber\">7</span> <span class=\"toctext\">Discussion</span></a></li>\n</ul>\n\
      </div>\n<p></p>\n<h2><span class=\"mw-headline\" id=\"Strict_Definition\">Strict\
      \ Definition</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Simulated_Function?section=1\" title=\"Edit\
      \ section: Strict Definition\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p>Functions that are called in the context of an actor\
      \ will not be executed if the <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\"\
      >Actor</a>'s local <a href=\"/Legacy:Role\" title=\"Legacy:Role\">Role</a> (not\
      \ RemoteRole!) is less than or equal to <code>ROLE_SimulatedProxy</code> <b>unless</b>\
      \ the function is declared as <i>simulated</i> or as <i>native</i>.</p>\n<h3><span\
      \ class=\"mw-headline\" id=\"Some_Clarifications\">Some Clarifications</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Simulated_Function?section=2\" title=\"Edit section: Some\
      \ Clarifications\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h3>\n\
      <ul>\n<li>An Actor's clientside Role takes the value of the serverside RemoteRole\
      \ and the clientside RemoteRole takes the serverside value of Role. This definition\
      \ talks about the local <i>Role</i> value.</li>\n<li>\"Less than or equal to\
      \ <code>ROLE_SimulatedProxy</code>\" actually means <code>ROLE_SimulatedProxy</code>\
      \ or <code>ROLE_DumbProxy</code>. <code>ROLE_None</code> would also be \"less\
      \ than\" <code>ROLE_SimulatedProxy</code>, but this value prevents actors from\
      \ being replicated, so it should never appear as the value of the actor's local\
      \ Role.</li>\n<li>Functions in object classes not derived from Actor are not\
      \ affected by network roles and thus will always execute.</li>\n<li><a href=\"\
      /Legacy:Static_Function\" title=\"Legacy:Static Function\">Static functions</a>\
      \ are executed in the context of a class (as opposed to the context of an actor\
      \ or other object), which means they are not affected by network roles and thus\
      \ will always execute.</li>\n<li>It doesn't matter where the function call originated.\
      \ The definition described above is always applied if the function is supposed\
      \ to be executed in the context of an actor.</li>\n</ul>\n<h2><span class=\"\
      mw-headline\" id=\"Executing_Simulated_Functions\">Executing Simulated Functions</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Simulated_Function?section=3\" title=\"Edit section: Executing\
      \ Simulated Functions\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>Being <i>able</i> to execute a function doesn't mean it <i>will</i> be executed.\
      \ Function calls always stay on the same machine unless there's a valid replication\
      \ statement for the function. In that case the function will only be executed\
      \ on the machine the function call was replicated to.</p>\n<p>This means that\
      \ you basically have two ways of executing a simulated function client-side:</p>\n\
      <ol>\n<li>Call it from another client-side function. PostBeginPlay, Tick or\
      \ HitWall are good candidates for this. Beware of simulated Timer functions,\
      \ they will only be executed if SetTimer was actually executed on that machine,\
      \ i.e. if you set the timer on the server, then Timer will only be called on\
      \ the server, even if it is declared simulated. <b>Server and client have independent\
      \ timers.</b></li>\n<li>Replicate the function call from the server to the client.\
      \ Note that replicated functions can only be replicated to a single machine,\
      \ either from the client of the player owning this actor to the server or from\
      \ the server to the client of the player owning this actor. Replicated functions\
      \ will be executed <b>only</b> on the replication destination.</li>\n</ol>\n\
      <h3><span class=\"mw-headline\" id=\"Simulated_Engine_Events\">Simulated Engine\
      \ Events</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Simulated_Function?section=4\" title=\"Edit\
      \ section: Simulated Engine Events\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>Events like Tick, <a href=\"/Legacy:Chain_Of_Events_At_Level_Startup\"\
      \ title=\"Legacy:Chain Of Events At Level Startup\">(Pre/Post/PostNet)BeginPlay</a>,\
      \ Destroyed, Timer, Begin/EndState and others are always called on the server\
      \ and the clients by the engine, but like other functions they will only be\
      \ executed if they are declared as <i>simulated</i>.</p>\n<p><b>There is no\
      \ synchronization between events on the server and the clients!</b> For example\
      \ the number of Tick() calls on a client can greatly differ from the number\
      \ of calls on the server. As mentioned above already, server and client have\
      \ independent timers and the same goes for states.</p>\n<h3><span class=\"mw-headline\"\
      \ id=\"Replication_Myth:_.22Simulated_Functions_Can_Only_Be_Called_From_Other_Simulated_Functions.22\"\
      >Replication Myth: \"Simulated Functions Can Only Be Called From Other Simulated\
      \ Functions\"</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\"\
      >[</span><a href=\"/edit/Legacy:Simulated_Function?section=5\" title=\"Edit\
      \ section: Replication Myth: &quot;Simulated Functions Can Only Be Called From\
      \ Other Simulated Functions&quot;\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h3>\n<p>This statement is an over-simplification and not true\
      \ at all. Simulated functions can actually be called from whichever function\
      \ you like, the only condition is that they actually <i>do</i> get called.</p>\n\
      <p>Think of function calls as messages consisting of:</p>\n<ol>\n<li>a function\
      \ specification,</li>\n<li>an object to call the function on and</li>\n<li>parameter\
      \ values.</li>\n</ol>\n<p>You can send as many of these messages around as you\
      \ like, but the engine will ignore them if certain conditions are not met, this\
      \ includes the constraint that the function needs to be <i>simulated</i> or\
      \ <i>native</i> when the function is called on non-authorative client instances\
      \ of an actor.</p>\n<p>So in order to call a simulated function all you need\
      \ is an object (actually an actor) containing the function. The engine really\
      \ doesn't care where the function call originated. For example the GUI is implemented\
      \ using classes not derived from Actor, so the functions in these classes don't\
      \ need to be simulated, yet there's no problem calling simulated functions from\
      \ them.</p>\n<h2><span class=\"mw-headline\" id=\"PlaySound.28.29_and_PlayOwnedSound.28.29_Replication_Magic\"\
      >PlaySound() and PlayOwnedSound() Replication Magic</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Simulated_Function?section=6\"\
      \ title=\"Edit section: PlaySound() and PlayOwnedSound() Replication Magic\"\
      >edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Most\
      \ functions do not care how they have been called. A noteable exception are\
      \ the native <a href=\"/Legacy:Actor\" title=\"Legacy:Actor\">Actor</a>.PlaySound()\
      \ and Actor.PlayOwnedSound() functions, which alter their behavior on the server\
      \ based on whether they have been called from a simulated function.</p>\n<dl>\n\
      <dt>PlaySound()&#160;</dt>\n<dd>This function plays the sound locally if it\
      \ was called on a client <i>or from a simulated function</i>. If called from\
      \ a non-simulated function on the server, it will broadcast the sound to all\
      \ clients.</dd>\n<dt>PlayOwnedSound()&#160;</dt>\n<dd>This function plays the\
      \ sound locally if it was called on a client. If called on the server, the sound\
      \ will be broadcasted to all clients with one exception: If the sound player\
      \ is a <a href=\"/Legacy:Pawn\" title=\"Legacy:Pawn\">Pawn</a> (or is owned\
      \ by a Pawn) and that Pawn is not controlled locally, then the client owning\
      \ this Pawn will not receive the sound.</dd>\n</dl>\n<h2><span class=\"mw-headline\"\
      \ id=\"Overriding_Simulated_Functions\">Overriding Simulated Functions</span><span\
      \ class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a\
      \ href=\"/edit/Legacy:Simulated_Function?section=7\" title=\"Edit section: Overriding\
      \ Simulated Functions\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n\
      <p>The <code>simulated</code> keyword is <i>not</i> inherited when you override\
      \ a (non)simulated function in a state or subclass. If the overridden function\
      \ is not simulated and your new function is, you will not be able to execute\
      \ Super.YourFunction() on clients, simply because that is a completely different\
      \ function which may not be executed on simulated proxies.</p>\n<p>If you override\
      \ a simulated function and don't declare the new function as simulated as well,\
      \ your new function can not be executed on simulated proxies. This also means\
      \ you have no chance to call Super.YourFunction(), so be careful with this.\
      \ A good way around this is:</p>\n<div dir=\"ltr\" class=\"mw-geshi mw-code\
      \ mw-content-ltr\">\n<div class=\"uscript source-uscript\">\n<pre class=\"de1\"\
      ><span class=\"kw1\">simulated</span> <span class=\"kw1\">function</span> OverriddenFunction<span\
      \ class=\"br0\">(</span><span class=\"br0\">)</span>\n<span class=\"br0\">{</span>\n\
      \  <span class=\"kw2\">if</span> <span class=\"br0\">(</span> <span class=\"\
      kw7\">Role</span> <span class=\"sy0\">==</span> <span class=\"kw7\">ROLE_Authority</span>\
      \ <span class=\"br0\">)</span> <span class=\"br0\">{</span>\n    <span class=\"\
      co1\">// put your new code here, it will only run on the server</span>\n  <span\
      \ class=\"br0\">}</span>\n  <span class=\"kw6\">Super</span>.<span class=\"\
      me0\">OverriddenFunction</span><span class=\"br0\">(</span><span class=\"br0\"\
      >)</span>;  <span class=\"co1\">// execute the super version on server and clients</span>\n\
      <span class=\"br0\">}</span></pre></div>\n</div>\n<h2><span class=\"mw-headline\"\
      \ id=\"Simulated_States\">Simulated States</span><span class=\"mw-editsection\"\
      ><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Simulated_Function?section=8\"\
      \ title=\"Edit section: Simulated States\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p><a href=\"/Legacy:State\" title=\"Legacy:State\">States</a>\
      \ can be declared <i>simulated</i> as well, but you will rarely need it as it\
      \ only applies to the state code outside any function.</p>\n<p>Clientside instances\
      \ of actors can always switch to states, whether these are declared simulated\
      \ or not. Functions in these states will override global (non-state) functions\
      \ with the same name as usual. The same rules apply as with functions overridden\
      \ in subclasses – neither the state's nor the overridden function's <i>simulated</i>\
      \ flag is inherited. In other words:</p>\n<ul>\n<li>You can have non-simulated\
      \ function in simulated states and they will behave like non-simulated functions.</li>\n\
      <li>You can have simulated functions in non-simulated states and they will behave\
      \ like simulated functions.</li>\n</ul>\n<p><b>Switching states is not synchronized\
      \ between server and clients!</b> Like with timers and other engine events,\
      \ states are changed independently.</p>\n<h2><span class=\"mw-headline\" id=\"\
      Related_Topics\">Related Topics</span><span class=\"mw-editsection\"><span class=\"\
      mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Simulated_Function?section=9\"\
      \ title=\"Edit section: Related Topics\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<ul>\n<li><a href=\"/Legacy:UnrealScript\" title=\"Legacy:UnrealScript\"\
      >UnrealScript</a>\n<ul>\n<li><a href=\"/Legacy:Replication\" title=\"Legacy:Replication\"\
      >Replication</a></li>\n<li><a href=\"/Legacy:Role\" title=\"Legacy:Role\">Role</a>\
      \ and RemoteRole</li>\n<li><a href=\"/Legacy:Replicated_Function\" title=\"\
      Legacy:Replicated Function\">Replicated Function</a></li>\n<li><a href=\"/Legacy:Function_Syntax\"\
      \ title=\"Legacy:Function Syntax\">Function Syntax</a></li>\n<li><a href=\"\
      /Legacy:State\" title=\"Legacy:State\">State</a></li>\n</ul>\n</li>\n</ul>\n\
      <h2><span class=\"mw-headline\" id=\"Discussion\">Discussion</span><span class=\"\
      mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/edit/Legacy:Simulated_Function?section=10\"\
      \ title=\"Edit section: Discussion\">edit</a><span class=\"mw-editsection-bracket\"\
      >]</span></span></h2>\n<p><b>Foxpaw:</b> I have a few questions about simulated\
      \ functions:</p>\n<ul>\n<li>If you declare an \"entry point\" as simulated,\
      \ will it get called on all clients? For instance, say I declare Tick as simulated..\
      \ does every client tick on it's own based on it's own framerate, or does the\
      \ server have to replicate the tick function?</li>\n</ul>\n<ul>\n<li>If entry\
      \ points are simulated automatically without being replicated, what will happen\
      \ if I set up a replication statement for that function? Will it be run twice,\
      \ or does the engine recognize the function in the replication statement and\
      \ thus run it only once? If so, is it the replicated or local version that gets\
      \ run?</li>\n</ul>\n<ul>\n<li>Variables are replicated only if they have been\
      \ changed.. if a variable is changed in a simulated function is it still considered\
      \ changed or does the engine assume that the client changed it itself and thus\
      \ it will still be in sync?</li>\n</ul>\n<ul>\n<li>As I understand it, simulated\
      \ functions can only call other simulated functions unless they are the authority\
      \ version. If a simulated function (non-authority version) calls a non-simulated\
      \ function, does the client simply ignore the call and proceed, or does it replicate\
      \ the function to the server, wait for a response, then continue the function\
      \ once the server has returned something?</li>\n</ul>\n<ul>\n<li>If a superclass\
      \ has a non-simulated function, and I override it and declare it as simulated,\
      \ is it simulated or non-simulated? Or does the stuff I wrote in the override\
      \ function simulate but not the Super.Function call? Or does the simulated call\
      \ override the previous non-simulated call and force the simulated behaviour\
      \ all the way up the class tree? What if a simulated function is overridden\
      \ but the overridden version doesn't use the simulated keyword. (it is declared\
      \ as non-simulated) Will the Super.Function still simulate instead of the overridden\
      \ function?</li>\n</ul>\n<p><b>Mr Evil:</b> I have a few answers about simulated\
      \ functions:</p>\n<ul>\n<li>They are automatically simulated. They are called\
      \ on the client automatically, not replicated, as a quick experiment will show\
      \ the bandwidth usage does not change if you simulate Tick.</li>\n<li>You can't\
      \ set up a replication statement for them, since you can't replicate anything\
      \ from a superclass, but have to have the replication statement in the class\
      \ in which the function/variable is declared.</li>\n<li>The engine knows nothing\
      \ about what variables are being changed on the client in simulated functions,\
      \ thus it goes ahead and replicates changed variables regardless of their client-side\
      \ values.</li>\n<li>Calls to non-simulated functions are simply ignored in this\
      \ case.</li>\n<li>You can simulate functions that are not simulated in a superclass\
      \ if you wish, but calls to super.blah() will not be simulated (I think).</li>\n\
      </ul>\n<p><b>Kamek:</b> I can say for sure that if the super version of a class\
      \ has a function defined with the simulated keyword and you leave this keyword\
      \ off of the overridden version of the subclass, NOTHING gets simulated. I had\
      \ this problem the other day in <a href=\"/Legacy:Postal_2\" title=\"Legacy:Postal\
      \ 2\">Postal 2</a> when I was inserting extra code into PostBeginPlay of a subclass\
      \ of <a href=\"/Legacy:PlayerController\" title=\"Legacy:PlayerController\"\
      >PlayerController</a>. One of the superclasses of my new controller (which in\
      \ itself was a subclass of <a href=\"/Legacy:PlayerController\" title=\"Legacy:PlayerController\"\
      >PlayerController</a>) had defined PostBeginPlay as a simulated event, which\
      \ initialized ragdoll skeletons. I left the \"simulated\" out of my new subclass\
      \ and lo and behold, ragdolls stopped working in netplay. Putting the simulated\
      \ keyword back in the function call made ragdolls work again. To make a long\
      \ story short, overriding a function declared as a simulated function without\
      \ the simulated keyword causes the ENTIRE function (and all of its Super.Blah()\
      \ calls) to be non-simulated.</p>\n<p><b>Lilguy:</b> Ok, just to clarify:</p>\n\
      <ul>\n<li>functions are never \"automatically simulated\". There are certain\
      \ events such as tick that are enabled on the client when they've been enabled\
      \ on the server, but if you write a simulated function and call it on the server,\
      \ it's not going to automatically be called on the client.</li>\n<li>you MUST\
      \ set up a replication statement for simulated functions if you ever want them\
      \ to be called on a client. You can't replicate functions/vars things differently\
      \ than a super class, but that's not to prevent you from declaring the function\
      \ as simulated and calling it from your own function, or writing your own replicated\
      \ simulated function from scratch.</li>\n<li>non-simulated functions are never\
      \ called on a client machine, unless they have RemoteRole = ROLE_AUTHORITY.\
      \ If you call a non simulated function from a simulated function, it will return\
      \ null if it's supposed to return an actor, will return false if it returns\
      \ a bool, and I think will return 0 if it was a number.</li>\n</ul>\n<p><b>EntropicLqd:</b>\
      \ Lilguy - Am I correct in thinking that for an Actor to have RemoteRole=ROLE_AUTHORITY\
      \ on a client machine that Actor <b>must</b> have been spawned on that machine.</p>\n\
      <p><b>Foxpaw:</b> Generally speaking, this will be the case. However, Unrealscript\
      \ can set the Role and RemoteRole to whatever it wants - they are not declared\
      \ as const variables. So technically, it doesn't <i>have</i> to have been spawned\
      \ on that machine - but almost invariably will be.</p>\n<p><b>Lilguy:</b> Yeah,\
      \ I think you can do it either way...If you want the client to have ROLE_AUTHORITY\
      \ and spawn it on the server, then you need to set RemoteRole = ROLE_AUTHORITY\
      \ (*I think*) because it swaps the roles when it replicates the actor. I'm looking\
      \ at the HUD, however, which is clientside only, and they have RemoteRole =\
      \ ROLE_NONE, which suggests to me that it is spawned on the client, RemoteRole\
      \ = Role_None tells it that it doesn't belong on the server. And now that I\
      \ think about it, setting Role = Role_none on the server and remoteRole = ROLE_AUTHORITY,\
      \ it wouldn't even get replicated to the client initially...I think there is\
      \ a different method for telling clients that they'll be the authority, but\
      \ I can't remember what it is. I'll look into it...</p>\n<p><b>EntropicLqd:</b>\
      \ Surely the meaning of RemoteRole is dependant upon where the Actor is spawned.\
      \ So Actors spawned on the server with a RemoteRole = ROLE_None never get transmitted\
      \ to the client machines. Conversely Actors spawned on a client with a RemoteRole\
      \ = ROLE_None will never get spawned on the server. I would guess that the best\
      \ way to spawn an Actor on the server that has authority on the client machine\
      \ would be to add some code within either the Actor's PostNetReceive() event\
      \ (if replicated variables were needed) or PostBeginPlay() event to set the\
      \ Role and RemoteRole appropriately. I've got to admit it seems way easier (and\
      \ maybe safer) to spawn the Actor on the machine where you want it to have authority.</p>\n\
      <p><b>Matariel:</b> I think the best way would be to set the actor's bTearOff\
      \ = true followed by one of these within the same tick</p>\n<div dir=\"ltr\"\
      \ class=\"mw-geshi mw-code mw-content-ltr\">\n<div class=\"uscript source-uscript\"\
      >\n<pre class=\"de1\"><span class=\"kw2\">if</span> <span class=\"br0\">(</span>NetMode\
      \ <span class=\"sy0\">==</span> NM_DedicatedServer<span class=\"br0\">)</span>\
      \ \n<span class=\"br0\">{</span>\n <span class=\"kw4\">Destroy</span><span class=\"\
      br0\">(</span><span class=\"br0\">)</span>;\n<span class=\"br0\">}</span></pre></div>\n\
      </div>\n<p><b>Wormbo:</b> The keyword <i>simulated</i> is only evaluated on\
      \ the local machine, so the value of RemoteRole is irrelevant, you're slightly\
      \ over-complicating the problem here. Everything you need to know about the\
      \ <i>Role</i> variable in connection with the <i>simulated</i> keyword are described\
      \ at the top of this page and on the page about <a href=\"/Legacy:Role\" title=\"\
      Legacy:Role\">Role</a> and RemoteRole:</p>\n<blockquote class=\"legacyquote\"\
      >\n<p>Simulated functions are allowed to be executed on any machine while non-simulated\
      \ functions require ROLE_AutonomousProxy or higher.<br />\nThe server's RemoteRole\
      \ becomes the client's Role.</p>\n</blockquote>\n<p>That's all – no \"they can\
      \ only be called from...\" or \"they can only call\" stuff. They can be called\
      \ from anywhere (as long as that calling function or state code is actually\
      \ executed) and they can call anything. Note the difference between calling\
      \ and executing functions again: whether the called function is actually executed\
      \ after it has been called from code depends on whether it's simulated, replicated\
      \ or whatever.<br />\nSame thing with function replication: You basically have\
      \ to see it as a totally different and mostly unrelated concept. You have two\
      \ machines and send function call <i>requests</i> (along with the function parameters)\
      \ between them if certain conditions are met. Again, that's all. You will only\
      \ get more difficulties with these already confusing topics if you start connecting\
      \ them before you understand them individually.&#160;;)<br />\nReplication is\
      \ for communication between a server and its clients. The <i>simulated</i> keyword\
      \ only tells, whether functions <i>may be executed</i> at all on a client. (also\
      \ on a server or stand-alone game, but there Role==ROLE_Authority makes all\
      \ functions pass the check)<br />\nOf course, these concepts have to be understood\
      \ both in order to be able to write working netcode, but at least in theory\
      \ you should separate them.</p>\n<p><b>Lilguy:</b> Yes, but suppose we have\
      \ a non-simulated function which returns a bool. We call it on the clientside\
      \ from some other function, and try to do something based on the value of what's\
      \ returned from that function. True, we can \"call\" it, but since it's not\
      \ executing, unreal script will return false, even though the function may have\
      \ returned true if it were \"executed.\" So I really don't think it's fair to\
      \ say you can seperate the two, they're really closely tied together with respect\
      \ to what codepath is actually executing.</p>\n<p><b>Foxpaw:</b> I suppose the\
      \ simplest way to sum it up is:</p>\n<p>A non-simulated function executes it's\
      \ normal function body only on a Role of ROLE_AutonomousProxy or better if owned\
      \ by the local player, or if it has ROLE_Authority regardless of owner. Otherwise\
      \ it just executes a blank function.</p>\n<p>A simulated function executes it's\
      \ normal function body only on a Role of ROLE_SimulatedProxy or better. Otherwise\
      \ it just executes a blank function.</p>\n<p>The only difference is the Role\
      \ required to get it to actually execute the code in the function, as opposed\
      \ to skipping said code.</p>\n<p>For the record, my personal preference is to\
      \ make every function simulated, and just put my own Role, RemoteRole, and Level.NetMode\
      \ checks in.</p>\n<p><b>Wormbo:</b> Lilguy, I said you have to <i>understand</i>\
      \ them separately because technically they are independant concepts. Of course\
      \ you usually need to apply them both and yes, in order to properly handle replicated\
      \ functions you need to know about simulated functions. For a tutorial, however,\
      \ it would also be possible to explain variable replication and simulated functions\
      \ before ever mentioning function replication. For learning this stuff it's\
      \ not really neccessary to talk about how to replicate functions before the\
      \ reader learned why some functions need the <i>simulated</i> keyword and others\
      \ don't.</p>\n<p><b>Lilguy:</b> The only reason I mentioned all of this was\
      \ to correct some blatently untrue statements (in the discussion, not the document)\
      \ that might confuse someone who was new to all this stuff. I don't know if\
      \ I agree that simulated functions and role are independent concepts though.\
      \ for instance, the statement \"non simulated functions cannot be called on\
      \ the client\" is only true part of the time, and to understant that you NEED\
      \ to understand what the role and remoterole are. I really don't see how any\
      \ two concepts could be more closely tied together...</p>\n<p>That said, I think\
      \ this is an excellent document just the way it is; The passing mention of role\
      \ at the beginning should be sufficient to make newcomers understand that they\
      \ need to look at the role stuff eventually. Could you clarify this sentence\
      \ though:</p>\n<p><i>\"Conversely, functions that aren't simulated can not be\
      \ called on clients in a network game, but there are non-simulated functions\
      \ which can be called from the client owning that actor\"</i></p>\n<p>What's\
      \ the difference between \"functions that aren't simulated\" and \"non-simulated\
      \ functions\"&#160;? If they are the same, then it seems the sentence contradicts\
      \ itself. May I suggest the following instead?</p>\n<p><i>Conversely, non-simulated\
      \ functions cannot be executed on a client in a network game, except in some\
      \ special cases where the client owning that actor is the authority on that\
      \ actor</i></p>\n<p>That way it doesn't say \"you can't do this, but, sometimes\
      \ you can...\"</p>\n<p>Maybe I'm just reading it wrong, so take this all with\
      \ a grain of salt of course...</p>\n<p><b>Tarquin:</b> Changed as suggested.\
      \ But you can change stuff in documents yourself&#160;:)</p>\n<p><b>Lilguy:</b>\
      \ My god Tarquin, do you ever sleep?&#160;:) thanks, I would have done it, but\
      \ I didn't want to step on any toes here...</p>\n<p><b>Tarquin:</b> I live in\
      \ the UK. It's breakfast time here&#160;:) One thing you could clear up is the\
      \ \"definition\" heading. I've cleaned up the intro &amp; added an example.</p>\n\
      <p><b>Wormbo:</b> Who said simulation and role were independant? I only said\
      \ simulated functions and replicated functions were two different things. Also\
      \ simulated functions check the local <i>Role</i>, not the local <i>RemoteRole</i>.</p>\n\
      <p><b>Lilguy:</b> Ok, one last post, then I'm going to leave this topic alone...\
      \ Sorry for the mis-understanding about what we were talking about Wormbo, it\
      \ seems once again I've managed to totally mangle the subject&#160;:(<br />\n\
      Yeah, simulated functions check the local role, but if this actor was spawned\
      \ at the other end of the pipeline first and replicated, then the local role\
      \ is equal to how the remoteRole was defined in script, so that's why I mentioned\
      \ it...</p>\n<p><b>karminax:</b> The simulated function tick(float dt) or weapontick\
      \ of a weapon hold by the player on the listening server isn't executed on clients,\
      \ even if their players see this player and his weapon. (I've checked that with\
      \ log messages). Why is that? Weapons are simulated proxys, so sim.tick should\
      \ be executed everywhere.</p>\n<p><b>Wormbo:</b> The weapon is only replicated\
      \ to the owning client. What you see is actually the weapon's <a href=\"/Legacy:InventoryAttachment\"\
      \ title=\"Legacy:InventoryAttachment\">InventoryAttachment</a>.</p>\n<p><b>Matariel:</b>\
      \ I suggest that we remove this discussion, it has outlived its usefulness and\
      \ it only confuses newcomers with outdated information. We should remove it\
      \ as soon as we get sufficient agreement on this course of action. If anyone\
      \ is against the removal of this discussion, please speak up.</p>\n<p><a href=\"\
      /Category:Legacy_Refactor_Me\" title=\"Category:Legacy Refactor Me\">Category:Legacy\
      \ Refactor Me</a></p>\n<hr />\n<p><a href=\"/Category:Legacy_Tutorial\" title=\"\
      Category:Legacy Tutorial\">Category:Legacy Tutorial</a><br />\n<a href=\"/Category:Legacy_Refactor_Me\"\
      \ title=\"Category:Legacy Refactor Me\">Category:Legacy Refactor Me</a><br />\n\
      <a href=\"/Category:Legacy_To_Do\" title=\"Category:Legacy To Do\">Category:Legacy\
      \ To Do</a> – This needs merged into the grand topic of <a href=\"/Legacy:Replication\"\
      \ title=\"Legacy:Replication\">Replication</a>. See <a href=\"/Legacy:Replication/Discussing\"\
      \ title=\"Legacy:Replication/Discussing\">Replication/Discussing</a></p>\n\n\
      <!-- \nNewPP limit report\nCPU time usage: 0.128 seconds\nReal time usage: 0.131\
      \ seconds\nPreprocessor visited node count: 80/1000000\nPreprocessor generated\
      \ node count: 203/1000000\nPost‐expand include size: 546/2097152 bytes\nTemplate\
      \ argument size: 189/2097152 bytes\nHighest expansion depth: 3/40\nExpensive\
      \ parser function count: 0/100\n-->\n\n<!-- \nTransclusion expansion time report\
      \ (%,ms,calls,template)\n100.00%    5.467      1 - -total\n100.00%    5.467\
      \      1 - Template:Innerbox\n-->\n\n<!-- Saved in parser cache with key wiki:pcache:idhash:2813-0!*!0!!en!*!*\
      \ and timestamp 20221118015703 and revision id 34537\n -->\n"
  categories:
  - sortkey: "Simulated Function"
    name: "Legacy_Tutorial"
  - sortkey: "Simulated Function"
    name: "Legacy_To_Do"
  - sortkey: "Simulated Function"
    name: "Legacy_Refactor_Me"
  links:
  - ns: 100
    exists: true
    name: "Legacy:Static Function"
  - ns: 100
    exists: true
    name: "Legacy:Replicated Function"
  - ns: 100
    exists: true
    name: "Legacy:Postal 2"
  - ns: 14
    exists: true
    name: "Category:Legacy Refactor Me"
  - ns: 100
    exists: true
    name: "Legacy:State"
  - ns: 100
    exists: true
    name: "Legacy:PlayerController"
  - ns: 14
    exists: true
    name: "Category:Legacy Tutorial"
  - ns: 100
    exists: true
    name: "Legacy:Function Syntax"
  - ns: 100
    exists: true
    name: "Legacy:Chain Of Events At Level Startup"
  - ns: 100
    exists: true
    name: "Legacy:Replication/Discussing"
  - ns: 100
    exists: true
    name: "Legacy:Replication"
  - ns: 14
    exists: true
    name: "Category:Legacy To Do"
  - ns: 100
    exists: true
    name: "Legacy:Role"
  - ns: 100
    exists: true
    name: "Legacy:Pawn"
  - ns: 100
    exists: true
    name: "Legacy:UnrealScript"
  - ns: 100
    exists: true
    name: "Legacy:InventoryAttachment"
  - ns: 100
    exists: true
    name: "Legacy:Function"
  - ns: 100
    exists: true
    name: "Legacy:Actor"
  templates:
  - ns: 10
    exists: true
    name: "Template:Innerbox"
  images: []
  externallinks: []
  sections:
  - toclevel: 1
    level: "2"
    line: "Strict Definition"
    number: "1"
    index: "1"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 568
    anchor: "Strict_Definition"
  - toclevel: 2
    level: "3"
    line: "Some Clarifications"
    number: "1.1"
    index: "2"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 874
    anchor: "Some_Clarifications"
  - toclevel: 1
    level: "2"
    line: "Executing Simulated Functions"
    number: "2"
    index: "3"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 1953
    anchor: "Executing_Simulated_Functions"
  - toclevel: 2
    level: "3"
    line: "Simulated Engine Events"
    number: "2.1"
    index: "4"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 3110
    anchor: "Simulated_Engine_Events"
  - toclevel: 2
    level: "3"
    line: "Replication Myth: \"Simulated Functions Can Only Be Called From Other Simulated\
      \ Functions\""
    number: "2.2"
    index: "5"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 3722
    anchor: "Replication_Myth:_.22Simulated_Functions_Can_Only_Be_Called_From_Other_Simulated_Functions.22"
  - toclevel: 1
    level: "2"
    line: "PlaySound() and PlayOwnedSound() Replication Magic"
    number: "3"
    index: "6"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 4829
    anchor: "PlaySound.28.29_and_PlayOwnedSound.28.29_Replication_Magic"
  - toclevel: 1
    level: "2"
    line: "Overriding Simulated Functions"
    number: "4"
    index: "7"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 5723
    anchor: "Overriding_Simulated_Functions"
  - toclevel: 1
    level: "2"
    line: "Simulated States"
    number: "5"
    index: "8"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 6642
    anchor: "Simulated_States"
  - toclevel: 1
    level: "2"
    line: "Related Topics"
    number: "6"
    index: "9"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 7553
    anchor: "Related_Topics"
  - toclevel: 1
    level: "2"
    line: "Discussion"
    number: "7"
    index: "10"
    fromtitle: "Legacy:Simulated_Function"
    byteoffset: 7815
    anchor: "Discussion"
  displaytitle: "Legacy:Simulated Function"
  iwlinks: []
  wikitext:
    text: "Roughly speaking, a '''simulated function''' is a function in an [[Legacy:Actor|Actor]]-derived\
      \ class that ''can'' be called on a client in a network game. \n\nConversely,\
      \ non-simulated functions in an Actor-derived class cannot be executed on a\
      \ client in a network game, except in some special cases where the client owning\
      \ that actor is the authority on that actor.\n\nSimulated functions are declared\
      \ with the [[Legacy:Function|function]] modifier keyword ''simulated'':\n\n\
      <uscript>\nsimulated function bool MyFunction(bool FirstParam)\n{\n // function\
      \ code\n}\n</uscript>\n\n\n==Strict Definition==\n\nFunctions that are called\
      \ in the context of an actor will not be executed if the [[Legacy:Actor|Actor]]'s\
      \ local [[Legacy:Role|Role]] (not RemoteRole!) is less than or equal to <code>ROLE_SimulatedProxy</code>\
      \ '''unless''' the function is declared as ''simulated'' or as ''native''.\n\
      \n===Some Clarifications===\n* An Actor's clientside Role takes the value of\
      \ the serverside RemoteRole and the clientside RemoteRole takes the serverside\
      \ value of Role. This definition talks about the local ''Role'' value.\n* \"\
      Less than or equal to <code>ROLE_SimulatedProxy</code>\" actually means <code>ROLE_SimulatedProxy</code>\
      \ or <code>ROLE_DumbProxy</code>. <code>ROLE_None</code> would also be \"less\
      \ than\" <code>ROLE_SimulatedProxy</code>, but this value prevents actors from\
      \ being replicated, so it should never appear as the value of the actor's local\
      \ Role.\n* Functions in object classes not derived from Actor are not affected\
      \ by network roles and thus will always execute.\n* [[Legacy:Static Function|Static\
      \ function]]s are executed in the context of a class (as opposed to the context\
      \ of an actor or other object), which means they are not affected by network\
      \ roles and thus will always execute.\n* It doesn't matter where the function\
      \ call originated. The definition described above is always applied if the function\
      \ is supposed to be executed in the context of an actor.\n\n==Executing Simulated\
      \ Functions ==\n\nBeing ''able'' to execute a function doesn't mean it ''will''\
      \ be executed. Function calls always stay on the same machine unless there's\
      \ a valid replication statement for the function. In that case the function\
      \ will only be executed on the machine the function call was replicated to.\n\
      \nThis means that you basically have two ways of executing a simulated function\
      \ client-side:\n# Call it from another client-side function. PostBeginPlay,\
      \ Tick or HitWall are good candidates for this. Beware of simulated Timer functions,\
      \ they will only be executed if SetTimer was actually executed on that machine,\
      \ i.e. if you set the timer on the server, then Timer will only be called on\
      \ the server, even if it is declared simulated. '''Server and client have independent\
      \ timers.'''\n# Replicate the function call from the server to the client. Note\
      \ that replicated functions can only be replicated to a single machine, either\
      \ from the client of the player owning this actor to the server or from the\
      \ server to the client of the player owning this actor. Replicated functions\
      \ will be executed '''only''' on the replication destination.\n\n===Simulated\
      \ Engine Events===\n\nEvents like Tick, [[Legacy:Chain Of Events At Level Startup|(Pre/Post/PostNet)BeginPlay]],\
      \ Destroyed, Timer, Begin/EndState and others are always called on the server\
      \ and the clients by the engine, but like other functions they will only be\
      \ executed if they are declared as ''simulated''.\n\n'''There is no synchronization\
      \ between events on the server and the clients!''' For example the number of\
      \ Tick() calls on a client can greatly differ from the number of calls on the\
      \ server. As mentioned above already, server and client have independent timers\
      \ and the same goes for states.\n\n=== Replication Myth: \"Simulated Functions\
      \ Can Only Be Called From Other Simulated Functions\" ===\n\nThis statement\
      \ is an over-simplification and not true at all. Simulated functions can actually\
      \ be called from whichever function you like, the only condition is that they\
      \ actually ''do'' get called.\n\nThink of function calls as messages consisting\
      \ of:\n# a function specification,\n# an object to call the function on and\n\
      # parameter values.\n\nYou can send as many of these messages around as you\
      \ like, but the engine will ignore them if certain conditions are not met, this\
      \ includes the constraint that the function needs to be ''simulated'' or ''native''\
      \ when the function is called on non-authorative client instances of an actor.\n\
      \nSo in order to call a simulated function all you need is an object (actually\
      \ an actor) containing the function. The engine really doesn't care where the\
      \ function call originated. For example the GUI is implemented using classes\
      \ not derived from Actor, so the functions in these classes don't need to be\
      \ simulated, yet there's no problem calling simulated functions from them.\n\
      \n==PlaySound() and PlayOwnedSound() Replication Magic==\n\nMost functions do\
      \ not care how they have been called. A noteable exception are the native [[Legacy:Actor|Actor]].PlaySound()\
      \ and Actor.PlayOwnedSound() functions, which alter their behavior on the server\
      \ based on whether they have been called from a simulated function.\n; PlaySound()\
      \ : This function plays the sound locally if it was called on a client ''or\
      \ from a simulated function''. If called from a non-simulated function on the\
      \ server, it will broadcast the sound to all clients.\n; PlayOwnedSound() :\
      \ This function plays the sound locally if it was called on a client. If called\
      \ on the server, the sound will be broadcasted to all clients with one exception:\
      \ If the sound player is a [[Legacy:Pawn|Pawn]] (or is owned by a Pawn) and\
      \ that Pawn is not controlled locally, then the client owning this Pawn will\
      \ not receive the sound.\n\n==Overriding Simulated Functions==\n\nThe <code>simulated</code>\
      \ keyword is ''not'' inherited when you override a (non)simulated function in\
      \ a state or subclass. If the overridden function is not simulated and your\
      \ new function is, you will not be able to execute Super.YourFunction() on clients,\
      \ simply because that is a completely different function which may not be executed\
      \ on simulated proxies.\n\nIf you override a simulated function and don't declare\
      \ the new function as simulated as well, your new function can not be executed\
      \ on simulated proxies. This also means you have no chance to call Super.YourFunction(),\
      \ so be careful with this. A good way around this is:\n\n<uscript>\nsimulated\
      \ function OverriddenFunction()\n{\n  if ( Role == ROLE_Authority ) {\n    //\
      \ put your new code here, it will only run on the server\n  }\n  Super.OverriddenFunction();\
      \  // execute the super version on server and clients\n}\n</uscript>\n\n==Simulated\
      \ States==\n\n[[Legacy:State|State]]s can be declared ''simulated'' as well,\
      \ but you will rarely need it as it only applies to the state code outside any\
      \ function.\n\nClientside instances of actors can always switch to states, whether\
      \ these are declared simulated or not. Functions in these states will override\
      \ global (non-state) functions with the same name as usual. The same rules apply\
      \ as with functions overridden in subclasses &ndash; neither the state's nor\
      \ the overridden function's ''simulated'' flag is inherited. In other words:\n\
      * You can have non-simulated function in simulated states and they will behave\
      \ like non-simulated functions.\n* You can have simulated functions in non-simulated\
      \ states and they will behave like simulated functions.\n\n'''Switching states\
      \ is not synchronized between server and clients!''' Like with timers and other\
      \ engine events, states are changed independently.\n\n==Related Topics==\n*\
      \ [[Legacy:UnrealScript|UnrealScript]]\n** [[Legacy:Replication|Replication]]\n\
      ** [[Legacy:Role|Role]] and RemoteRole\n** [[Legacy:Replicated Function|Replicated\
      \ Function]]\n** [[Legacy:Function Syntax|Function Syntax]]\n** [[Legacy:State|State]]\n\
      \n==Discussion==\n\n'''Foxpaw:''' I have a few questions about simulated functions:\n\
      * If you declare an \"entry point\" as simulated, will it get called on all\
      \ clients? For instance, say I declare Tick as simulated.. does every client\
      \ tick on it's own based on it's own framerate, or does the server have to replicate\
      \ the tick function?\n\n* If entry points are simulated automatically without\
      \ being replicated, what will happen if I set up a replication statement for\
      \ that function? Will it be run twice, or does the engine recognize the function\
      \ in the replication statement and thus run it only once? If so, is it the replicated\
      \ or local version that gets run?\n\n* Variables are replicated only if they\
      \ have been changed.. if a variable is changed in a simulated function is it\
      \ still considered changed or does the engine assume that the client changed\
      \ it itself and thus it will still be in sync?\n\n* As I understand it, simulated\
      \ functions can only call other simulated functions unless they are the authority\
      \ version. If a simulated function (non-authority version) calls a non-simulated\
      \ function, does the client simply ignore the call and proceed, or does it replicate\
      \ the function to the server, wait for a response, then continue the function\
      \ once the server has returned something?\n\n* If a superclass has a non-simulated\
      \ function, and I override it and declare it as simulated, is it simulated or\
      \ non-simulated? Or does the stuff I wrote in the override function simulate\
      \ but not the Super.Function call? Or does the simulated call override the previous\
      \ non-simulated call and force the simulated behaviour all the way up the class\
      \ tree? What if a simulated function is overridden but the overridden version\
      \ doesn't use the simulated keyword. (it is declared as non-simulated) Will\
      \ the Super.Function still simulate instead of the overridden function?\n\n\
      '''Mr Evil:''' I have a few answers about simulated functions:\n* They are automatically\
      \ simulated. They are called on the client automatically, not replicated, as\
      \ a quick experiment will show the bandwidth usage does not change if you simulate\
      \ Tick.\n* You can't set up a replication statement for them, since you can't\
      \ replicate anything from a superclass, but have to have the replication statement\
      \ in the class in which the function/variable is declared.\n* The engine knows\
      \ nothing about what variables are being changed on the client in simulated\
      \ functions, thus it goes ahead and replicates changed variables regardless\
      \ of their client-side values.\n* Calls to non-simulated functions are simply\
      \ ignored in this case.\n* You can simulate functions that are not simulated\
      \ in a superclass if you wish, but calls to super.blah() will not be simulated\
      \ (I think).\n\n'''Kamek:''' I can say for sure that if the super version of\
      \ a class has a function defined with the simulated keyword and you leave this\
      \ keyword off of the overridden version of the subclass, NOTHING gets simulated.\
      \ I had this problem the other day in [[Legacy:Postal 2|Postal 2]] when I was\
      \ inserting extra code into PostBeginPlay of a subclass of [[Legacy:PlayerController|PlayerController]].\
      \ One of the superclasses of my new controller (which in itself was a subclass\
      \ of [[Legacy:PlayerController|PlayerController]]) had defined PostBeginPlay\
      \ as a simulated event, which initialized ragdoll skeletons. I left the \"simulated\"\
      \ out of my new subclass and lo and behold, ragdolls stopped working in netplay.\
      \ Putting the simulated keyword back in the function call made ragdolls work\
      \ again. To make a long story short, overriding a function declared as a simulated\
      \ function without the simulated keyword causes the ENTIRE function (and all\
      \ of its Super.Blah() calls) to be non-simulated.\n\n'''Lilguy:''' Ok, just\
      \ to clarify:\n\n* functions are never \"automatically simulated\". There are\
      \ certain events such as tick that are enabled on the client when they've been\
      \ enabled on the server, but if you write a simulated function and call it on\
      \ the server, it's not going to automatically be called on the client.\n* you\
      \ MUST set up a replication statement for simulated functions if you ever want\
      \ them to be called on a client. You can't replicate functions/vars things differently\
      \ than a super class, but that's not to prevent you from declaring the function\
      \ as simulated and calling it from your own function, or writing your own replicated\
      \ simulated function from scratch.\n* non-simulated functions are never called\
      \ on a client machine, unless they have RemoteRole = ROLE_AUTHORITY. If you\
      \ call a non simulated function from a simulated function, it will return null\
      \ if it's supposed to return an actor, will return false if it returns a bool,\
      \ and I think will return 0 if it was a number.\n\n'''EntropicLqd:''' Lilguy\
      \ - Am I correct in thinking that for an Actor to have RemoteRole=ROLE_AUTHORITY\
      \ on a client machine that Actor '''must''' have been spawned on that machine.\n\
      \n'''Foxpaw:''' Generally speaking, this will be the case. However, Unrealscript\
      \ can set the Role and RemoteRole to whatever it wants - they are not declared\
      \ as const variables. So technically, it doesn't ''have'' to have been spawned\
      \ on that machine - but almost invariably will be.\n\n'''Lilguy:''' Yeah, I\
      \ think you can do it either way...If you want the client to have ROLE_AUTHORITY\
      \ and spawn it on the server, then you need to set RemoteRole = ROLE_AUTHORITY\
      \ (*I think*) because it swaps the roles when it replicates the actor. I'm looking\
      \ at the HUD, however, which is clientside only, and they have RemoteRole =\
      \ ROLE_NONE, which suggests to me that it is spawned on the client, RemoteRole\
      \ = Role_None tells it that it doesn't belong on the server. And now that I\
      \ think about it, setting Role = Role_none on the server and remoteRole = ROLE_AUTHORITY,\
      \ it wouldn't even get replicated to the client initially...I think there is\
      \ a different method for telling clients that they'll be the authority, but\
      \ I can't remember what it is. I'll look into it...\n\n'''EntropicLqd:''' Surely\
      \ the meaning of RemoteRole is dependant upon where the Actor is spawned.  So\
      \ Actors spawned on the server with a RemoteRole = ROLE_None never get transmitted\
      \ to the client machines.  Conversely Actors spawned on a client with a RemoteRole\
      \ = ROLE_None will never get spawned on the server.  I would guess that the\
      \ best way to spawn an Actor on the server that has authority on the client\
      \ machine would be to add some code within either the Actor's PostNetReceive()\
      \ event (if replicated variables were needed) or PostBeginPlay() event to set\
      \ the Role and RemoteRole appropriately.  I've got to admit it seems way easier\
      \ (and maybe safer) to spawn the Actor on the machine where you want it to have\
      \ authority.\n\n'''Matariel:''' I think the best way would be to set the actor's\
      \ bTearOff = true followed by one of these within the same tick\n\n<uscript>\n\
      if (NetMode == NM_DedicatedServer) \n{\n Destroy();\n}\n</uscript>\n\n'''Wormbo:'''\
      \ The keyword ''simulated'' is only evaluated on the local machine, so the value\
      \ of RemoteRole is irrelevant, you're slightly over-complicating the problem\
      \ here. Everything you need to know about the ''Role'' variable in connection\
      \ with the ''simulated'' keyword are described at the top of this page and on\
      \ the page about [[Legacy:Role|Role]] and RemoteRole:\n\n{{innerbox|Simulated\
      \ functions are allowed to be executed on any machine while non-simulated functions\
      \ require ROLE_AutonomousProxy or higher.<br />The server's RemoteRole becomes\
      \ the client's Role.\n\n}}\n\nThat's all &ndash; no \"they can only be called\
      \ from...\" or \"they can only call\" stuff. They can be called from anywhere\
      \ (as long as that calling function or state code is actually executed) and\
      \ they can call anything. Note the difference between calling and executing\
      \ functions again: whether the called function is actually executed after it\
      \ has been called from code depends on whether it's simulated, replicated or\
      \ whatever.<br />Same thing with function replication: You basically have to\
      \ see it as a totally different and mostly unrelated concept. You have two machines\
      \ and send function call ''requests'' (along with the function parameters) between\
      \ them if certain conditions are met. Again, that's all. You will only get more\
      \ difficulties with these already confusing topics if you start connecting them\
      \ before you understand them individually. ;)<br />Replication is for communication\
      \ between a server and its clients. The ''simulated'' keyword only tells, whether\
      \ functions ''may be executed'' at all on a client. (also on a server or stand-alone\
      \ game, but there Role==ROLE_Authority makes all functions pass the check)<br\
      \ />Of course, these concepts have to be understood both in order to be able\
      \ to write working netcode, but at least in theory you should separate them.\n\
      \n'''Lilguy:''' Yes, but suppose we have a non-simulated function which returns\
      \ a bool. We call it on the clientside from some other function, and try to\
      \ do something based on the value of what's returned from that function. True,\
      \ we can \"call\" it, but since it's not executing, unreal script will return\
      \ false, even though the function may have returned true if it were \"executed.\"\
      \ So I really don't think it's fair to say you can seperate the two, they're\
      \ really closely tied together with respect to what codepath is actually executing.\n\
      \n'''Foxpaw:''' I suppose the simplest way to sum it up is:\n\nA non-simulated\
      \ function executes it's normal function body only on a Role of ROLE_AutonomousProxy\
      \ or better if owned by the local player, or if it has ROLE_Authority regardless\
      \ of owner. Otherwise it just executes a blank function.\n\nA simulated function\
      \ executes it's normal function body only on a Role of ROLE_SimulatedProxy or\
      \ better. Otherwise it just executes a blank function.\n\nThe only difference\
      \ is the Role required to get it to actually execute the code in the function,\
      \ as opposed to skipping said code.\n\nFor the record, my personal preference\
      \ is to make every function simulated, and just put my own Role, RemoteRole,\
      \ and Level.NetMode checks in.\n\n'''Wormbo:''' Lilguy, I said you have to ''understand''\
      \ them separately because technically they are independant concepts. Of course\
      \ you usually need to apply them both and yes, in order to properly handle replicated\
      \ functions you need to know about simulated functions. For a tutorial, however,\
      \ it would also be possible to explain variable replication and simulated functions\
      \ before ever mentioning function replication. For learning this stuff it's\
      \ not really neccessary to talk about how to replicate functions before the\
      \ reader learned why some functions need the ''simulated'' keyword and others\
      \ don't.\n\n'''Lilguy:''' The only reason I mentioned all of this was to correct\
      \ some blatently untrue statements (in the discussion, not the document) that\
      \ might confuse someone who was new to all this stuff. I don't know if I agree\
      \ that simulated functions and role are independent concepts though. for instance,\
      \ the statement \"non simulated functions cannot be called on the client\" is\
      \ only true part of the time, and to understant that you NEED to understand\
      \ what the role and remoterole are. I really don't see how any two concepts\
      \ could be more closely tied together...\n\nThat said, I think this is an excellent\
      \ document just the way it is; The passing mention of role at the beginning\
      \ should be sufficient to make newcomers understand that they need to look at\
      \ the role stuff eventually. Could you clarify this sentence though:\n\n''\"\
      Conversely, functions that aren't simulated can not be called on clients in\
      \ a network game, but there are non-simulated functions which can be called\
      \ from the client owning that actor\"''\n\nWhat's the difference between \"\
      functions that aren't simulated\" and \"non-simulated functions\" ? If they\
      \ are the same, then it seems the sentence contradicts itself. May I suggest\
      \ the following instead?\n\n''Conversely, non-simulated functions cannot be\
      \ executed on a client in a network game, except in some special cases where\
      \ the client owning that actor is the authority on that actor''\n\nThat way\
      \ it doesn't say \"you can't do this, but, sometimes you can...\"\n\nMaybe I'm\
      \ just reading it wrong, so take this all with a grain of salt of course...\n\
      \n'''Tarquin:''' Changed as suggested. But you can change stuff in documents\
      \ yourself :)\n\n'''Lilguy:''' My god Tarquin, do you ever sleep? :) thanks,\
      \ I would have done it, but I didn't want to step on any toes here...\n\n'''Tarquin:'''\
      \ I live in the UK. It's breakfast time here :) One thing you could clear up\
      \ is the \"definition\" heading. I've cleaned up the intro & added an example.\n\
      \n'''Wormbo:''' Who said simulation and role were independant? I only said simulated\
      \ functions and replicated functions were two different things. Also simulated\
      \ functions check the local ''Role'', not the local ''RemoteRole''.\n\n'''Lilguy:'''\
      \ Ok, one last post, then I'm going to leave this topic alone... Sorry for the\
      \ mis-understanding about what we were talking about Wormbo, it seems once again\
      \ I've managed to totally mangle the subject :( <br />Yeah, simulated functions\
      \ check the local role, but if this actor was spawned at the other end of the\
      \ pipeline first and replicated, then the local role is equal to how the remoteRole\
      \ was defined in script, so that's why I mentioned it...\n\n'''karminax:'''\
      \ The simulated function tick(float dt) or weapontick of a weapon hold by the\
      \ player on the listening server isn't executed on clients, even if their players\
      \ see this player and his weapon. (I've checked that with log messages). Why\
      \ is that? Weapons are simulated proxys, so sim.tick should be executed everywhere.\n\
      \n'''Wormbo:''' The weapon is only replicated to the owning client. What you\
      \ see is actually the weapon's [[Legacy:InventoryAttachment|InventoryAttachment]].\n\
      \n'''Matariel:''' I suggest that we remove this discussion, it has outlived\
      \ its usefulness and it only confuses newcomers with outdated information. We\
      \ should remove it as soon as we get sufficient agreement on this course of\
      \ action. If anyone is against the removal of this discussion, please speak\
      \ up.\n\n[[:Category:Legacy Refactor Me]]\n\n----\n\n[[:Category:Legacy Tutorial]]<br\
      \ />[[:Category:Legacy Refactor Me]]<br />[[:Category:Legacy To Do]] &ndash;\
      \ This needs merged into the grand topic of [[Legacy:Replication|Replication]].\
      \ See [[Legacy:Replication/Discussing|Replication/Discussing]]\n[[Category:Legacy\
      \ Refactor Me|{{PAGENAME}}]]\n[[Category:Legacy Tutorial|{{PAGENAME}}]]\n[[Category:Legacy\
      \ Refactor Me|{{PAGENAME}}]]\n[[Category:Legacy To Do|{{PAGENAME}}]]"
  properties: []
  revId: 34537
name: "Legacy:Simulated Function"
revision:
  revid: 34537
  parentid: 34481
  user: "84.57.182.70"
  timestamp: 1247912322.000000000
  comment: "/* PlayOwnedSound() and PlayOwnedSound() Replication Magic */"
timestamp: 1668764353.109839000
